Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     declare -> decvars decfuncs main_block
Rule 3     main_block -> MAIN changecontext LPAREN RPAREN block
Rule 4     block -> LCURLY decvars blockcontent RCURLY
Rule 5     returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
Rule 6     blockcontent -> empty
Rule 7     blockcontent -> statute blockcontent
Rule 8     decvars -> empty
Rule 9     decvars -> VARS decvar_line
Rule 10    decvar_line -> type decvar SEMICOLON decvar_line
Rule 11    decvar_line -> type decvar SEMICOLON
Rule 12    decvar -> var COMMA decvar
Rule 13    decvar -> var
Rule 14    var -> FLOAT
Rule 15    var -> INT
Rule 16    var -> ELSE
Rule 17    var -> IF
Rule 18    var -> PRINT
Rule 19    var -> INPUT
Rule 20    var -> WHILE
Rule 21    var -> DO
Rule 22    var -> BY
Rule 23    var -> TO
Rule 24    var -> FROM
Rule 25    var -> VOID
Rule 26    var -> RETURN
Rule 27    var -> FUNC
Rule 28    var -> MAIN
Rule 29    var -> VARS
Rule 30    var -> PROGRAM
Rule 31    var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
Rule 32    var -> ID LBRACKET CTEINT RBRACKET
Rule 33    var -> ID
Rule 34    decfuncs -> empty
Rule 35    decfuncs -> func decfuncs
Rule 36    func -> FUNC typefunc
Rule 37    func -> FUNC voidfunc
Rule 38    voidfunc -> VOID ID changecontext LPAREN params RPAREN block
Rule 39    typefunc -> type ID changecontext LPAREN params RPAREN returnblock
Rule 40    params -> empty
Rule 41    params -> type ID COMMA params
Rule 42    params -> type ID
Rule 43    call -> ID LPAREN callvalues RPAREN
Rule 44    callvalues -> empty
Rule 45    callvalues -> exp COMMA callvalues
Rule 46    callvalues -> exp
Rule 47    super_exp_aux -> logic super_exp
Rule 48    super_exp_aux -> empty
Rule 49    super_exp -> expression super_exp_quadgen super_exp_aux
Rule 50    logic -> OR
Rule 51    logic -> AND
Rule 52    super_exp_quadgen -> <empty>
Rule 53    expression_aux -> relation expression
Rule 54    expression_aux -> empty
Rule 55    expression -> exp expression_quadgen expression_aux
Rule 56    relation -> NEQ
Rule 57    relation -> EQ
Rule 58    relation -> LTE
Rule 59    relation -> GTE
Rule 60    relation -> LT
Rule 61    relation -> GT
Rule 62    expression_quadgen -> <empty>
Rule 63    exp_aux -> exp_sign exp
Rule 64    exp_aux -> empty
Rule 65    exp -> term exp_quadgen exp_aux
Rule 66    exp_sign -> MINUS
Rule 67    exp_sign -> PLUS
Rule 68    exp_quadgen -> <empty>
Rule 69    term_aux -> term_sign term
Rule 70    term_aux -> empty
Rule 71    term -> factor term_quadgen term_aux
Rule 72    term_sign -> DIVIDE
Rule 73    term_sign -> TIMES
Rule 74    term_quadgen -> <empty>
Rule 75    factor -> LPAREN fakefloor super_exp RPAREN
Rule 76    factor -> varcte
Rule 77    factor -> call
Rule 78    factor -> var
Rule 79    fakefloor -> <empty>
Rule 80    forloop -> FROM var ASSIGN expression TO expression BY expression DO block
Rule 81    forloop -> FROM var ASSIGN expression TO expression DO block
Rule 82    whileloop -> WHILE LPAREN expression RPAREN block
Rule 83    assignment -> ID ASSIGN expression SEMICOLON
Rule 84    read -> INPUT LPAREN decvar RPAREN SEMICOLON
Rule 85    write -> PRINT LPAREN writevalues RPAREN SEMICOLON
Rule 86    writevalues -> CTESTRING COMMA writevalues
Rule 87    writevalues -> super_exp COMMA writevalues
Rule 88    writevalues -> CTESTRING
Rule 89    writevalues -> super_exp
Rule 90    condition -> IF LPAREN expression RPAREN block ELSE block
Rule 91    condition -> IF LPAREN expression RPAREN block
Rule 92    varcte -> CTEFLOAT
Rule 93    varcte -> CTEINT
Rule 94    type -> FLOAT
Rule 95    type -> INT
Rule 96    statute -> call
Rule 97    statute -> forloop
Rule 98    statute -> whileloop
Rule 99    statute -> read
Rule 100   statute -> write
Rule 101   statute -> condition
Rule 102   statute -> assignment
Rule 103   changecontext -> <empty>
Rule 104   saveprogramname -> <empty>
Rule 105   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 51
ASSIGN               : 80 81 83
BY                   : 22 80
COMMA                : 12 41 45 86 87
CTEFLOAT             : 92
CTEINT               : 31 31 32 93
CTESTRING            : 86 88
DIVIDE               : 72
DO                   : 21 80 81
ELSE                 : 16 90
EQ                   : 57
FLOAT                : 14 94
FROM                 : 24 80 81
FUNC                 : 27 36 37
GT                   : 61
GTE                  : 59
ID                   : 1 31 32 33 38 39 41 42 43 83
IF                   : 17 90 91
INPUT                : 19 84
INT                  : 15 95
LBRACKET             : 31 31 32
LCURLY               : 4 5
LPAREN               : 3 38 39 43 75 82 84 85 90 91
LT                   : 60
LTE                  : 58
MAIN                 : 3 28
MINUS                : 66
NEQ                  : 56
OR                   : 50
PLUS                 : 67
PRINT                : 18 85
PROGRAM              : 1 30
RBRACKET             : 31 31 32
RCURLY               : 4 5
RETURN               : 5 26
RPAREN               : 3 38 39 43 75 82 84 85 90 91
SEMICOLON            : 5 10 11 83 84 85
TIMES                : 73
TO                   : 23 80 81
VARS                 : 9 29
VOID                 : 25 38
WHILE                : 20 82
error                : 

Nonterminals, with rules where they appear:

assignment           : 102
block                : 3 38 80 81 82 90 90 91
blockcontent         : 4 5 7
call                 : 77 96
callvalues           : 43 45
changecontext        : 3 38 39
condition            : 101
decfuncs             : 2 35
declare              : 1
decvar               : 10 11 12 84
decvar_line          : 9 10
decvars              : 2 4 5
empty                : 6 8 34 40 44 48 54 64 70
exp                  : 5 45 46 55 63
exp_aux              : 65
exp_quadgen          : 65
exp_sign             : 63
expression           : 49 53 80 80 80 81 81 82 83 90 91
expression_aux       : 55
expression_quadgen   : 55
factor               : 71
fakefloor            : 75
forloop              : 97
func                 : 35
logic                : 47
main_block           : 2
params               : 38 39 41
program              : 0
read                 : 99
relation             : 53
returnblock          : 39
saveprogramname      : 1
statute              : 7
super_exp            : 47 75 87 89
super_exp_aux        : 49
super_exp_quadgen    : 49
term                 : 65 69
term_aux             : 71
term_quadgen         : 71
term_sign            : 69
type                 : 10 11 39 41 42
typefunc             : 36
var                  : 12 13 78 80 81
varcte               : 76
voidfunc             : 37
whileloop            : 98
write                : 100
writevalues          : 85 86 87


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (104) saveprogramname -> .
    VARS            reduce using rule 104 (saveprogramname -> .)
    FUNC            reduce using rule 104 (saveprogramname -> .)
    MAIN            reduce using rule 104 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (2) declare -> . decvars decfuncs main_block
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (105) empty -> .
    VARS            shift and go to state 8
    FUNC            reduce using rule 105 (empty -> .)
    MAIN            reduce using rule 105 (empty -> .)

    declare                        shift and go to state 5
    decvars                        shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (2) declare -> decvars . decfuncs main_block
    (34) decfuncs -> . empty
    (35) decfuncs -> . func decfuncs
    (105) empty -> .
    (36) func -> . FUNC typefunc
    (37) func -> . FUNC voidfunc
    MAIN            reduce using rule 105 (empty -> .)
    FUNC            shift and go to state 12

    decfuncs                       shift and go to state 9
    empty                          shift and go to state 10
    func                           shift and go to state 11

state 7

    (8) decvars -> empty .
    FUNC            reduce using rule 8 (decvars -> empty .)
    MAIN            reduce using rule 8 (decvars -> empty .)
    ID              reduce using rule 8 (decvars -> empty .)
    FROM            reduce using rule 8 (decvars -> empty .)
    WHILE           reduce using rule 8 (decvars -> empty .)
    INPUT           reduce using rule 8 (decvars -> empty .)
    PRINT           reduce using rule 8 (decvars -> empty .)
    IF              reduce using rule 8 (decvars -> empty .)
    RCURLY          reduce using rule 8 (decvars -> empty .)
    RETURN          reduce using rule 8 (decvars -> empty .)


state 8

    (9) decvars -> VARS . decvar_line
    (10) decvar_line -> . type decvar SEMICOLON decvar_line
    (11) decvar_line -> . type decvar SEMICOLON
    (94) type -> . FLOAT
    (95) type -> . INT
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    decvar_line                    shift and go to state 13
    type                           shift and go to state 14

state 9

    (2) declare -> decvars decfuncs . main_block
    (3) main_block -> . MAIN changecontext LPAREN RPAREN block
    MAIN            shift and go to state 18

    main_block                     shift and go to state 17

state 10

    (34) decfuncs -> empty .
    MAIN            reduce using rule 34 (decfuncs -> empty .)


state 11

    (35) decfuncs -> func . decfuncs
    (34) decfuncs -> . empty
    (35) decfuncs -> . func decfuncs
    (105) empty -> .
    (36) func -> . FUNC typefunc
    (37) func -> . FUNC voidfunc
    MAIN            reduce using rule 105 (empty -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 11
    decfuncs                       shift and go to state 19
    empty                          shift and go to state 10

state 12

    (36) func -> FUNC . typefunc
    (37) func -> FUNC . voidfunc
    (39) typefunc -> . type ID changecontext LPAREN params RPAREN returnblock
    (38) voidfunc -> . VOID ID changecontext LPAREN params RPAREN block
    (94) type -> . FLOAT
    (95) type -> . INT
    VOID            shift and go to state 23
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    typefunc                       shift and go to state 20
    voidfunc                       shift and go to state 21
    type                           shift and go to state 22

state 13

    (9) decvars -> VARS decvar_line .
    FUNC            reduce using rule 9 (decvars -> VARS decvar_line .)
    MAIN            reduce using rule 9 (decvars -> VARS decvar_line .)
    ID              reduce using rule 9 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 9 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 9 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 9 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 9 (decvars -> VARS decvar_line .)
    IF              reduce using rule 9 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 9 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 9 (decvars -> VARS decvar_line .)


state 14

    (10) decvar_line -> type . decvar SEMICOLON decvar_line
    (11) decvar_line -> type . decvar SEMICOLON
    (12) decvar -> . var COMMA decvar
    (13) decvar -> . var
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    decvar                         shift and go to state 24
    var                            shift and go to state 25

state 15

    (94) type -> FLOAT .
    FLOAT           reduce using rule 94 (type -> FLOAT .)
    INT             reduce using rule 94 (type -> FLOAT .)
    ELSE            reduce using rule 94 (type -> FLOAT .)
    IF              reduce using rule 94 (type -> FLOAT .)
    PRINT           reduce using rule 94 (type -> FLOAT .)
    INPUT           reduce using rule 94 (type -> FLOAT .)
    WHILE           reduce using rule 94 (type -> FLOAT .)
    DO              reduce using rule 94 (type -> FLOAT .)
    BY              reduce using rule 94 (type -> FLOAT .)
    TO              reduce using rule 94 (type -> FLOAT .)
    FROM            reduce using rule 94 (type -> FLOAT .)
    VOID            reduce using rule 94 (type -> FLOAT .)
    RETURN          reduce using rule 94 (type -> FLOAT .)
    FUNC            reduce using rule 94 (type -> FLOAT .)
    MAIN            reduce using rule 94 (type -> FLOAT .)
    VARS            reduce using rule 94 (type -> FLOAT .)
    PROGRAM         reduce using rule 94 (type -> FLOAT .)
    ID              reduce using rule 94 (type -> FLOAT .)


state 16

    (95) type -> INT .
    FLOAT           reduce using rule 95 (type -> INT .)
    INT             reduce using rule 95 (type -> INT .)
    ELSE            reduce using rule 95 (type -> INT .)
    IF              reduce using rule 95 (type -> INT .)
    PRINT           reduce using rule 95 (type -> INT .)
    INPUT           reduce using rule 95 (type -> INT .)
    WHILE           reduce using rule 95 (type -> INT .)
    DO              reduce using rule 95 (type -> INT .)
    BY              reduce using rule 95 (type -> INT .)
    TO              reduce using rule 95 (type -> INT .)
    FROM            reduce using rule 95 (type -> INT .)
    VOID            reduce using rule 95 (type -> INT .)
    RETURN          reduce using rule 95 (type -> INT .)
    FUNC            reduce using rule 95 (type -> INT .)
    MAIN            reduce using rule 95 (type -> INT .)
    VARS            reduce using rule 95 (type -> INT .)
    PROGRAM         reduce using rule 95 (type -> INT .)
    ID              reduce using rule 95 (type -> INT .)


state 17

    (2) declare -> decvars decfuncs main_block .
    $end            reduce using rule 2 (declare -> decvars decfuncs main_block .)


state 18

    (3) main_block -> MAIN . changecontext LPAREN RPAREN block
    (103) changecontext -> .
    LPAREN          reduce using rule 103 (changecontext -> .)

    changecontext                  shift and go to state 44

state 19

    (35) decfuncs -> func decfuncs .
    MAIN            reduce using rule 35 (decfuncs -> func decfuncs .)


state 20

    (36) func -> FUNC typefunc .
    FUNC            reduce using rule 36 (func -> FUNC typefunc .)
    MAIN            reduce using rule 36 (func -> FUNC typefunc .)


state 21

    (37) func -> FUNC voidfunc .
    FUNC            reduce using rule 37 (func -> FUNC voidfunc .)
    MAIN            reduce using rule 37 (func -> FUNC voidfunc .)


state 22

    (39) typefunc -> type . ID changecontext LPAREN params RPAREN returnblock
    ID              shift and go to state 45


state 23

    (38) voidfunc -> VOID . ID changecontext LPAREN params RPAREN block
    ID              shift and go to state 46


state 24

    (10) decvar_line -> type decvar . SEMICOLON decvar_line
    (11) decvar_line -> type decvar . SEMICOLON
    SEMICOLON       shift and go to state 47


state 25

    (12) decvar -> var . COMMA decvar
    (13) decvar -> var .
    COMMA           shift and go to state 48
    SEMICOLON       reduce using rule 13 (decvar -> var .)
    RPAREN          reduce using rule 13 (decvar -> var .)


state 26

    (14) var -> FLOAT .
    COMMA           reduce using rule 14 (var -> FLOAT .)
    SEMICOLON       reduce using rule 14 (var -> FLOAT .)
    RPAREN          reduce using rule 14 (var -> FLOAT .)
    ASSIGN          reduce using rule 14 (var -> FLOAT .)
    DIVIDE          reduce using rule 14 (var -> FLOAT .)
    TIMES           reduce using rule 14 (var -> FLOAT .)
    MINUS           reduce using rule 14 (var -> FLOAT .)
    PLUS            reduce using rule 14 (var -> FLOAT .)
    NEQ             reduce using rule 14 (var -> FLOAT .)
    EQ              reduce using rule 14 (var -> FLOAT .)
    LTE             reduce using rule 14 (var -> FLOAT .)
    GTE             reduce using rule 14 (var -> FLOAT .)
    LT              reduce using rule 14 (var -> FLOAT .)
    GT              reduce using rule 14 (var -> FLOAT .)
    OR              reduce using rule 14 (var -> FLOAT .)
    AND             reduce using rule 14 (var -> FLOAT .)
    TO              reduce using rule 14 (var -> FLOAT .)
    BY              reduce using rule 14 (var -> FLOAT .)
    DO              reduce using rule 14 (var -> FLOAT .)


state 27

    (15) var -> INT .
    COMMA           reduce using rule 15 (var -> INT .)
    SEMICOLON       reduce using rule 15 (var -> INT .)
    RPAREN          reduce using rule 15 (var -> INT .)
    ASSIGN          reduce using rule 15 (var -> INT .)
    DIVIDE          reduce using rule 15 (var -> INT .)
    TIMES           reduce using rule 15 (var -> INT .)
    MINUS           reduce using rule 15 (var -> INT .)
    PLUS            reduce using rule 15 (var -> INT .)
    NEQ             reduce using rule 15 (var -> INT .)
    EQ              reduce using rule 15 (var -> INT .)
    LTE             reduce using rule 15 (var -> INT .)
    GTE             reduce using rule 15 (var -> INT .)
    LT              reduce using rule 15 (var -> INT .)
    GT              reduce using rule 15 (var -> INT .)
    OR              reduce using rule 15 (var -> INT .)
    AND             reduce using rule 15 (var -> INT .)
    TO              reduce using rule 15 (var -> INT .)
    BY              reduce using rule 15 (var -> INT .)
    DO              reduce using rule 15 (var -> INT .)


state 28

    (16) var -> ELSE .
    COMMA           reduce using rule 16 (var -> ELSE .)
    SEMICOLON       reduce using rule 16 (var -> ELSE .)
    RPAREN          reduce using rule 16 (var -> ELSE .)
    ASSIGN          reduce using rule 16 (var -> ELSE .)
    DIVIDE          reduce using rule 16 (var -> ELSE .)
    TIMES           reduce using rule 16 (var -> ELSE .)
    MINUS           reduce using rule 16 (var -> ELSE .)
    PLUS            reduce using rule 16 (var -> ELSE .)
    NEQ             reduce using rule 16 (var -> ELSE .)
    EQ              reduce using rule 16 (var -> ELSE .)
    LTE             reduce using rule 16 (var -> ELSE .)
    GTE             reduce using rule 16 (var -> ELSE .)
    LT              reduce using rule 16 (var -> ELSE .)
    GT              reduce using rule 16 (var -> ELSE .)
    OR              reduce using rule 16 (var -> ELSE .)
    AND             reduce using rule 16 (var -> ELSE .)
    TO              reduce using rule 16 (var -> ELSE .)
    BY              reduce using rule 16 (var -> ELSE .)
    DO              reduce using rule 16 (var -> ELSE .)


state 29

    (17) var -> IF .
    COMMA           reduce using rule 17 (var -> IF .)
    SEMICOLON       reduce using rule 17 (var -> IF .)
    RPAREN          reduce using rule 17 (var -> IF .)
    ASSIGN          reduce using rule 17 (var -> IF .)
    DIVIDE          reduce using rule 17 (var -> IF .)
    TIMES           reduce using rule 17 (var -> IF .)
    MINUS           reduce using rule 17 (var -> IF .)
    PLUS            reduce using rule 17 (var -> IF .)
    NEQ             reduce using rule 17 (var -> IF .)
    EQ              reduce using rule 17 (var -> IF .)
    LTE             reduce using rule 17 (var -> IF .)
    GTE             reduce using rule 17 (var -> IF .)
    LT              reduce using rule 17 (var -> IF .)
    GT              reduce using rule 17 (var -> IF .)
    OR              reduce using rule 17 (var -> IF .)
    AND             reduce using rule 17 (var -> IF .)
    TO              reduce using rule 17 (var -> IF .)
    BY              reduce using rule 17 (var -> IF .)
    DO              reduce using rule 17 (var -> IF .)


state 30

    (18) var -> PRINT .
    COMMA           reduce using rule 18 (var -> PRINT .)
    SEMICOLON       reduce using rule 18 (var -> PRINT .)
    RPAREN          reduce using rule 18 (var -> PRINT .)
    ASSIGN          reduce using rule 18 (var -> PRINT .)
    DIVIDE          reduce using rule 18 (var -> PRINT .)
    TIMES           reduce using rule 18 (var -> PRINT .)
    MINUS           reduce using rule 18 (var -> PRINT .)
    PLUS            reduce using rule 18 (var -> PRINT .)
    NEQ             reduce using rule 18 (var -> PRINT .)
    EQ              reduce using rule 18 (var -> PRINT .)
    LTE             reduce using rule 18 (var -> PRINT .)
    GTE             reduce using rule 18 (var -> PRINT .)
    LT              reduce using rule 18 (var -> PRINT .)
    GT              reduce using rule 18 (var -> PRINT .)
    OR              reduce using rule 18 (var -> PRINT .)
    AND             reduce using rule 18 (var -> PRINT .)
    TO              reduce using rule 18 (var -> PRINT .)
    BY              reduce using rule 18 (var -> PRINT .)
    DO              reduce using rule 18 (var -> PRINT .)


state 31

    (19) var -> INPUT .
    COMMA           reduce using rule 19 (var -> INPUT .)
    SEMICOLON       reduce using rule 19 (var -> INPUT .)
    RPAREN          reduce using rule 19 (var -> INPUT .)
    ASSIGN          reduce using rule 19 (var -> INPUT .)
    DIVIDE          reduce using rule 19 (var -> INPUT .)
    TIMES           reduce using rule 19 (var -> INPUT .)
    MINUS           reduce using rule 19 (var -> INPUT .)
    PLUS            reduce using rule 19 (var -> INPUT .)
    NEQ             reduce using rule 19 (var -> INPUT .)
    EQ              reduce using rule 19 (var -> INPUT .)
    LTE             reduce using rule 19 (var -> INPUT .)
    GTE             reduce using rule 19 (var -> INPUT .)
    LT              reduce using rule 19 (var -> INPUT .)
    GT              reduce using rule 19 (var -> INPUT .)
    OR              reduce using rule 19 (var -> INPUT .)
    AND             reduce using rule 19 (var -> INPUT .)
    TO              reduce using rule 19 (var -> INPUT .)
    BY              reduce using rule 19 (var -> INPUT .)
    DO              reduce using rule 19 (var -> INPUT .)


state 32

    (20) var -> WHILE .
    COMMA           reduce using rule 20 (var -> WHILE .)
    SEMICOLON       reduce using rule 20 (var -> WHILE .)
    RPAREN          reduce using rule 20 (var -> WHILE .)
    ASSIGN          reduce using rule 20 (var -> WHILE .)
    DIVIDE          reduce using rule 20 (var -> WHILE .)
    TIMES           reduce using rule 20 (var -> WHILE .)
    MINUS           reduce using rule 20 (var -> WHILE .)
    PLUS            reduce using rule 20 (var -> WHILE .)
    NEQ             reduce using rule 20 (var -> WHILE .)
    EQ              reduce using rule 20 (var -> WHILE .)
    LTE             reduce using rule 20 (var -> WHILE .)
    GTE             reduce using rule 20 (var -> WHILE .)
    LT              reduce using rule 20 (var -> WHILE .)
    GT              reduce using rule 20 (var -> WHILE .)
    OR              reduce using rule 20 (var -> WHILE .)
    AND             reduce using rule 20 (var -> WHILE .)
    TO              reduce using rule 20 (var -> WHILE .)
    BY              reduce using rule 20 (var -> WHILE .)
    DO              reduce using rule 20 (var -> WHILE .)


state 33

    (21) var -> DO .
    COMMA           reduce using rule 21 (var -> DO .)
    SEMICOLON       reduce using rule 21 (var -> DO .)
    RPAREN          reduce using rule 21 (var -> DO .)
    ASSIGN          reduce using rule 21 (var -> DO .)
    DIVIDE          reduce using rule 21 (var -> DO .)
    TIMES           reduce using rule 21 (var -> DO .)
    MINUS           reduce using rule 21 (var -> DO .)
    PLUS            reduce using rule 21 (var -> DO .)
    NEQ             reduce using rule 21 (var -> DO .)
    EQ              reduce using rule 21 (var -> DO .)
    LTE             reduce using rule 21 (var -> DO .)
    GTE             reduce using rule 21 (var -> DO .)
    LT              reduce using rule 21 (var -> DO .)
    GT              reduce using rule 21 (var -> DO .)
    OR              reduce using rule 21 (var -> DO .)
    AND             reduce using rule 21 (var -> DO .)
    TO              reduce using rule 21 (var -> DO .)
    BY              reduce using rule 21 (var -> DO .)
    DO              reduce using rule 21 (var -> DO .)


state 34

    (22) var -> BY .
    COMMA           reduce using rule 22 (var -> BY .)
    SEMICOLON       reduce using rule 22 (var -> BY .)
    RPAREN          reduce using rule 22 (var -> BY .)
    ASSIGN          reduce using rule 22 (var -> BY .)
    DIVIDE          reduce using rule 22 (var -> BY .)
    TIMES           reduce using rule 22 (var -> BY .)
    MINUS           reduce using rule 22 (var -> BY .)
    PLUS            reduce using rule 22 (var -> BY .)
    NEQ             reduce using rule 22 (var -> BY .)
    EQ              reduce using rule 22 (var -> BY .)
    LTE             reduce using rule 22 (var -> BY .)
    GTE             reduce using rule 22 (var -> BY .)
    LT              reduce using rule 22 (var -> BY .)
    GT              reduce using rule 22 (var -> BY .)
    OR              reduce using rule 22 (var -> BY .)
    AND             reduce using rule 22 (var -> BY .)
    TO              reduce using rule 22 (var -> BY .)
    BY              reduce using rule 22 (var -> BY .)
    DO              reduce using rule 22 (var -> BY .)


state 35

    (23) var -> TO .
    COMMA           reduce using rule 23 (var -> TO .)
    SEMICOLON       reduce using rule 23 (var -> TO .)
    RPAREN          reduce using rule 23 (var -> TO .)
    ASSIGN          reduce using rule 23 (var -> TO .)
    DIVIDE          reduce using rule 23 (var -> TO .)
    TIMES           reduce using rule 23 (var -> TO .)
    MINUS           reduce using rule 23 (var -> TO .)
    PLUS            reduce using rule 23 (var -> TO .)
    NEQ             reduce using rule 23 (var -> TO .)
    EQ              reduce using rule 23 (var -> TO .)
    LTE             reduce using rule 23 (var -> TO .)
    GTE             reduce using rule 23 (var -> TO .)
    LT              reduce using rule 23 (var -> TO .)
    GT              reduce using rule 23 (var -> TO .)
    OR              reduce using rule 23 (var -> TO .)
    AND             reduce using rule 23 (var -> TO .)
    TO              reduce using rule 23 (var -> TO .)
    BY              reduce using rule 23 (var -> TO .)
    DO              reduce using rule 23 (var -> TO .)


state 36

    (24) var -> FROM .
    COMMA           reduce using rule 24 (var -> FROM .)
    SEMICOLON       reduce using rule 24 (var -> FROM .)
    RPAREN          reduce using rule 24 (var -> FROM .)
    ASSIGN          reduce using rule 24 (var -> FROM .)
    DIVIDE          reduce using rule 24 (var -> FROM .)
    TIMES           reduce using rule 24 (var -> FROM .)
    MINUS           reduce using rule 24 (var -> FROM .)
    PLUS            reduce using rule 24 (var -> FROM .)
    NEQ             reduce using rule 24 (var -> FROM .)
    EQ              reduce using rule 24 (var -> FROM .)
    LTE             reduce using rule 24 (var -> FROM .)
    GTE             reduce using rule 24 (var -> FROM .)
    LT              reduce using rule 24 (var -> FROM .)
    GT              reduce using rule 24 (var -> FROM .)
    OR              reduce using rule 24 (var -> FROM .)
    AND             reduce using rule 24 (var -> FROM .)
    TO              reduce using rule 24 (var -> FROM .)
    BY              reduce using rule 24 (var -> FROM .)
    DO              reduce using rule 24 (var -> FROM .)


state 37

    (25) var -> VOID .
    COMMA           reduce using rule 25 (var -> VOID .)
    SEMICOLON       reduce using rule 25 (var -> VOID .)
    RPAREN          reduce using rule 25 (var -> VOID .)
    ASSIGN          reduce using rule 25 (var -> VOID .)
    DIVIDE          reduce using rule 25 (var -> VOID .)
    TIMES           reduce using rule 25 (var -> VOID .)
    MINUS           reduce using rule 25 (var -> VOID .)
    PLUS            reduce using rule 25 (var -> VOID .)
    NEQ             reduce using rule 25 (var -> VOID .)
    EQ              reduce using rule 25 (var -> VOID .)
    LTE             reduce using rule 25 (var -> VOID .)
    GTE             reduce using rule 25 (var -> VOID .)
    LT              reduce using rule 25 (var -> VOID .)
    GT              reduce using rule 25 (var -> VOID .)
    OR              reduce using rule 25 (var -> VOID .)
    AND             reduce using rule 25 (var -> VOID .)
    TO              reduce using rule 25 (var -> VOID .)
    BY              reduce using rule 25 (var -> VOID .)
    DO              reduce using rule 25 (var -> VOID .)


state 38

    (26) var -> RETURN .
    COMMA           reduce using rule 26 (var -> RETURN .)
    SEMICOLON       reduce using rule 26 (var -> RETURN .)
    RPAREN          reduce using rule 26 (var -> RETURN .)
    ASSIGN          reduce using rule 26 (var -> RETURN .)
    DIVIDE          reduce using rule 26 (var -> RETURN .)
    TIMES           reduce using rule 26 (var -> RETURN .)
    MINUS           reduce using rule 26 (var -> RETURN .)
    PLUS            reduce using rule 26 (var -> RETURN .)
    NEQ             reduce using rule 26 (var -> RETURN .)
    EQ              reduce using rule 26 (var -> RETURN .)
    LTE             reduce using rule 26 (var -> RETURN .)
    GTE             reduce using rule 26 (var -> RETURN .)
    LT              reduce using rule 26 (var -> RETURN .)
    GT              reduce using rule 26 (var -> RETURN .)
    OR              reduce using rule 26 (var -> RETURN .)
    AND             reduce using rule 26 (var -> RETURN .)
    TO              reduce using rule 26 (var -> RETURN .)
    BY              reduce using rule 26 (var -> RETURN .)
    DO              reduce using rule 26 (var -> RETURN .)


state 39

    (27) var -> FUNC .
    COMMA           reduce using rule 27 (var -> FUNC .)
    SEMICOLON       reduce using rule 27 (var -> FUNC .)
    RPAREN          reduce using rule 27 (var -> FUNC .)
    ASSIGN          reduce using rule 27 (var -> FUNC .)
    DIVIDE          reduce using rule 27 (var -> FUNC .)
    TIMES           reduce using rule 27 (var -> FUNC .)
    MINUS           reduce using rule 27 (var -> FUNC .)
    PLUS            reduce using rule 27 (var -> FUNC .)
    NEQ             reduce using rule 27 (var -> FUNC .)
    EQ              reduce using rule 27 (var -> FUNC .)
    LTE             reduce using rule 27 (var -> FUNC .)
    GTE             reduce using rule 27 (var -> FUNC .)
    LT              reduce using rule 27 (var -> FUNC .)
    GT              reduce using rule 27 (var -> FUNC .)
    OR              reduce using rule 27 (var -> FUNC .)
    AND             reduce using rule 27 (var -> FUNC .)
    TO              reduce using rule 27 (var -> FUNC .)
    BY              reduce using rule 27 (var -> FUNC .)
    DO              reduce using rule 27 (var -> FUNC .)


state 40

    (28) var -> MAIN .
    COMMA           reduce using rule 28 (var -> MAIN .)
    SEMICOLON       reduce using rule 28 (var -> MAIN .)
    RPAREN          reduce using rule 28 (var -> MAIN .)
    ASSIGN          reduce using rule 28 (var -> MAIN .)
    DIVIDE          reduce using rule 28 (var -> MAIN .)
    TIMES           reduce using rule 28 (var -> MAIN .)
    MINUS           reduce using rule 28 (var -> MAIN .)
    PLUS            reduce using rule 28 (var -> MAIN .)
    NEQ             reduce using rule 28 (var -> MAIN .)
    EQ              reduce using rule 28 (var -> MAIN .)
    LTE             reduce using rule 28 (var -> MAIN .)
    GTE             reduce using rule 28 (var -> MAIN .)
    LT              reduce using rule 28 (var -> MAIN .)
    GT              reduce using rule 28 (var -> MAIN .)
    OR              reduce using rule 28 (var -> MAIN .)
    AND             reduce using rule 28 (var -> MAIN .)
    TO              reduce using rule 28 (var -> MAIN .)
    BY              reduce using rule 28 (var -> MAIN .)
    DO              reduce using rule 28 (var -> MAIN .)


state 41

    (29) var -> VARS .
    COMMA           reduce using rule 29 (var -> VARS .)
    SEMICOLON       reduce using rule 29 (var -> VARS .)
    RPAREN          reduce using rule 29 (var -> VARS .)
    ASSIGN          reduce using rule 29 (var -> VARS .)
    DIVIDE          reduce using rule 29 (var -> VARS .)
    TIMES           reduce using rule 29 (var -> VARS .)
    MINUS           reduce using rule 29 (var -> VARS .)
    PLUS            reduce using rule 29 (var -> VARS .)
    NEQ             reduce using rule 29 (var -> VARS .)
    EQ              reduce using rule 29 (var -> VARS .)
    LTE             reduce using rule 29 (var -> VARS .)
    GTE             reduce using rule 29 (var -> VARS .)
    LT              reduce using rule 29 (var -> VARS .)
    GT              reduce using rule 29 (var -> VARS .)
    OR              reduce using rule 29 (var -> VARS .)
    AND             reduce using rule 29 (var -> VARS .)
    TO              reduce using rule 29 (var -> VARS .)
    BY              reduce using rule 29 (var -> VARS .)
    DO              reduce using rule 29 (var -> VARS .)


state 42

    (30) var -> PROGRAM .
    COMMA           reduce using rule 30 (var -> PROGRAM .)
    SEMICOLON       reduce using rule 30 (var -> PROGRAM .)
    RPAREN          reduce using rule 30 (var -> PROGRAM .)
    ASSIGN          reduce using rule 30 (var -> PROGRAM .)
    DIVIDE          reduce using rule 30 (var -> PROGRAM .)
    TIMES           reduce using rule 30 (var -> PROGRAM .)
    MINUS           reduce using rule 30 (var -> PROGRAM .)
    PLUS            reduce using rule 30 (var -> PROGRAM .)
    NEQ             reduce using rule 30 (var -> PROGRAM .)
    EQ              reduce using rule 30 (var -> PROGRAM .)
    LTE             reduce using rule 30 (var -> PROGRAM .)
    GTE             reduce using rule 30 (var -> PROGRAM .)
    LT              reduce using rule 30 (var -> PROGRAM .)
    GT              reduce using rule 30 (var -> PROGRAM .)
    OR              reduce using rule 30 (var -> PROGRAM .)
    AND             reduce using rule 30 (var -> PROGRAM .)
    TO              reduce using rule 30 (var -> PROGRAM .)
    BY              reduce using rule 30 (var -> PROGRAM .)
    DO              reduce using rule 30 (var -> PROGRAM .)


state 43

    (31) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID . LBRACKET CTEINT RBRACKET
    (33) var -> ID .
    LBRACKET        shift and go to state 49
    COMMA           reduce using rule 33 (var -> ID .)
    SEMICOLON       reduce using rule 33 (var -> ID .)
    RPAREN          reduce using rule 33 (var -> ID .)
    ASSIGN          reduce using rule 33 (var -> ID .)


state 44

    (3) main_block -> MAIN changecontext . LPAREN RPAREN block
    LPAREN          shift and go to state 50


state 45

    (39) typefunc -> type ID . changecontext LPAREN params RPAREN returnblock
    (103) changecontext -> .
    LPAREN          reduce using rule 103 (changecontext -> .)

    changecontext                  shift and go to state 51

state 46

    (38) voidfunc -> VOID ID . changecontext LPAREN params RPAREN block
    (103) changecontext -> .
    LPAREN          reduce using rule 103 (changecontext -> .)

    changecontext                  shift and go to state 52

state 47

    (10) decvar_line -> type decvar SEMICOLON . decvar_line
    (11) decvar_line -> type decvar SEMICOLON .
    (10) decvar_line -> . type decvar SEMICOLON decvar_line
    (11) decvar_line -> . type decvar SEMICOLON
    (94) type -> . FLOAT
    (95) type -> . INT
    FUNC            reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    MAIN            reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    ID              reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    FROM            reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    WHILE           reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    INPUT           reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    PRINT           reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    IF              reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    RCURLY          reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    RETURN          reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    type                           shift and go to state 14
    decvar_line                    shift and go to state 53

state 48

    (12) decvar -> var COMMA . decvar
    (12) decvar -> . var COMMA decvar
    (13) decvar -> . var
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    var                            shift and go to state 25
    decvar                         shift and go to state 54

state 49

    (31) var -> ID LBRACKET . CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 55


state 50

    (3) main_block -> MAIN changecontext LPAREN . RPAREN block
    RPAREN          shift and go to state 56


state 51

    (39) typefunc -> type ID changecontext . LPAREN params RPAREN returnblock
    LPAREN          shift and go to state 57


state 52

    (38) voidfunc -> VOID ID changecontext . LPAREN params RPAREN block
    LPAREN          shift and go to state 58


state 53

    (10) decvar_line -> type decvar SEMICOLON decvar_line .
    FUNC            reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    MAIN            reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)


state 54

    (12) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 12 (decvar -> var COMMA decvar .)
    RPAREN          reduce using rule 12 (decvar -> var COMMA decvar .)


state 55

    (31) var -> ID LBRACKET CTEINT . RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 59


state 56

    (3) main_block -> MAIN changecontext LPAREN RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 60

state 57

    (39) typefunc -> type ID changecontext LPAREN . params RPAREN returnblock
    (40) params -> . empty
    (41) params -> . type ID COMMA params
    (42) params -> . type ID
    (105) empty -> .
    (94) type -> . FLOAT
    (95) type -> . INT
    RPAREN          reduce using rule 105 (empty -> .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    type                           shift and go to state 62
    params                         shift and go to state 63
    empty                          shift and go to state 64

state 58

    (38) voidfunc -> VOID ID changecontext LPAREN . params RPAREN block
    (40) params -> . empty
    (41) params -> . type ID COMMA params
    (42) params -> . type ID
    (105) empty -> .
    (94) type -> . FLOAT
    (95) type -> . INT
    RPAREN          reduce using rule 105 (empty -> .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    params                         shift and go to state 65
    empty                          shift and go to state 64
    type                           shift and go to state 62

state 59

    (31) var -> ID LBRACKET CTEINT RBRACKET . LBRACKET CTEINT RBRACKET
    (32) var -> ID LBRACKET CTEINT RBRACKET .
    LBRACKET        shift and go to state 66
    COMMA           reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    BY              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)


state 60

    (3) main_block -> MAIN changecontext LPAREN RPAREN block .
    $end            reduce using rule 3 (main_block -> MAIN changecontext LPAREN RPAREN block .)


state 61

    (4) block -> LCURLY . decvars blockcontent RCURLY
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (105) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 105 (empty -> .)
    FROM            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    INPUT           reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    RCURLY          reduce using rule 105 (empty -> .)

    decvars                        shift and go to state 67
    empty                          shift and go to state 7

state 62

    (41) params -> type . ID COMMA params
    (42) params -> type . ID
    ID              shift and go to state 68


state 63

    (39) typefunc -> type ID changecontext LPAREN params . RPAREN returnblock
    RPAREN          shift and go to state 69


state 64

    (40) params -> empty .
    RPAREN          reduce using rule 40 (params -> empty .)


state 65

    (38) voidfunc -> VOID ID changecontext LPAREN params . RPAREN block
    RPAREN          shift and go to state 70


state 66

    (31) var -> ID LBRACKET CTEINT RBRACKET LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 71


state 67

    (4) block -> LCURLY decvars . blockcontent RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (105) empty -> .
    (96) statute -> . call
    (97) statute -> . forloop
    (98) statute -> . whileloop
    (99) statute -> . read
    (100) statute -> . write
    (101) statute -> . condition
    (102) statute -> . assignment
    (43) call -> . ID LPAREN callvalues RPAREN
    (80) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (81) forloop -> . FROM var ASSIGN expression TO expression DO block
    (82) whileloop -> . WHILE LPAREN expression RPAREN block
    (84) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (85) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (90) condition -> . IF LPAREN expression RPAREN block ELSE block
    (91) condition -> . IF LPAREN expression RPAREN block
    (83) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 105 (empty -> .)
    ID              shift and go to state 82
    FROM            shift and go to state 83
    WHILE           shift and go to state 84
    INPUT           shift and go to state 85
    PRINT           shift and go to state 86
    IF              shift and go to state 87

    blockcontent                   shift and go to state 72
    empty                          shift and go to state 73
    statute                        shift and go to state 74
    call                           shift and go to state 75
    forloop                        shift and go to state 76
    whileloop                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    condition                      shift and go to state 80
    assignment                     shift and go to state 81

state 68

    (41) params -> type ID . COMMA params
    (42) params -> type ID .
    COMMA           shift and go to state 88
    RPAREN          reduce using rule 42 (params -> type ID .)


state 69

    (39) typefunc -> type ID changecontext LPAREN params RPAREN . returnblock
    (5) returnblock -> . LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
    LCURLY          shift and go to state 90

    returnblock                    shift and go to state 89

state 70

    (38) voidfunc -> VOID ID changecontext LPAREN params RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 91

state 71

    (31) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 92


state 72

    (4) block -> LCURLY decvars blockcontent . RCURLY
    RCURLY          shift and go to state 93


state 73

    (6) blockcontent -> empty .
    RCURLY          reduce using rule 6 (blockcontent -> empty .)
    RETURN          reduce using rule 6 (blockcontent -> empty .)


state 74

    (7) blockcontent -> statute . blockcontent
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (105) empty -> .
    (96) statute -> . call
    (97) statute -> . forloop
    (98) statute -> . whileloop
    (99) statute -> . read
    (100) statute -> . write
    (101) statute -> . condition
    (102) statute -> . assignment
    (43) call -> . ID LPAREN callvalues RPAREN
    (80) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (81) forloop -> . FROM var ASSIGN expression TO expression DO block
    (82) whileloop -> . WHILE LPAREN expression RPAREN block
    (84) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (85) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (90) condition -> . IF LPAREN expression RPAREN block ELSE block
    (91) condition -> . IF LPAREN expression RPAREN block
    (83) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    ID              shift and go to state 82
    FROM            shift and go to state 83
    WHILE           shift and go to state 84
    INPUT           shift and go to state 85
    PRINT           shift and go to state 86
    IF              shift and go to state 87

    statute                        shift and go to state 74
    blockcontent                   shift and go to state 94
    empty                          shift and go to state 73
    call                           shift and go to state 75
    forloop                        shift and go to state 76
    whileloop                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    condition                      shift and go to state 80
    assignment                     shift and go to state 81

state 75

    (96) statute -> call .
    ID              reduce using rule 96 (statute -> call .)
    FROM            reduce using rule 96 (statute -> call .)
    WHILE           reduce using rule 96 (statute -> call .)
    INPUT           reduce using rule 96 (statute -> call .)
    PRINT           reduce using rule 96 (statute -> call .)
    IF              reduce using rule 96 (statute -> call .)
    RCURLY          reduce using rule 96 (statute -> call .)
    RETURN          reduce using rule 96 (statute -> call .)


state 76

    (97) statute -> forloop .
    ID              reduce using rule 97 (statute -> forloop .)
    FROM            reduce using rule 97 (statute -> forloop .)
    WHILE           reduce using rule 97 (statute -> forloop .)
    INPUT           reduce using rule 97 (statute -> forloop .)
    PRINT           reduce using rule 97 (statute -> forloop .)
    IF              reduce using rule 97 (statute -> forloop .)
    RCURLY          reduce using rule 97 (statute -> forloop .)
    RETURN          reduce using rule 97 (statute -> forloop .)


state 77

    (98) statute -> whileloop .
    ID              reduce using rule 98 (statute -> whileloop .)
    FROM            reduce using rule 98 (statute -> whileloop .)
    WHILE           reduce using rule 98 (statute -> whileloop .)
    INPUT           reduce using rule 98 (statute -> whileloop .)
    PRINT           reduce using rule 98 (statute -> whileloop .)
    IF              reduce using rule 98 (statute -> whileloop .)
    RCURLY          reduce using rule 98 (statute -> whileloop .)
    RETURN          reduce using rule 98 (statute -> whileloop .)


state 78

    (99) statute -> read .
    ID              reduce using rule 99 (statute -> read .)
    FROM            reduce using rule 99 (statute -> read .)
    WHILE           reduce using rule 99 (statute -> read .)
    INPUT           reduce using rule 99 (statute -> read .)
    PRINT           reduce using rule 99 (statute -> read .)
    IF              reduce using rule 99 (statute -> read .)
    RCURLY          reduce using rule 99 (statute -> read .)
    RETURN          reduce using rule 99 (statute -> read .)


state 79

    (100) statute -> write .
    ID              reduce using rule 100 (statute -> write .)
    FROM            reduce using rule 100 (statute -> write .)
    WHILE           reduce using rule 100 (statute -> write .)
    INPUT           reduce using rule 100 (statute -> write .)
    PRINT           reduce using rule 100 (statute -> write .)
    IF              reduce using rule 100 (statute -> write .)
    RCURLY          reduce using rule 100 (statute -> write .)
    RETURN          reduce using rule 100 (statute -> write .)


state 80

    (101) statute -> condition .
    ID              reduce using rule 101 (statute -> condition .)
    FROM            reduce using rule 101 (statute -> condition .)
    WHILE           reduce using rule 101 (statute -> condition .)
    INPUT           reduce using rule 101 (statute -> condition .)
    PRINT           reduce using rule 101 (statute -> condition .)
    IF              reduce using rule 101 (statute -> condition .)
    RCURLY          reduce using rule 101 (statute -> condition .)
    RETURN          reduce using rule 101 (statute -> condition .)


state 81

    (102) statute -> assignment .
    ID              reduce using rule 102 (statute -> assignment .)
    FROM            reduce using rule 102 (statute -> assignment .)
    WHILE           reduce using rule 102 (statute -> assignment .)
    INPUT           reduce using rule 102 (statute -> assignment .)
    PRINT           reduce using rule 102 (statute -> assignment .)
    IF              reduce using rule 102 (statute -> assignment .)
    RCURLY          reduce using rule 102 (statute -> assignment .)
    RETURN          reduce using rule 102 (statute -> assignment .)


state 82

    (43) call -> ID . LPAREN callvalues RPAREN
    (83) assignment -> ID . ASSIGN expression SEMICOLON
    LPAREN          shift and go to state 95
    ASSIGN          shift and go to state 96


state 83

    (80) forloop -> FROM . var ASSIGN expression TO expression BY expression DO block
    (81) forloop -> FROM . var ASSIGN expression TO expression DO block
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    var                            shift and go to state 97

state 84

    (82) whileloop -> WHILE . LPAREN expression RPAREN block
    LPAREN          shift and go to state 98


state 85

    (84) read -> INPUT . LPAREN decvar RPAREN SEMICOLON
    LPAREN          shift and go to state 99


state 86

    (85) write -> PRINT . LPAREN writevalues RPAREN SEMICOLON
    LPAREN          shift and go to state 100


state 87

    (90) condition -> IF . LPAREN expression RPAREN block ELSE block
    (91) condition -> IF . LPAREN expression RPAREN block
    LPAREN          shift and go to state 101


state 88

    (41) params -> type ID COMMA . params
    (40) params -> . empty
    (41) params -> . type ID COMMA params
    (42) params -> . type ID
    (105) empty -> .
    (94) type -> . FLOAT
    (95) type -> . INT
    RPAREN          reduce using rule 105 (empty -> .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    type                           shift and go to state 62
    params                         shift and go to state 102
    empty                          shift and go to state 64

state 89

    (39) typefunc -> type ID changecontext LPAREN params RPAREN returnblock .
    FUNC            reduce using rule 39 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)
    MAIN            reduce using rule 39 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)


state 90

    (5) returnblock -> LCURLY . decvars blockcontent RETURN exp SEMICOLON RCURLY
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (105) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 105 (empty -> .)
    FROM            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    INPUT           reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)

    decvars                        shift and go to state 103
    empty                          shift and go to state 7

state 91

    (38) voidfunc -> VOID ID changecontext LPAREN params RPAREN block .
    FUNC            reduce using rule 38 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)
    MAIN            reduce using rule 38 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)


state 92

    (31) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .
    COMMA           reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    BY              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)


state 93

    (4) block -> LCURLY decvars blockcontent RCURLY .
    $end            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    FUNC            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    MAIN            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    ID              reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    FROM            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    WHILE           reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    INPUT           reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    PRINT           reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    IF              reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    RCURLY          reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    RETURN          reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    ELSE            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)


state 94

    (7) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 7 (blockcontent -> statute blockcontent .)
    RETURN          reduce using rule 7 (blockcontent -> statute blockcontent .)


state 95

    (43) call -> ID LPAREN . callvalues RPAREN
    (44) callvalues -> . empty
    (45) callvalues -> . exp COMMA callvalues
    (46) callvalues -> . exp
    (105) empty -> .
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    RPAREN          reduce using rule 105 (empty -> .)
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    callvalues                     shift and go to state 106
    empty                          shift and go to state 107
    exp                            shift and go to state 108
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 96

    (83) assignment -> ID ASSIGN . expression SEMICOLON
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 97

    (80) forloop -> FROM var . ASSIGN expression TO expression BY expression DO block
    (81) forloop -> FROM var . ASSIGN expression TO expression DO block
    ASSIGN          shift and go to state 118


state 98

    (82) whileloop -> WHILE LPAREN . expression RPAREN block
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 119
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 99

    (84) read -> INPUT LPAREN . decvar RPAREN SEMICOLON
    (12) decvar -> . var COMMA decvar
    (13) decvar -> . var
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    decvar                         shift and go to state 120
    var                            shift and go to state 25

state 100

    (85) write -> PRINT LPAREN . writevalues RPAREN SEMICOLON
    (86) writevalues -> . CTESTRING COMMA writevalues
    (87) writevalues -> . super_exp COMMA writevalues
    (88) writevalues -> . CTESTRING
    (89) writevalues -> . super_exp
    (49) super_exp -> . expression super_exp_quadgen super_exp_aux
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    CTESTRING       shift and go to state 122
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    writevalues                    shift and go to state 121
    super_exp                      shift and go to state 123
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 101

    (90) condition -> IF LPAREN . expression RPAREN block ELSE block
    (91) condition -> IF LPAREN . expression RPAREN block
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 125
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 102

    (41) params -> type ID COMMA params .
    RPAREN          reduce using rule 41 (params -> type ID COMMA params .)


state 103

    (5) returnblock -> LCURLY decvars . blockcontent RETURN exp SEMICOLON RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (105) empty -> .
    (96) statute -> . call
    (97) statute -> . forloop
    (98) statute -> . whileloop
    (99) statute -> . read
    (100) statute -> . write
    (101) statute -> . condition
    (102) statute -> . assignment
    (43) call -> . ID LPAREN callvalues RPAREN
    (80) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (81) forloop -> . FROM var ASSIGN expression TO expression DO block
    (82) whileloop -> . WHILE LPAREN expression RPAREN block
    (84) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (85) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (90) condition -> . IF LPAREN expression RPAREN block ELSE block
    (91) condition -> . IF LPAREN expression RPAREN block
    (83) assignment -> . ID ASSIGN expression SEMICOLON
    RETURN          reduce using rule 105 (empty -> .)
    ID              shift and go to state 82
    FROM            shift and go to state 83
    WHILE           shift and go to state 84
    INPUT           shift and go to state 85
    PRINT           shift and go to state 86
    IF              shift and go to state 87

    blockcontent                   shift and go to state 126
    empty                          shift and go to state 73
    statute                        shift and go to state 74
    call                           shift and go to state 75
    forloop                        shift and go to state 76
    whileloop                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    condition                      shift and go to state 80
    assignment                     shift and go to state 81

state 104

    (43) call -> ID . LPAREN callvalues RPAREN
    (31) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID . LBRACKET CTEINT RBRACKET
    (33) var -> ID .
    LPAREN          shift and go to state 95
    LBRACKET        shift and go to state 49
    DIVIDE          reduce using rule 33 (var -> ID .)
    TIMES           reduce using rule 33 (var -> ID .)
    MINUS           reduce using rule 33 (var -> ID .)
    PLUS            reduce using rule 33 (var -> ID .)
    COMMA           reduce using rule 33 (var -> ID .)
    RPAREN          reduce using rule 33 (var -> ID .)
    NEQ             reduce using rule 33 (var -> ID .)
    EQ              reduce using rule 33 (var -> ID .)
    LTE             reduce using rule 33 (var -> ID .)
    GTE             reduce using rule 33 (var -> ID .)
    LT              reduce using rule 33 (var -> ID .)
    GT              reduce using rule 33 (var -> ID .)
    SEMICOLON       reduce using rule 33 (var -> ID .)
    OR              reduce using rule 33 (var -> ID .)
    AND             reduce using rule 33 (var -> ID .)
    TO              reduce using rule 33 (var -> ID .)
    BY              reduce using rule 33 (var -> ID .)
    DO              reduce using rule 33 (var -> ID .)


state 105

    (75) factor -> LPAREN . fakefloor super_exp RPAREN
    (79) fakefloor -> .
    LPAREN          reduce using rule 79 (fakefloor -> .)
    CTEFLOAT        reduce using rule 79 (fakefloor -> .)
    CTEINT          reduce using rule 79 (fakefloor -> .)
    ID              reduce using rule 79 (fakefloor -> .)
    FLOAT           reduce using rule 79 (fakefloor -> .)
    INT             reduce using rule 79 (fakefloor -> .)
    ELSE            reduce using rule 79 (fakefloor -> .)
    IF              reduce using rule 79 (fakefloor -> .)
    PRINT           reduce using rule 79 (fakefloor -> .)
    INPUT           reduce using rule 79 (fakefloor -> .)
    WHILE           reduce using rule 79 (fakefloor -> .)
    DO              reduce using rule 79 (fakefloor -> .)
    BY              reduce using rule 79 (fakefloor -> .)
    TO              reduce using rule 79 (fakefloor -> .)
    FROM            reduce using rule 79 (fakefloor -> .)
    VOID            reduce using rule 79 (fakefloor -> .)
    RETURN          reduce using rule 79 (fakefloor -> .)
    FUNC            reduce using rule 79 (fakefloor -> .)
    MAIN            reduce using rule 79 (fakefloor -> .)
    VARS            reduce using rule 79 (fakefloor -> .)
    PROGRAM         reduce using rule 79 (fakefloor -> .)

    fakefloor                      shift and go to state 127

state 106

    (43) call -> ID LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 128


state 107

    (44) callvalues -> empty .
    RPAREN          reduce using rule 44 (callvalues -> empty .)


state 108

    (45) callvalues -> exp . COMMA callvalues
    (46) callvalues -> exp .
    COMMA           shift and go to state 129
    RPAREN          reduce using rule 46 (callvalues -> exp .)


state 109

    (65) exp -> term . exp_quadgen exp_aux
    (68) exp_quadgen -> .
    MINUS           reduce using rule 68 (exp_quadgen -> .)
    PLUS            reduce using rule 68 (exp_quadgen -> .)
    COMMA           reduce using rule 68 (exp_quadgen -> .)
    RPAREN          reduce using rule 68 (exp_quadgen -> .)
    NEQ             reduce using rule 68 (exp_quadgen -> .)
    EQ              reduce using rule 68 (exp_quadgen -> .)
    LTE             reduce using rule 68 (exp_quadgen -> .)
    GTE             reduce using rule 68 (exp_quadgen -> .)
    LT              reduce using rule 68 (exp_quadgen -> .)
    GT              reduce using rule 68 (exp_quadgen -> .)
    SEMICOLON       reduce using rule 68 (exp_quadgen -> .)
    OR              reduce using rule 68 (exp_quadgen -> .)
    AND             reduce using rule 68 (exp_quadgen -> .)
    TO              reduce using rule 68 (exp_quadgen -> .)
    BY              reduce using rule 68 (exp_quadgen -> .)
    DO              reduce using rule 68 (exp_quadgen -> .)

    exp_quadgen                    shift and go to state 130

state 110

    (71) term -> factor . term_quadgen term_aux
    (74) term_quadgen -> .
    DIVIDE          reduce using rule 74 (term_quadgen -> .)
    TIMES           reduce using rule 74 (term_quadgen -> .)
    MINUS           reduce using rule 74 (term_quadgen -> .)
    PLUS            reduce using rule 74 (term_quadgen -> .)
    COMMA           reduce using rule 74 (term_quadgen -> .)
    RPAREN          reduce using rule 74 (term_quadgen -> .)
    NEQ             reduce using rule 74 (term_quadgen -> .)
    EQ              reduce using rule 74 (term_quadgen -> .)
    LTE             reduce using rule 74 (term_quadgen -> .)
    GTE             reduce using rule 74 (term_quadgen -> .)
    LT              reduce using rule 74 (term_quadgen -> .)
    GT              reduce using rule 74 (term_quadgen -> .)
    SEMICOLON       reduce using rule 74 (term_quadgen -> .)
    OR              reduce using rule 74 (term_quadgen -> .)
    AND             reduce using rule 74 (term_quadgen -> .)
    TO              reduce using rule 74 (term_quadgen -> .)
    BY              reduce using rule 74 (term_quadgen -> .)
    DO              reduce using rule 74 (term_quadgen -> .)

    term_quadgen                   shift and go to state 131

state 111

    (76) factor -> varcte .
    DIVIDE          reduce using rule 76 (factor -> varcte .)
    TIMES           reduce using rule 76 (factor -> varcte .)
    MINUS           reduce using rule 76 (factor -> varcte .)
    PLUS            reduce using rule 76 (factor -> varcte .)
    COMMA           reduce using rule 76 (factor -> varcte .)
    RPAREN          reduce using rule 76 (factor -> varcte .)
    NEQ             reduce using rule 76 (factor -> varcte .)
    EQ              reduce using rule 76 (factor -> varcte .)
    LTE             reduce using rule 76 (factor -> varcte .)
    GTE             reduce using rule 76 (factor -> varcte .)
    LT              reduce using rule 76 (factor -> varcte .)
    GT              reduce using rule 76 (factor -> varcte .)
    SEMICOLON       reduce using rule 76 (factor -> varcte .)
    OR              reduce using rule 76 (factor -> varcte .)
    AND             reduce using rule 76 (factor -> varcte .)
    TO              reduce using rule 76 (factor -> varcte .)
    BY              reduce using rule 76 (factor -> varcte .)
    DO              reduce using rule 76 (factor -> varcte .)


state 112

    (77) factor -> call .
    DIVIDE          reduce using rule 77 (factor -> call .)
    TIMES           reduce using rule 77 (factor -> call .)
    MINUS           reduce using rule 77 (factor -> call .)
    PLUS            reduce using rule 77 (factor -> call .)
    COMMA           reduce using rule 77 (factor -> call .)
    RPAREN          reduce using rule 77 (factor -> call .)
    NEQ             reduce using rule 77 (factor -> call .)
    EQ              reduce using rule 77 (factor -> call .)
    LTE             reduce using rule 77 (factor -> call .)
    GTE             reduce using rule 77 (factor -> call .)
    LT              reduce using rule 77 (factor -> call .)
    GT              reduce using rule 77 (factor -> call .)
    SEMICOLON       reduce using rule 77 (factor -> call .)
    OR              reduce using rule 77 (factor -> call .)
    AND             reduce using rule 77 (factor -> call .)
    TO              reduce using rule 77 (factor -> call .)
    BY              reduce using rule 77 (factor -> call .)
    DO              reduce using rule 77 (factor -> call .)


state 113

    (78) factor -> var .
    DIVIDE          reduce using rule 78 (factor -> var .)
    TIMES           reduce using rule 78 (factor -> var .)
    MINUS           reduce using rule 78 (factor -> var .)
    PLUS            reduce using rule 78 (factor -> var .)
    COMMA           reduce using rule 78 (factor -> var .)
    RPAREN          reduce using rule 78 (factor -> var .)
    NEQ             reduce using rule 78 (factor -> var .)
    EQ              reduce using rule 78 (factor -> var .)
    LTE             reduce using rule 78 (factor -> var .)
    GTE             reduce using rule 78 (factor -> var .)
    LT              reduce using rule 78 (factor -> var .)
    GT              reduce using rule 78 (factor -> var .)
    SEMICOLON       reduce using rule 78 (factor -> var .)
    OR              reduce using rule 78 (factor -> var .)
    AND             reduce using rule 78 (factor -> var .)
    TO              reduce using rule 78 (factor -> var .)
    BY              reduce using rule 78 (factor -> var .)
    DO              reduce using rule 78 (factor -> var .)


state 114

    (92) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 92 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 92 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 92 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 92 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 92 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 92 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 92 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 92 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 92 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 92 (varcte -> CTEFLOAT .)
    LT              reduce using rule 92 (varcte -> CTEFLOAT .)
    GT              reduce using rule 92 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 92 (varcte -> CTEFLOAT .)
    OR              reduce using rule 92 (varcte -> CTEFLOAT .)
    AND             reduce using rule 92 (varcte -> CTEFLOAT .)
    TO              reduce using rule 92 (varcte -> CTEFLOAT .)
    BY              reduce using rule 92 (varcte -> CTEFLOAT .)
    DO              reduce using rule 92 (varcte -> CTEFLOAT .)


state 115

    (93) varcte -> CTEINT .
    DIVIDE          reduce using rule 93 (varcte -> CTEINT .)
    TIMES           reduce using rule 93 (varcte -> CTEINT .)
    MINUS           reduce using rule 93 (varcte -> CTEINT .)
    PLUS            reduce using rule 93 (varcte -> CTEINT .)
    COMMA           reduce using rule 93 (varcte -> CTEINT .)
    RPAREN          reduce using rule 93 (varcte -> CTEINT .)
    NEQ             reduce using rule 93 (varcte -> CTEINT .)
    EQ              reduce using rule 93 (varcte -> CTEINT .)
    LTE             reduce using rule 93 (varcte -> CTEINT .)
    GTE             reduce using rule 93 (varcte -> CTEINT .)
    LT              reduce using rule 93 (varcte -> CTEINT .)
    GT              reduce using rule 93 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 93 (varcte -> CTEINT .)
    OR              reduce using rule 93 (varcte -> CTEINT .)
    AND             reduce using rule 93 (varcte -> CTEINT .)
    TO              reduce using rule 93 (varcte -> CTEINT .)
    BY              reduce using rule 93 (varcte -> CTEINT .)
    DO              reduce using rule 93 (varcte -> CTEINT .)


state 116

    (83) assignment -> ID ASSIGN expression . SEMICOLON
    SEMICOLON       shift and go to state 132


state 117

    (55) expression -> exp . expression_quadgen expression_aux
    (62) expression_quadgen -> .
    NEQ             reduce using rule 62 (expression_quadgen -> .)
    EQ              reduce using rule 62 (expression_quadgen -> .)
    LTE             reduce using rule 62 (expression_quadgen -> .)
    GTE             reduce using rule 62 (expression_quadgen -> .)
    LT              reduce using rule 62 (expression_quadgen -> .)
    GT              reduce using rule 62 (expression_quadgen -> .)
    SEMICOLON       reduce using rule 62 (expression_quadgen -> .)
    RPAREN          reduce using rule 62 (expression_quadgen -> .)
    OR              reduce using rule 62 (expression_quadgen -> .)
    AND             reduce using rule 62 (expression_quadgen -> .)
    COMMA           reduce using rule 62 (expression_quadgen -> .)
    TO              reduce using rule 62 (expression_quadgen -> .)
    BY              reduce using rule 62 (expression_quadgen -> .)
    DO              reduce using rule 62 (expression_quadgen -> .)

    expression_quadgen             shift and go to state 133

state 118

    (80) forloop -> FROM var ASSIGN . expression TO expression BY expression DO block
    (81) forloop -> FROM var ASSIGN . expression TO expression DO block
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    var                            shift and go to state 113
    expression                     shift and go to state 134
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112

state 119

    (82) whileloop -> WHILE LPAREN expression . RPAREN block
    RPAREN          shift and go to state 135


state 120

    (84) read -> INPUT LPAREN decvar . RPAREN SEMICOLON
    RPAREN          shift and go to state 136


state 121

    (85) write -> PRINT LPAREN writevalues . RPAREN SEMICOLON
    RPAREN          shift and go to state 137


state 122

    (86) writevalues -> CTESTRING . COMMA writevalues
    (88) writevalues -> CTESTRING .
    COMMA           shift and go to state 138
    RPAREN          reduce using rule 88 (writevalues -> CTESTRING .)


state 123

    (87) writevalues -> super_exp . COMMA writevalues
    (89) writevalues -> super_exp .
    COMMA           shift and go to state 139
    RPAREN          reduce using rule 89 (writevalues -> super_exp .)


state 124

    (49) super_exp -> expression . super_exp_quadgen super_exp_aux
    (52) super_exp_quadgen -> .
    OR              reduce using rule 52 (super_exp_quadgen -> .)
    AND             reduce using rule 52 (super_exp_quadgen -> .)
    COMMA           reduce using rule 52 (super_exp_quadgen -> .)
    RPAREN          reduce using rule 52 (super_exp_quadgen -> .)

    super_exp_quadgen              shift and go to state 140

state 125

    (90) condition -> IF LPAREN expression . RPAREN block ELSE block
    (91) condition -> IF LPAREN expression . RPAREN block
    RPAREN          shift and go to state 141


state 126

    (5) returnblock -> LCURLY decvars blockcontent . RETURN exp SEMICOLON RCURLY
    RETURN          shift and go to state 142


state 127

    (75) factor -> LPAREN fakefloor . super_exp RPAREN
    (49) super_exp -> . expression super_exp_quadgen super_exp_aux
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    super_exp                      shift and go to state 143
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 128

    (43) call -> ID LPAREN callvalues RPAREN .
    ID              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    FROM            reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    IF              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    RETURN          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    DIVIDE          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    EQ              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    LTE             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    GTE             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    LT              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    GT              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    OR              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    AND             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    TO              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    BY              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    DO              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)


state 129

    (45) callvalues -> exp COMMA . callvalues
    (44) callvalues -> . empty
    (45) callvalues -> . exp COMMA callvalues
    (46) callvalues -> . exp
    (105) empty -> .
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    RPAREN          reduce using rule 105 (empty -> .)
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    exp                            shift and go to state 108
    callvalues                     shift and go to state 144
    empty                          shift and go to state 107
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 130

    (65) exp -> term exp_quadgen . exp_aux
    (63) exp_aux -> . exp_sign exp
    (64) exp_aux -> . empty
    (66) exp_sign -> . MINUS
    (67) exp_sign -> . PLUS
    (105) empty -> .
    MINUS           shift and go to state 148
    PLUS            shift and go to state 149
    COMMA           reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    NEQ             reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    LTE             reduce using rule 105 (empty -> .)
    GTE             reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    SEMICOLON       reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    BY              reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)

    exp_aux                        shift and go to state 145
    exp_sign                       shift and go to state 146
    empty                          shift and go to state 147

state 131

    (71) term -> factor term_quadgen . term_aux
    (69) term_aux -> . term_sign term
    (70) term_aux -> . empty
    (72) term_sign -> . DIVIDE
    (73) term_sign -> . TIMES
    (105) empty -> .
    DIVIDE          shift and go to state 153
    TIMES           shift and go to state 154
    MINUS           reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    NEQ             reduce using rule 105 (empty -> .)
    EQ              reduce using rule 105 (empty -> .)
    LTE             reduce using rule 105 (empty -> .)
    GTE             reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    SEMICOLON       reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    BY              reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)

    term_aux                       shift and go to state 150
    term_sign                      shift and go to state 151
    empty                          shift and go to state 152

state 132

    (83) assignment -> ID ASSIGN expression SEMICOLON .
    ID              reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    FROM            reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    INPUT           reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    RCURLY          reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 83 (assignment -> ID ASSIGN expression SEMICOLON .)


state 133

    (55) expression -> exp expression_quadgen . expression_aux
    (53) expression_aux -> . relation expression
    (54) expression_aux -> . empty
    (56) relation -> . NEQ
    (57) relation -> . EQ
    (58) relation -> . LTE
    (59) relation -> . GTE
    (60) relation -> . LT
    (61) relation -> . GT
    (105) empty -> .
    NEQ             shift and go to state 158
    EQ              shift and go to state 159
    LTE             shift and go to state 160
    GTE             shift and go to state 161
    LT              shift and go to state 162
    GT              shift and go to state 163
    SEMICOLON       reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    BY              reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)

    expression_aux                 shift and go to state 155
    relation                       shift and go to state 156
    empty                          shift and go to state 157

state 134

    (80) forloop -> FROM var ASSIGN expression . TO expression BY expression DO block
    (81) forloop -> FROM var ASSIGN expression . TO expression DO block
    TO              shift and go to state 164


state 135

    (82) whileloop -> WHILE LPAREN expression RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 165

state 136

    (84) read -> INPUT LPAREN decvar RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 166


state 137

    (85) write -> PRINT LPAREN writevalues RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 167


state 138

    (86) writevalues -> CTESTRING COMMA . writevalues
    (86) writevalues -> . CTESTRING COMMA writevalues
    (87) writevalues -> . super_exp COMMA writevalues
    (88) writevalues -> . CTESTRING
    (89) writevalues -> . super_exp
    (49) super_exp -> . expression super_exp_quadgen super_exp_aux
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    CTESTRING       shift and go to state 122
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    writevalues                    shift and go to state 168
    super_exp                      shift and go to state 123
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 139

    (87) writevalues -> super_exp COMMA . writevalues
    (86) writevalues -> . CTESTRING COMMA writevalues
    (87) writevalues -> . super_exp COMMA writevalues
    (88) writevalues -> . CTESTRING
    (89) writevalues -> . super_exp
    (49) super_exp -> . expression super_exp_quadgen super_exp_aux
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    CTESTRING       shift and go to state 122
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    super_exp                      shift and go to state 123
    writevalues                    shift and go to state 169
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 140

    (49) super_exp -> expression super_exp_quadgen . super_exp_aux
    (47) super_exp_aux -> . logic super_exp
    (48) super_exp_aux -> . empty
    (50) logic -> . OR
    (51) logic -> . AND
    (105) empty -> .
    OR              shift and go to state 173
    AND             shift and go to state 174
    COMMA           reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)

    super_exp_aux                  shift and go to state 170
    logic                          shift and go to state 171
    empty                          shift and go to state 172

state 141

    (90) condition -> IF LPAREN expression RPAREN . block ELSE block
    (91) condition -> IF LPAREN expression RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 175

state 142

    (5) returnblock -> LCURLY decvars blockcontent RETURN . exp SEMICOLON RCURLY
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    exp                            shift and go to state 176
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 143

    (75) factor -> LPAREN fakefloor super_exp . RPAREN
    RPAREN          shift and go to state 177


state 144

    (45) callvalues -> exp COMMA callvalues .
    RPAREN          reduce using rule 45 (callvalues -> exp COMMA callvalues .)


state 145

    (65) exp -> term exp_quadgen exp_aux .
    COMMA           reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    RPAREN          reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    NEQ             reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    EQ              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    LTE             reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    GTE             reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    LT              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    GT              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    SEMICOLON       reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    OR              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    AND             reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    TO              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    BY              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)
    DO              reduce using rule 65 (exp -> term exp_quadgen exp_aux .)


state 146

    (63) exp_aux -> exp_sign . exp
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    exp                            shift and go to state 178
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 147

    (64) exp_aux -> empty .
    COMMA           reduce using rule 64 (exp_aux -> empty .)
    RPAREN          reduce using rule 64 (exp_aux -> empty .)
    NEQ             reduce using rule 64 (exp_aux -> empty .)
    EQ              reduce using rule 64 (exp_aux -> empty .)
    LTE             reduce using rule 64 (exp_aux -> empty .)
    GTE             reduce using rule 64 (exp_aux -> empty .)
    LT              reduce using rule 64 (exp_aux -> empty .)
    GT              reduce using rule 64 (exp_aux -> empty .)
    SEMICOLON       reduce using rule 64 (exp_aux -> empty .)
    OR              reduce using rule 64 (exp_aux -> empty .)
    AND             reduce using rule 64 (exp_aux -> empty .)
    TO              reduce using rule 64 (exp_aux -> empty .)
    BY              reduce using rule 64 (exp_aux -> empty .)
    DO              reduce using rule 64 (exp_aux -> empty .)


state 148

    (66) exp_sign -> MINUS .
    LPAREN          reduce using rule 66 (exp_sign -> MINUS .)
    CTEFLOAT        reduce using rule 66 (exp_sign -> MINUS .)
    CTEINT          reduce using rule 66 (exp_sign -> MINUS .)
    ID              reduce using rule 66 (exp_sign -> MINUS .)
    FLOAT           reduce using rule 66 (exp_sign -> MINUS .)
    INT             reduce using rule 66 (exp_sign -> MINUS .)
    ELSE            reduce using rule 66 (exp_sign -> MINUS .)
    IF              reduce using rule 66 (exp_sign -> MINUS .)
    PRINT           reduce using rule 66 (exp_sign -> MINUS .)
    INPUT           reduce using rule 66 (exp_sign -> MINUS .)
    WHILE           reduce using rule 66 (exp_sign -> MINUS .)
    DO              reduce using rule 66 (exp_sign -> MINUS .)
    BY              reduce using rule 66 (exp_sign -> MINUS .)
    TO              reduce using rule 66 (exp_sign -> MINUS .)
    FROM            reduce using rule 66 (exp_sign -> MINUS .)
    VOID            reduce using rule 66 (exp_sign -> MINUS .)
    RETURN          reduce using rule 66 (exp_sign -> MINUS .)
    FUNC            reduce using rule 66 (exp_sign -> MINUS .)
    MAIN            reduce using rule 66 (exp_sign -> MINUS .)
    VARS            reduce using rule 66 (exp_sign -> MINUS .)
    PROGRAM         reduce using rule 66 (exp_sign -> MINUS .)


state 149

    (67) exp_sign -> PLUS .
    LPAREN          reduce using rule 67 (exp_sign -> PLUS .)
    CTEFLOAT        reduce using rule 67 (exp_sign -> PLUS .)
    CTEINT          reduce using rule 67 (exp_sign -> PLUS .)
    ID              reduce using rule 67 (exp_sign -> PLUS .)
    FLOAT           reduce using rule 67 (exp_sign -> PLUS .)
    INT             reduce using rule 67 (exp_sign -> PLUS .)
    ELSE            reduce using rule 67 (exp_sign -> PLUS .)
    IF              reduce using rule 67 (exp_sign -> PLUS .)
    PRINT           reduce using rule 67 (exp_sign -> PLUS .)
    INPUT           reduce using rule 67 (exp_sign -> PLUS .)
    WHILE           reduce using rule 67 (exp_sign -> PLUS .)
    DO              reduce using rule 67 (exp_sign -> PLUS .)
    BY              reduce using rule 67 (exp_sign -> PLUS .)
    TO              reduce using rule 67 (exp_sign -> PLUS .)
    FROM            reduce using rule 67 (exp_sign -> PLUS .)
    VOID            reduce using rule 67 (exp_sign -> PLUS .)
    RETURN          reduce using rule 67 (exp_sign -> PLUS .)
    FUNC            reduce using rule 67 (exp_sign -> PLUS .)
    MAIN            reduce using rule 67 (exp_sign -> PLUS .)
    VARS            reduce using rule 67 (exp_sign -> PLUS .)
    PROGRAM         reduce using rule 67 (exp_sign -> PLUS .)


state 150

    (71) term -> factor term_quadgen term_aux .
    MINUS           reduce using rule 71 (term -> factor term_quadgen term_aux .)
    PLUS            reduce using rule 71 (term -> factor term_quadgen term_aux .)
    COMMA           reduce using rule 71 (term -> factor term_quadgen term_aux .)
    RPAREN          reduce using rule 71 (term -> factor term_quadgen term_aux .)
    NEQ             reduce using rule 71 (term -> factor term_quadgen term_aux .)
    EQ              reduce using rule 71 (term -> factor term_quadgen term_aux .)
    LTE             reduce using rule 71 (term -> factor term_quadgen term_aux .)
    GTE             reduce using rule 71 (term -> factor term_quadgen term_aux .)
    LT              reduce using rule 71 (term -> factor term_quadgen term_aux .)
    GT              reduce using rule 71 (term -> factor term_quadgen term_aux .)
    SEMICOLON       reduce using rule 71 (term -> factor term_quadgen term_aux .)
    OR              reduce using rule 71 (term -> factor term_quadgen term_aux .)
    AND             reduce using rule 71 (term -> factor term_quadgen term_aux .)
    TO              reduce using rule 71 (term -> factor term_quadgen term_aux .)
    BY              reduce using rule 71 (term -> factor term_quadgen term_aux .)
    DO              reduce using rule 71 (term -> factor term_quadgen term_aux .)


state 151

    (69) term_aux -> term_sign . term
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    term                           shift and go to state 179
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 152

    (70) term_aux -> empty .
    MINUS           reduce using rule 70 (term_aux -> empty .)
    PLUS            reduce using rule 70 (term_aux -> empty .)
    COMMA           reduce using rule 70 (term_aux -> empty .)
    RPAREN          reduce using rule 70 (term_aux -> empty .)
    NEQ             reduce using rule 70 (term_aux -> empty .)
    EQ              reduce using rule 70 (term_aux -> empty .)
    LTE             reduce using rule 70 (term_aux -> empty .)
    GTE             reduce using rule 70 (term_aux -> empty .)
    LT              reduce using rule 70 (term_aux -> empty .)
    GT              reduce using rule 70 (term_aux -> empty .)
    SEMICOLON       reduce using rule 70 (term_aux -> empty .)
    OR              reduce using rule 70 (term_aux -> empty .)
    AND             reduce using rule 70 (term_aux -> empty .)
    TO              reduce using rule 70 (term_aux -> empty .)
    BY              reduce using rule 70 (term_aux -> empty .)
    DO              reduce using rule 70 (term_aux -> empty .)


state 153

    (72) term_sign -> DIVIDE .
    LPAREN          reduce using rule 72 (term_sign -> DIVIDE .)
    CTEFLOAT        reduce using rule 72 (term_sign -> DIVIDE .)
    CTEINT          reduce using rule 72 (term_sign -> DIVIDE .)
    ID              reduce using rule 72 (term_sign -> DIVIDE .)
    FLOAT           reduce using rule 72 (term_sign -> DIVIDE .)
    INT             reduce using rule 72 (term_sign -> DIVIDE .)
    ELSE            reduce using rule 72 (term_sign -> DIVIDE .)
    IF              reduce using rule 72 (term_sign -> DIVIDE .)
    PRINT           reduce using rule 72 (term_sign -> DIVIDE .)
    INPUT           reduce using rule 72 (term_sign -> DIVIDE .)
    WHILE           reduce using rule 72 (term_sign -> DIVIDE .)
    DO              reduce using rule 72 (term_sign -> DIVIDE .)
    BY              reduce using rule 72 (term_sign -> DIVIDE .)
    TO              reduce using rule 72 (term_sign -> DIVIDE .)
    FROM            reduce using rule 72 (term_sign -> DIVIDE .)
    VOID            reduce using rule 72 (term_sign -> DIVIDE .)
    RETURN          reduce using rule 72 (term_sign -> DIVIDE .)
    FUNC            reduce using rule 72 (term_sign -> DIVIDE .)
    MAIN            reduce using rule 72 (term_sign -> DIVIDE .)
    VARS            reduce using rule 72 (term_sign -> DIVIDE .)
    PROGRAM         reduce using rule 72 (term_sign -> DIVIDE .)


state 154

    (73) term_sign -> TIMES .
    LPAREN          reduce using rule 73 (term_sign -> TIMES .)
    CTEFLOAT        reduce using rule 73 (term_sign -> TIMES .)
    CTEINT          reduce using rule 73 (term_sign -> TIMES .)
    ID              reduce using rule 73 (term_sign -> TIMES .)
    FLOAT           reduce using rule 73 (term_sign -> TIMES .)
    INT             reduce using rule 73 (term_sign -> TIMES .)
    ELSE            reduce using rule 73 (term_sign -> TIMES .)
    IF              reduce using rule 73 (term_sign -> TIMES .)
    PRINT           reduce using rule 73 (term_sign -> TIMES .)
    INPUT           reduce using rule 73 (term_sign -> TIMES .)
    WHILE           reduce using rule 73 (term_sign -> TIMES .)
    DO              reduce using rule 73 (term_sign -> TIMES .)
    BY              reduce using rule 73 (term_sign -> TIMES .)
    TO              reduce using rule 73 (term_sign -> TIMES .)
    FROM            reduce using rule 73 (term_sign -> TIMES .)
    VOID            reduce using rule 73 (term_sign -> TIMES .)
    RETURN          reduce using rule 73 (term_sign -> TIMES .)
    FUNC            reduce using rule 73 (term_sign -> TIMES .)
    MAIN            reduce using rule 73 (term_sign -> TIMES .)
    VARS            reduce using rule 73 (term_sign -> TIMES .)
    PROGRAM         reduce using rule 73 (term_sign -> TIMES .)


state 155

    (55) expression -> exp expression_quadgen expression_aux .
    SEMICOLON       reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    RPAREN          reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    OR              reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    AND             reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    COMMA           reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    TO              reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    BY              reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)
    DO              reduce using rule 55 (expression -> exp expression_quadgen expression_aux .)


state 156

    (53) expression_aux -> relation . expression
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 180
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 157

    (54) expression_aux -> empty .
    SEMICOLON       reduce using rule 54 (expression_aux -> empty .)
    RPAREN          reduce using rule 54 (expression_aux -> empty .)
    OR              reduce using rule 54 (expression_aux -> empty .)
    AND             reduce using rule 54 (expression_aux -> empty .)
    COMMA           reduce using rule 54 (expression_aux -> empty .)
    TO              reduce using rule 54 (expression_aux -> empty .)
    BY              reduce using rule 54 (expression_aux -> empty .)
    DO              reduce using rule 54 (expression_aux -> empty .)


state 158

    (56) relation -> NEQ .
    LPAREN          reduce using rule 56 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 56 (relation -> NEQ .)
    CTEINT          reduce using rule 56 (relation -> NEQ .)
    ID              reduce using rule 56 (relation -> NEQ .)
    FLOAT           reduce using rule 56 (relation -> NEQ .)
    INT             reduce using rule 56 (relation -> NEQ .)
    ELSE            reduce using rule 56 (relation -> NEQ .)
    IF              reduce using rule 56 (relation -> NEQ .)
    PRINT           reduce using rule 56 (relation -> NEQ .)
    INPUT           reduce using rule 56 (relation -> NEQ .)
    WHILE           reduce using rule 56 (relation -> NEQ .)
    DO              reduce using rule 56 (relation -> NEQ .)
    BY              reduce using rule 56 (relation -> NEQ .)
    TO              reduce using rule 56 (relation -> NEQ .)
    FROM            reduce using rule 56 (relation -> NEQ .)
    VOID            reduce using rule 56 (relation -> NEQ .)
    RETURN          reduce using rule 56 (relation -> NEQ .)
    FUNC            reduce using rule 56 (relation -> NEQ .)
    MAIN            reduce using rule 56 (relation -> NEQ .)
    VARS            reduce using rule 56 (relation -> NEQ .)
    PROGRAM         reduce using rule 56 (relation -> NEQ .)


state 159

    (57) relation -> EQ .
    LPAREN          reduce using rule 57 (relation -> EQ .)
    CTEFLOAT        reduce using rule 57 (relation -> EQ .)
    CTEINT          reduce using rule 57 (relation -> EQ .)
    ID              reduce using rule 57 (relation -> EQ .)
    FLOAT           reduce using rule 57 (relation -> EQ .)
    INT             reduce using rule 57 (relation -> EQ .)
    ELSE            reduce using rule 57 (relation -> EQ .)
    IF              reduce using rule 57 (relation -> EQ .)
    PRINT           reduce using rule 57 (relation -> EQ .)
    INPUT           reduce using rule 57 (relation -> EQ .)
    WHILE           reduce using rule 57 (relation -> EQ .)
    DO              reduce using rule 57 (relation -> EQ .)
    BY              reduce using rule 57 (relation -> EQ .)
    TO              reduce using rule 57 (relation -> EQ .)
    FROM            reduce using rule 57 (relation -> EQ .)
    VOID            reduce using rule 57 (relation -> EQ .)
    RETURN          reduce using rule 57 (relation -> EQ .)
    FUNC            reduce using rule 57 (relation -> EQ .)
    MAIN            reduce using rule 57 (relation -> EQ .)
    VARS            reduce using rule 57 (relation -> EQ .)
    PROGRAM         reduce using rule 57 (relation -> EQ .)


state 160

    (58) relation -> LTE .
    LPAREN          reduce using rule 58 (relation -> LTE .)
    CTEFLOAT        reduce using rule 58 (relation -> LTE .)
    CTEINT          reduce using rule 58 (relation -> LTE .)
    ID              reduce using rule 58 (relation -> LTE .)
    FLOAT           reduce using rule 58 (relation -> LTE .)
    INT             reduce using rule 58 (relation -> LTE .)
    ELSE            reduce using rule 58 (relation -> LTE .)
    IF              reduce using rule 58 (relation -> LTE .)
    PRINT           reduce using rule 58 (relation -> LTE .)
    INPUT           reduce using rule 58 (relation -> LTE .)
    WHILE           reduce using rule 58 (relation -> LTE .)
    DO              reduce using rule 58 (relation -> LTE .)
    BY              reduce using rule 58 (relation -> LTE .)
    TO              reduce using rule 58 (relation -> LTE .)
    FROM            reduce using rule 58 (relation -> LTE .)
    VOID            reduce using rule 58 (relation -> LTE .)
    RETURN          reduce using rule 58 (relation -> LTE .)
    FUNC            reduce using rule 58 (relation -> LTE .)
    MAIN            reduce using rule 58 (relation -> LTE .)
    VARS            reduce using rule 58 (relation -> LTE .)
    PROGRAM         reduce using rule 58 (relation -> LTE .)


state 161

    (59) relation -> GTE .
    LPAREN          reduce using rule 59 (relation -> GTE .)
    CTEFLOAT        reduce using rule 59 (relation -> GTE .)
    CTEINT          reduce using rule 59 (relation -> GTE .)
    ID              reduce using rule 59 (relation -> GTE .)
    FLOAT           reduce using rule 59 (relation -> GTE .)
    INT             reduce using rule 59 (relation -> GTE .)
    ELSE            reduce using rule 59 (relation -> GTE .)
    IF              reduce using rule 59 (relation -> GTE .)
    PRINT           reduce using rule 59 (relation -> GTE .)
    INPUT           reduce using rule 59 (relation -> GTE .)
    WHILE           reduce using rule 59 (relation -> GTE .)
    DO              reduce using rule 59 (relation -> GTE .)
    BY              reduce using rule 59 (relation -> GTE .)
    TO              reduce using rule 59 (relation -> GTE .)
    FROM            reduce using rule 59 (relation -> GTE .)
    VOID            reduce using rule 59 (relation -> GTE .)
    RETURN          reduce using rule 59 (relation -> GTE .)
    FUNC            reduce using rule 59 (relation -> GTE .)
    MAIN            reduce using rule 59 (relation -> GTE .)
    VARS            reduce using rule 59 (relation -> GTE .)
    PROGRAM         reduce using rule 59 (relation -> GTE .)


state 162

    (60) relation -> LT .
    LPAREN          reduce using rule 60 (relation -> LT .)
    CTEFLOAT        reduce using rule 60 (relation -> LT .)
    CTEINT          reduce using rule 60 (relation -> LT .)
    ID              reduce using rule 60 (relation -> LT .)
    FLOAT           reduce using rule 60 (relation -> LT .)
    INT             reduce using rule 60 (relation -> LT .)
    ELSE            reduce using rule 60 (relation -> LT .)
    IF              reduce using rule 60 (relation -> LT .)
    PRINT           reduce using rule 60 (relation -> LT .)
    INPUT           reduce using rule 60 (relation -> LT .)
    WHILE           reduce using rule 60 (relation -> LT .)
    DO              reduce using rule 60 (relation -> LT .)
    BY              reduce using rule 60 (relation -> LT .)
    TO              reduce using rule 60 (relation -> LT .)
    FROM            reduce using rule 60 (relation -> LT .)
    VOID            reduce using rule 60 (relation -> LT .)
    RETURN          reduce using rule 60 (relation -> LT .)
    FUNC            reduce using rule 60 (relation -> LT .)
    MAIN            reduce using rule 60 (relation -> LT .)
    VARS            reduce using rule 60 (relation -> LT .)
    PROGRAM         reduce using rule 60 (relation -> LT .)


state 163

    (61) relation -> GT .
    LPAREN          reduce using rule 61 (relation -> GT .)
    CTEFLOAT        reduce using rule 61 (relation -> GT .)
    CTEINT          reduce using rule 61 (relation -> GT .)
    ID              reduce using rule 61 (relation -> GT .)
    FLOAT           reduce using rule 61 (relation -> GT .)
    INT             reduce using rule 61 (relation -> GT .)
    ELSE            reduce using rule 61 (relation -> GT .)
    IF              reduce using rule 61 (relation -> GT .)
    PRINT           reduce using rule 61 (relation -> GT .)
    INPUT           reduce using rule 61 (relation -> GT .)
    WHILE           reduce using rule 61 (relation -> GT .)
    DO              reduce using rule 61 (relation -> GT .)
    BY              reduce using rule 61 (relation -> GT .)
    TO              reduce using rule 61 (relation -> GT .)
    FROM            reduce using rule 61 (relation -> GT .)
    VOID            reduce using rule 61 (relation -> GT .)
    RETURN          reduce using rule 61 (relation -> GT .)
    FUNC            reduce using rule 61 (relation -> GT .)
    MAIN            reduce using rule 61 (relation -> GT .)
    VARS            reduce using rule 61 (relation -> GT .)
    PROGRAM         reduce using rule 61 (relation -> GT .)


state 164

    (80) forloop -> FROM var ASSIGN expression TO . expression BY expression DO block
    (81) forloop -> FROM var ASSIGN expression TO . expression DO block
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    var                            shift and go to state 113
    expression                     shift and go to state 181
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112

state 165

    (82) whileloop -> WHILE LPAREN expression RPAREN block .
    ID              reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    FROM            reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    WHILE           reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    INPUT           reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    PRINT           reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    IF              reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RETURN          reduce using rule 82 (whileloop -> WHILE LPAREN expression RPAREN block .)


state 166

    (84) read -> INPUT LPAREN decvar RPAREN SEMICOLON .
    ID              reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    FROM            reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    INPUT           reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    PRINT           reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    IF              reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RCURLY          reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RETURN          reduce using rule 84 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)


state 167

    (85) write -> PRINT LPAREN writevalues RPAREN SEMICOLON .
    ID              reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    FROM            reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    WHILE           reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    INPUT           reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    PRINT           reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    IF              reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RCURLY          reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RETURN          reduce using rule 85 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)


state 168

    (86) writevalues -> CTESTRING COMMA writevalues .
    RPAREN          reduce using rule 86 (writevalues -> CTESTRING COMMA writevalues .)


state 169

    (87) writevalues -> super_exp COMMA writevalues .
    RPAREN          reduce using rule 87 (writevalues -> super_exp COMMA writevalues .)


state 170

    (49) super_exp -> expression super_exp_quadgen super_exp_aux .
    COMMA           reduce using rule 49 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RPAREN          reduce using rule 49 (super_exp -> expression super_exp_quadgen super_exp_aux .)


state 171

    (47) super_exp_aux -> logic . super_exp
    (49) super_exp -> . expression super_exp_quadgen super_exp_aux
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    super_exp                      shift and go to state 182
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 172

    (48) super_exp_aux -> empty .
    COMMA           reduce using rule 48 (super_exp_aux -> empty .)
    RPAREN          reduce using rule 48 (super_exp_aux -> empty .)


state 173

    (50) logic -> OR .
    LPAREN          reduce using rule 50 (logic -> OR .)
    CTEFLOAT        reduce using rule 50 (logic -> OR .)
    CTEINT          reduce using rule 50 (logic -> OR .)
    ID              reduce using rule 50 (logic -> OR .)
    FLOAT           reduce using rule 50 (logic -> OR .)
    INT             reduce using rule 50 (logic -> OR .)
    ELSE            reduce using rule 50 (logic -> OR .)
    IF              reduce using rule 50 (logic -> OR .)
    PRINT           reduce using rule 50 (logic -> OR .)
    INPUT           reduce using rule 50 (logic -> OR .)
    WHILE           reduce using rule 50 (logic -> OR .)
    DO              reduce using rule 50 (logic -> OR .)
    BY              reduce using rule 50 (logic -> OR .)
    TO              reduce using rule 50 (logic -> OR .)
    FROM            reduce using rule 50 (logic -> OR .)
    VOID            reduce using rule 50 (logic -> OR .)
    RETURN          reduce using rule 50 (logic -> OR .)
    FUNC            reduce using rule 50 (logic -> OR .)
    MAIN            reduce using rule 50 (logic -> OR .)
    VARS            reduce using rule 50 (logic -> OR .)
    PROGRAM         reduce using rule 50 (logic -> OR .)


state 174

    (51) logic -> AND .
    LPAREN          reduce using rule 51 (logic -> AND .)
    CTEFLOAT        reduce using rule 51 (logic -> AND .)
    CTEINT          reduce using rule 51 (logic -> AND .)
    ID              reduce using rule 51 (logic -> AND .)
    FLOAT           reduce using rule 51 (logic -> AND .)
    INT             reduce using rule 51 (logic -> AND .)
    ELSE            reduce using rule 51 (logic -> AND .)
    IF              reduce using rule 51 (logic -> AND .)
    PRINT           reduce using rule 51 (logic -> AND .)
    INPUT           reduce using rule 51 (logic -> AND .)
    WHILE           reduce using rule 51 (logic -> AND .)
    DO              reduce using rule 51 (logic -> AND .)
    BY              reduce using rule 51 (logic -> AND .)
    TO              reduce using rule 51 (logic -> AND .)
    FROM            reduce using rule 51 (logic -> AND .)
    VOID            reduce using rule 51 (logic -> AND .)
    RETURN          reduce using rule 51 (logic -> AND .)
    FUNC            reduce using rule 51 (logic -> AND .)
    MAIN            reduce using rule 51 (logic -> AND .)
    VARS            reduce using rule 51 (logic -> AND .)
    PROGRAM         reduce using rule 51 (logic -> AND .)


state 175

    (90) condition -> IF LPAREN expression RPAREN block . ELSE block
    (91) condition -> IF LPAREN expression RPAREN block .
    ELSE            shift and go to state 183
    ID              reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    FROM            reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    WHILE           reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    INPUT           reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    PRINT           reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    IF              reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)
    RETURN          reduce using rule 91 (condition -> IF LPAREN expression RPAREN block .)


state 176

    (5) returnblock -> LCURLY decvars blockcontent RETURN exp . SEMICOLON RCURLY
    SEMICOLON       shift and go to state 184


state 177

    (75) factor -> LPAREN fakefloor super_exp RPAREN .
    DIVIDE          reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TIMES           reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    MINUS           reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PLUS            reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    COMMA           reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RPAREN          reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    NEQ             reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    EQ              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LTE             reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GTE             reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LT              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GT              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    SEMICOLON       reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    OR              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    AND             reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TO              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    BY              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)
    DO              reduce using rule 75 (factor -> LPAREN fakefloor super_exp RPAREN .)


state 178

    (63) exp_aux -> exp_sign exp .
    COMMA           reduce using rule 63 (exp_aux -> exp_sign exp .)
    RPAREN          reduce using rule 63 (exp_aux -> exp_sign exp .)
    NEQ             reduce using rule 63 (exp_aux -> exp_sign exp .)
    EQ              reduce using rule 63 (exp_aux -> exp_sign exp .)
    LTE             reduce using rule 63 (exp_aux -> exp_sign exp .)
    GTE             reduce using rule 63 (exp_aux -> exp_sign exp .)
    LT              reduce using rule 63 (exp_aux -> exp_sign exp .)
    GT              reduce using rule 63 (exp_aux -> exp_sign exp .)
    SEMICOLON       reduce using rule 63 (exp_aux -> exp_sign exp .)
    OR              reduce using rule 63 (exp_aux -> exp_sign exp .)
    AND             reduce using rule 63 (exp_aux -> exp_sign exp .)
    TO              reduce using rule 63 (exp_aux -> exp_sign exp .)
    BY              reduce using rule 63 (exp_aux -> exp_sign exp .)
    DO              reduce using rule 63 (exp_aux -> exp_sign exp .)


state 179

    (69) term_aux -> term_sign term .
    MINUS           reduce using rule 69 (term_aux -> term_sign term .)
    PLUS            reduce using rule 69 (term_aux -> term_sign term .)
    COMMA           reduce using rule 69 (term_aux -> term_sign term .)
    RPAREN          reduce using rule 69 (term_aux -> term_sign term .)
    NEQ             reduce using rule 69 (term_aux -> term_sign term .)
    EQ              reduce using rule 69 (term_aux -> term_sign term .)
    LTE             reduce using rule 69 (term_aux -> term_sign term .)
    GTE             reduce using rule 69 (term_aux -> term_sign term .)
    LT              reduce using rule 69 (term_aux -> term_sign term .)
    GT              reduce using rule 69 (term_aux -> term_sign term .)
    SEMICOLON       reduce using rule 69 (term_aux -> term_sign term .)
    OR              reduce using rule 69 (term_aux -> term_sign term .)
    AND             reduce using rule 69 (term_aux -> term_sign term .)
    TO              reduce using rule 69 (term_aux -> term_sign term .)
    BY              reduce using rule 69 (term_aux -> term_sign term .)
    DO              reduce using rule 69 (term_aux -> term_sign term .)


state 180

    (53) expression_aux -> relation expression .
    SEMICOLON       reduce using rule 53 (expression_aux -> relation expression .)
    RPAREN          reduce using rule 53 (expression_aux -> relation expression .)
    OR              reduce using rule 53 (expression_aux -> relation expression .)
    AND             reduce using rule 53 (expression_aux -> relation expression .)
    COMMA           reduce using rule 53 (expression_aux -> relation expression .)
    TO              reduce using rule 53 (expression_aux -> relation expression .)
    BY              reduce using rule 53 (expression_aux -> relation expression .)
    DO              reduce using rule 53 (expression_aux -> relation expression .)


state 181

    (80) forloop -> FROM var ASSIGN expression TO expression . BY expression DO block
    (81) forloop -> FROM var ASSIGN expression TO expression . DO block
    BY              shift and go to state 185
    DO              shift and go to state 186


state 182

    (47) super_exp_aux -> logic super_exp .
    COMMA           reduce using rule 47 (super_exp_aux -> logic super_exp .)
    RPAREN          reduce using rule 47 (super_exp_aux -> logic super_exp .)


state 183

    (90) condition -> IF LPAREN expression RPAREN block ELSE . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 187

state 184

    (5) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON . RCURLY
    RCURLY          shift and go to state 188


state 185

    (80) forloop -> FROM var ASSIGN expression TO expression BY . expression DO block
    (55) expression -> . exp expression_quadgen expression_aux
    (65) exp -> . term exp_quadgen exp_aux
    (71) term -> . factor term_quadgen term_aux
    (75) factor -> . LPAREN fakefloor super_exp RPAREN
    (76) factor -> . varcte
    (77) factor -> . call
    (78) factor -> . var
    (92) varcte -> . CTEFLOAT
    (93) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    var                            shift and go to state 113
    expression                     shift and go to state 189
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112

state 186

    (81) forloop -> FROM var ASSIGN expression TO expression DO . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 190

state 187

    (90) condition -> IF LPAREN expression RPAREN block ELSE block .
    ID              reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    FROM            reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    WHILE           reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    INPUT           reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    PRINT           reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    IF              reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RCURLY          reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RETURN          reduce using rule 90 (condition -> IF LPAREN expression RPAREN block ELSE block .)


state 188

    (5) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .
    FUNC            reduce using rule 5 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)
    MAIN            reduce using rule 5 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)


state 189

    (80) forloop -> FROM var ASSIGN expression TO expression BY expression . DO block
    DO              shift and go to state 191


state 190

    (81) forloop -> FROM var ASSIGN expression TO expression DO block .
    ID              reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    FROM            reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    WHILE           reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    INPUT           reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    PRINT           reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    IF              reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RCURLY          reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RETURN          reduce using rule 81 (forloop -> FROM var ASSIGN expression TO expression DO block .)


state 191

    (80) forloop -> FROM var ASSIGN expression TO expression BY expression DO . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 192

state 192

    (80) forloop -> FROM var ASSIGN expression TO expression BY expression DO block .
    ID              reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    FROM            reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    WHILE           reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    INPUT           reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    PRINT           reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    IF              reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RCURLY          reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RETURN          reduce using rule 80 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
