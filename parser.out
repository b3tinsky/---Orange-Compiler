Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID declare
Rule 2     declare -> main_block
Rule 3     declare -> decfuncs main_block
Rule 4     declare -> decvars saveglobalvars main_block
Rule 5     declare -> decvars saveglobalvars decfuncs main_block
Rule 6     main_block -> MAIN changecontext LPAREN RPAREN block
Rule 7     block -> LCURLY blockcontent RCURLY
Rule 8     returnblock -> LCURLY blockcontent RETURN factor SEMICOLON RCURLY
Rule 9     blockcontent -> empty
Rule 10    blockcontent -> statute blockcontent
Rule 11    decvars -> VARS decvar_line
Rule 12    decvar_line -> type decvar SEMICOLON decvar_line
Rule 13    decvar_line -> type decvar SEMICOLON
Rule 14    decvar -> var COMMA decvar
Rule 15    decvar -> var
Rule 16    var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 17    var -> ID LBRACKET exp RBRACKET
Rule 18    var -> ID
Rule 19    decfuncs -> func
Rule 20    decfuncs -> func decfuncs
Rule 21    func -> FUNC typefunc
Rule 22    func -> FUNC voidfunc
Rule 23    voidfunc -> VOID ID changecontext LPAREN params RPAREN block
Rule 24    typefunc -> type ID changecontext LPAREN params RPAREN returnblock
Rule 25    params -> empty
Rule 26    params -> type ID COMMA params
Rule 27    params -> type ID
Rule 28    call -> ID LPAREN callvalues RPAREN
Rule 29    callvalues -> empty
Rule 30    callvalues -> exp COMMA callvalues
Rule 31    callvalues -> exp
Rule 32    super_exp -> expression OR super_exp
Rule 33    super_exp -> expression AND super_exp
Rule 34    super_exp -> expression
Rule 35    expression -> exp relation exp
Rule 36    expression -> exp
Rule 37    relation -> NEQ
Rule 38    relation -> EQ
Rule 39    relation -> LTE
Rule 40    relation -> GTE
Rule 41    relation -> LT
Rule 42    relation -> GT
Rule 43    exp -> term MINUS exp
Rule 44    exp -> term PLUS exp
Rule 45    exp -> term
Rule 46    term -> factor DIVIDE term
Rule 47    term -> factor TIMES term
Rule 48    term -> factor
Rule 49    factor -> LPAREN super_exp RPAREN
Rule 50    factor -> varcte
Rule 51    factor -> call
Rule 52    factor -> var
Rule 53    forloop -> FROM var ASSIGN expression TO expression BY expression DO block
Rule 54    forloop -> FROM var ASSIGN expression TO expression DO block
Rule 55    whileloop -> WHILE LPAREN expression RPAREN block
Rule 56    assignment -> ID ASSIGN expression SEMICOLON
Rule 57    read -> INPUT LPAREN decvar RPAREN SEMICOLON
Rule 58    write -> PRINT LPAREN writevalues RPAREN SEMICOLON
Rule 59    writevalues -> CTESTRING COMMA writevalues
Rule 60    writevalues -> super_exp COMMA writevalues
Rule 61    writevalues -> CTESTRING
Rule 62    writevalues -> super_exp
Rule 63    condition -> IF LPAREN expression RPAREN block ELSE block
Rule 64    condition -> IF LPAREN expression RPAREN block
Rule 65    varcte -> CTEFLOAT
Rule 66    varcte -> CTEINT
Rule 67    type -> FLOAT
Rule 68    type -> INT
Rule 69    statute -> call
Rule 70    statute -> decvars
Rule 71    statute -> forloop
Rule 72    statute -> whileloop
Rule 73    statute -> read
Rule 74    statute -> write
Rule 75    statute -> condition
Rule 76    statute -> assignment
Rule 77    changecontext -> <empty>
Rule 78    saveglobalvars -> <empty>
Rule 79    empty -> <empty>

Terminals, with rules where they appear:

AND                  : 33
ASSIGN               : 53 54 56
BY                   : 53
COMMA                : 14 26 30 59 60
CTEFLOAT             : 65
CTEINT               : 66
CTESTRING            : 59 61
DIVIDE               : 46
DO                   : 53 54
ELSE                 : 63
EQ                   : 38
FLOAT                : 67
FROM                 : 53 54
FUNC                 : 21 22
GT                   : 42
GTE                  : 40
ID                   : 1 16 17 18 23 24 26 27 28 56
IF                   : 63 64
INPUT                : 57
INT                  : 68
LBRACKET             : 16 16 17
LCURLY               : 7 8
LPAREN               : 6 23 24 28 49 55 57 58 63 64
LT                   : 41
LTE                  : 39
MAIN                 : 6
MINUS                : 43
NEQ                  : 37
OR                   : 32
PLUS                 : 44
PRINT                : 58
PROGRAM              : 1
RBRACKET             : 16 16 17
RCURLY               : 7 8
RETURN               : 8
RPAREN               : 6 23 24 28 49 55 57 58 63 64
SEMICOLON            : 8 12 13 56 57 58
TIMES                : 47
TO                   : 53 54
VARS                 : 11
VOID                 : 23
WHILE                : 55
error                : 

Nonterminals, with rules where they appear:

assignment           : 76
block                : 6 23 53 54 55 63 63 64
blockcontent         : 7 8 10
call                 : 51 69
callvalues           : 28 30
changecontext        : 6 23 24
condition            : 75
decfuncs             : 3 5 20
declare              : 1
decvar               : 12 13 14 57
decvar_line          : 11 12
decvars              : 4 5 70
empty                : 9 25 29
exp                  : 16 16 17 30 31 35 35 36 43 44
expression           : 32 33 34 53 53 53 54 54 55 56 63 64
factor               : 8 46 47 48
forloop              : 71
func                 : 19 20
main_block           : 2 3 4 5
params               : 23 24 26
program              : 0
read                 : 73
relation             : 35
returnblock          : 24
saveglobalvars       : 4 5
statute              : 10
super_exp            : 32 33 49 60 62
term                 : 43 44 45 46 47
type                 : 12 13 24 26 27
typefunc             : 21
var                  : 14 15 52 53 54
varcte               : 50
voidfunc             : 22
whileloop            : 72
write                : 74
writevalues          : 58 59 60


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . declare
    (2) declare -> . main_block
    (3) declare -> . decfuncs main_block
    (4) declare -> . decvars saveglobalvars main_block
    (5) declare -> . decvars saveglobalvars decfuncs main_block
    (6) main_block -> . MAIN changecontext LPAREN RPAREN block
    (19) decfuncs -> . func
    (20) decfuncs -> . func decfuncs
    (11) decvars -> . VARS decvar_line
    (21) func -> . FUNC typefunc
    (22) func -> . FUNC voidfunc
    MAIN            shift and go to state 8
    VARS            shift and go to state 10
    FUNC            shift and go to state 11

    declare                        shift and go to state 4
    main_block                     shift and go to state 5
    decfuncs                       shift and go to state 6
    decvars                        shift and go to state 7
    func                           shift and go to state 9

state 4

    (1) program -> PROGRAM ID declare .
    $end            reduce using rule 1 (program -> PROGRAM ID declare .)


state 5

    (2) declare -> main_block .
    $end            reduce using rule 2 (declare -> main_block .)


state 6

    (3) declare -> decfuncs . main_block
    (6) main_block -> . MAIN changecontext LPAREN RPAREN block
    MAIN            shift and go to state 8

    main_block                     shift and go to state 12

state 7

    (4) declare -> decvars . saveglobalvars main_block
    (5) declare -> decvars . saveglobalvars decfuncs main_block
    (78) saveglobalvars -> .
    MAIN            reduce using rule 78 (saveglobalvars -> .)
    FUNC            reduce using rule 78 (saveglobalvars -> .)

    saveglobalvars                 shift and go to state 13

state 8

    (6) main_block -> MAIN . changecontext LPAREN RPAREN block
    (77) changecontext -> .
    LPAREN          reduce using rule 77 (changecontext -> .)

    changecontext                  shift and go to state 14

state 9

    (19) decfuncs -> func .
    (20) decfuncs -> func . decfuncs
    (19) decfuncs -> . func
    (20) decfuncs -> . func decfuncs
    (21) func -> . FUNC typefunc
    (22) func -> . FUNC voidfunc
    MAIN            reduce using rule 19 (decfuncs -> func .)
    FUNC            shift and go to state 11

    func                           shift and go to state 9
    decfuncs                       shift and go to state 15

state 10

    (11) decvars -> VARS . decvar_line
    (12) decvar_line -> . type decvar SEMICOLON decvar_line
    (13) decvar_line -> . type decvar SEMICOLON
    (67) type -> . FLOAT
    (68) type -> . INT
    FLOAT           shift and go to state 18
    INT             shift and go to state 19

    decvar_line                    shift and go to state 16
    type                           shift and go to state 17

state 11

    (21) func -> FUNC . typefunc
    (22) func -> FUNC . voidfunc
    (24) typefunc -> . type ID changecontext LPAREN params RPAREN returnblock
    (23) voidfunc -> . VOID ID changecontext LPAREN params RPAREN block
    (67) type -> . FLOAT
    (68) type -> . INT
    VOID            shift and go to state 23
    FLOAT           shift and go to state 18
    INT             shift and go to state 19

    typefunc                       shift and go to state 20
    voidfunc                       shift and go to state 21
    type                           shift and go to state 22

state 12

    (3) declare -> decfuncs main_block .
    $end            reduce using rule 3 (declare -> decfuncs main_block .)


state 13

    (4) declare -> decvars saveglobalvars . main_block
    (5) declare -> decvars saveglobalvars . decfuncs main_block
    (6) main_block -> . MAIN changecontext LPAREN RPAREN block
    (19) decfuncs -> . func
    (20) decfuncs -> . func decfuncs
    (21) func -> . FUNC typefunc
    (22) func -> . FUNC voidfunc
    MAIN            shift and go to state 8
    FUNC            shift and go to state 11

    main_block                     shift and go to state 24
    decfuncs                       shift and go to state 25
    func                           shift and go to state 9

state 14

    (6) main_block -> MAIN changecontext . LPAREN RPAREN block
    LPAREN          shift and go to state 26


state 15

    (20) decfuncs -> func decfuncs .
    MAIN            reduce using rule 20 (decfuncs -> func decfuncs .)


state 16

    (11) decvars -> VARS decvar_line .
    MAIN            reduce using rule 11 (decvars -> VARS decvar_line .)
    FUNC            reduce using rule 11 (decvars -> VARS decvar_line .)
    ID              reduce using rule 11 (decvars -> VARS decvar_line .)
    VARS            reduce using rule 11 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 11 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 11 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 11 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 11 (decvars -> VARS decvar_line .)
    IF              reduce using rule 11 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 11 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 11 (decvars -> VARS decvar_line .)


state 17

    (12) decvar_line -> type . decvar SEMICOLON decvar_line
    (13) decvar_line -> type . decvar SEMICOLON
    (14) decvar -> . var COMMA decvar
    (15) decvar -> . var
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    ID              shift and go to state 29

    decvar                         shift and go to state 27
    var                            shift and go to state 28

state 18

    (67) type -> FLOAT .
    ID              reduce using rule 67 (type -> FLOAT .)


state 19

    (68) type -> INT .
    ID              reduce using rule 68 (type -> INT .)


state 20

    (21) func -> FUNC typefunc .
    FUNC            reduce using rule 21 (func -> FUNC typefunc .)
    MAIN            reduce using rule 21 (func -> FUNC typefunc .)


state 21

    (22) func -> FUNC voidfunc .
    FUNC            reduce using rule 22 (func -> FUNC voidfunc .)
    MAIN            reduce using rule 22 (func -> FUNC voidfunc .)


state 22

    (24) typefunc -> type . ID changecontext LPAREN params RPAREN returnblock
    ID              shift and go to state 30


state 23

    (23) voidfunc -> VOID . ID changecontext LPAREN params RPAREN block
    ID              shift and go to state 31


state 24

    (4) declare -> decvars saveglobalvars main_block .
    $end            reduce using rule 4 (declare -> decvars saveglobalvars main_block .)


state 25

    (5) declare -> decvars saveglobalvars decfuncs . main_block
    (6) main_block -> . MAIN changecontext LPAREN RPAREN block
    MAIN            shift and go to state 8

    main_block                     shift and go to state 32

state 26

    (6) main_block -> MAIN changecontext LPAREN . RPAREN block
    RPAREN          shift and go to state 33


state 27

    (12) decvar_line -> type decvar . SEMICOLON decvar_line
    (13) decvar_line -> type decvar . SEMICOLON
    SEMICOLON       shift and go to state 34


state 28

    (14) decvar -> var . COMMA decvar
    (15) decvar -> var .
    COMMA           shift and go to state 35
    SEMICOLON       reduce using rule 15 (decvar -> var .)
    RPAREN          reduce using rule 15 (decvar -> var .)


state 29

    (16) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> ID . LBRACKET exp RBRACKET
    (18) var -> ID .
    LBRACKET        shift and go to state 36
    COMMA           reduce using rule 18 (var -> ID .)
    SEMICOLON       reduce using rule 18 (var -> ID .)
    RPAREN          reduce using rule 18 (var -> ID .)
    ASSIGN          reduce using rule 18 (var -> ID .)


state 30

    (24) typefunc -> type ID . changecontext LPAREN params RPAREN returnblock
    (77) changecontext -> .
    LPAREN          reduce using rule 77 (changecontext -> .)

    changecontext                  shift and go to state 37

state 31

    (23) voidfunc -> VOID ID . changecontext LPAREN params RPAREN block
    (77) changecontext -> .
    LPAREN          reduce using rule 77 (changecontext -> .)

    changecontext                  shift and go to state 38

state 32

    (5) declare -> decvars saveglobalvars decfuncs main_block .
    $end            reduce using rule 5 (declare -> decvars saveglobalvars decfuncs main_block .)


state 33

    (6) main_block -> MAIN changecontext LPAREN RPAREN . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 39

state 34

    (12) decvar_line -> type decvar SEMICOLON . decvar_line
    (13) decvar_line -> type decvar SEMICOLON .
    (12) decvar_line -> . type decvar SEMICOLON decvar_line
    (13) decvar_line -> . type decvar SEMICOLON
    (67) type -> . FLOAT
    (68) type -> . INT
    MAIN            reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    FUNC            reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    ID              reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    VARS            reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    FROM            reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    WHILE           reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    INPUT           reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    PRINT           reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    IF              reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    RCURLY          reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    RETURN          reduce using rule 13 (decvar_line -> type decvar SEMICOLON .)
    FLOAT           shift and go to state 18
    INT             shift and go to state 19

    type                           shift and go to state 17
    decvar_line                    shift and go to state 41

state 35

    (14) decvar -> var COMMA . decvar
    (14) decvar -> . var COMMA decvar
    (15) decvar -> . var
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    ID              shift and go to state 29

    var                            shift and go to state 28
    decvar                         shift and go to state 42

state 36

    (16) var -> ID LBRACKET . exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> ID LBRACKET . exp RBRACKET
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    exp                            shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 37

    (24) typefunc -> type ID changecontext . LPAREN params RPAREN returnblock
    LPAREN          shift and go to state 53


state 38

    (23) voidfunc -> VOID ID changecontext . LPAREN params RPAREN block
    LPAREN          shift and go to state 54


state 39

    (6) main_block -> MAIN changecontext LPAREN RPAREN block .
    $end            reduce using rule 6 (main_block -> MAIN changecontext LPAREN RPAREN block .)


state 40

    (7) block -> LCURLY . blockcontent RCURLY
    (9) blockcontent -> . empty
    (10) blockcontent -> . statute blockcontent
    (79) empty -> .
    (69) statute -> . call
    (70) statute -> . decvars
    (71) statute -> . forloop
    (72) statute -> . whileloop
    (73) statute -> . read
    (74) statute -> . write
    (75) statute -> . condition
    (76) statute -> . assignment
    (28) call -> . ID LPAREN callvalues RPAREN
    (11) decvars -> . VARS decvar_line
    (53) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (54) forloop -> . FROM var ASSIGN expression TO expression DO block
    (55) whileloop -> . WHILE LPAREN expression RPAREN block
    (57) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (58) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (63) condition -> . IF LPAREN expression RPAREN block ELSE block
    (64) condition -> . IF LPAREN expression RPAREN block
    (56) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 79 (empty -> .)
    ID              shift and go to state 66
    VARS            shift and go to state 10
    FROM            shift and go to state 67
    WHILE           shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71

    blockcontent                   shift and go to state 55
    empty                          shift and go to state 56
    statute                        shift and go to state 57
    call                           shift and go to state 58
    decvars                        shift and go to state 59
    forloop                        shift and go to state 60
    whileloop                      shift and go to state 61
    read                           shift and go to state 62
    write                          shift and go to state 63
    condition                      shift and go to state 64
    assignment                     shift and go to state 65

state 41

    (12) decvar_line -> type decvar SEMICOLON decvar_line .
    MAIN            reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FUNC            reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    VARS            reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 12 (decvar_line -> type decvar SEMICOLON decvar_line .)


state 42

    (14) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 14 (decvar -> var COMMA decvar .)
    RPAREN          reduce using rule 14 (decvar -> var COMMA decvar .)


state 43

    (28) call -> ID . LPAREN callvalues RPAREN
    (16) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> ID . LBRACKET exp RBRACKET
    (18) var -> ID .
    LPAREN          shift and go to state 72
    LBRACKET        shift and go to state 36
    DIVIDE          reduce using rule 18 (var -> ID .)
    TIMES           reduce using rule 18 (var -> ID .)
    MINUS           reduce using rule 18 (var -> ID .)
    PLUS            reduce using rule 18 (var -> ID .)
    RBRACKET        reduce using rule 18 (var -> ID .)
    NEQ             reduce using rule 18 (var -> ID .)
    EQ              reduce using rule 18 (var -> ID .)
    LTE             reduce using rule 18 (var -> ID .)
    GTE             reduce using rule 18 (var -> ID .)
    LT              reduce using rule 18 (var -> ID .)
    GT              reduce using rule 18 (var -> ID .)
    OR              reduce using rule 18 (var -> ID .)
    AND             reduce using rule 18 (var -> ID .)
    RPAREN          reduce using rule 18 (var -> ID .)
    COMMA           reduce using rule 18 (var -> ID .)
    SEMICOLON       reduce using rule 18 (var -> ID .)
    TO              reduce using rule 18 (var -> ID .)
    BY              reduce using rule 18 (var -> ID .)
    DO              reduce using rule 18 (var -> ID .)


state 44

    (16) var -> ID LBRACKET exp . RBRACKET LBRACKET exp RBRACKET
    (17) var -> ID LBRACKET exp . RBRACKET
    RBRACKET        shift and go to state 73


state 45

    (43) exp -> term . MINUS exp
    (44) exp -> term . PLUS exp
    (45) exp -> term .
    MINUS           shift and go to state 74
    PLUS            shift and go to state 75
    RBRACKET        reduce using rule 45 (exp -> term .)
    NEQ             reduce using rule 45 (exp -> term .)
    EQ              reduce using rule 45 (exp -> term .)
    LTE             reduce using rule 45 (exp -> term .)
    GTE             reduce using rule 45 (exp -> term .)
    LT              reduce using rule 45 (exp -> term .)
    GT              reduce using rule 45 (exp -> term .)
    OR              reduce using rule 45 (exp -> term .)
    AND             reduce using rule 45 (exp -> term .)
    RPAREN          reduce using rule 45 (exp -> term .)
    COMMA           reduce using rule 45 (exp -> term .)
    SEMICOLON       reduce using rule 45 (exp -> term .)
    TO              reduce using rule 45 (exp -> term .)
    BY              reduce using rule 45 (exp -> term .)
    DO              reduce using rule 45 (exp -> term .)


state 46

    (46) term -> factor . DIVIDE term
    (47) term -> factor . TIMES term
    (48) term -> factor .
    DIVIDE          shift and go to state 76
    TIMES           shift and go to state 77
    MINUS           reduce using rule 48 (term -> factor .)
    PLUS            reduce using rule 48 (term -> factor .)
    RBRACKET        reduce using rule 48 (term -> factor .)
    NEQ             reduce using rule 48 (term -> factor .)
    EQ              reduce using rule 48 (term -> factor .)
    LTE             reduce using rule 48 (term -> factor .)
    GTE             reduce using rule 48 (term -> factor .)
    LT              reduce using rule 48 (term -> factor .)
    GT              reduce using rule 48 (term -> factor .)
    OR              reduce using rule 48 (term -> factor .)
    AND             reduce using rule 48 (term -> factor .)
    RPAREN          reduce using rule 48 (term -> factor .)
    COMMA           reduce using rule 48 (term -> factor .)
    SEMICOLON       reduce using rule 48 (term -> factor .)
    TO              reduce using rule 48 (term -> factor .)
    BY              reduce using rule 48 (term -> factor .)
    DO              reduce using rule 48 (term -> factor .)


state 47

    (49) factor -> LPAREN . super_exp RPAREN
    (32) super_exp -> . expression OR super_exp
    (33) super_exp -> . expression AND super_exp
    (34) super_exp -> . expression
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    super_exp                      shift and go to state 78
    expression                     shift and go to state 79
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 48

    (50) factor -> varcte .
    DIVIDE          reduce using rule 50 (factor -> varcte .)
    TIMES           reduce using rule 50 (factor -> varcte .)
    MINUS           reduce using rule 50 (factor -> varcte .)
    PLUS            reduce using rule 50 (factor -> varcte .)
    RBRACKET        reduce using rule 50 (factor -> varcte .)
    NEQ             reduce using rule 50 (factor -> varcte .)
    EQ              reduce using rule 50 (factor -> varcte .)
    LTE             reduce using rule 50 (factor -> varcte .)
    GTE             reduce using rule 50 (factor -> varcte .)
    LT              reduce using rule 50 (factor -> varcte .)
    GT              reduce using rule 50 (factor -> varcte .)
    OR              reduce using rule 50 (factor -> varcte .)
    AND             reduce using rule 50 (factor -> varcte .)
    RPAREN          reduce using rule 50 (factor -> varcte .)
    COMMA           reduce using rule 50 (factor -> varcte .)
    SEMICOLON       reduce using rule 50 (factor -> varcte .)
    TO              reduce using rule 50 (factor -> varcte .)
    BY              reduce using rule 50 (factor -> varcte .)
    DO              reduce using rule 50 (factor -> varcte .)


state 49

    (51) factor -> call .
    DIVIDE          reduce using rule 51 (factor -> call .)
    TIMES           reduce using rule 51 (factor -> call .)
    MINUS           reduce using rule 51 (factor -> call .)
    PLUS            reduce using rule 51 (factor -> call .)
    RBRACKET        reduce using rule 51 (factor -> call .)
    NEQ             reduce using rule 51 (factor -> call .)
    EQ              reduce using rule 51 (factor -> call .)
    LTE             reduce using rule 51 (factor -> call .)
    GTE             reduce using rule 51 (factor -> call .)
    LT              reduce using rule 51 (factor -> call .)
    GT              reduce using rule 51 (factor -> call .)
    OR              reduce using rule 51 (factor -> call .)
    AND             reduce using rule 51 (factor -> call .)
    RPAREN          reduce using rule 51 (factor -> call .)
    COMMA           reduce using rule 51 (factor -> call .)
    SEMICOLON       reduce using rule 51 (factor -> call .)
    TO              reduce using rule 51 (factor -> call .)
    BY              reduce using rule 51 (factor -> call .)
    DO              reduce using rule 51 (factor -> call .)


state 50

    (52) factor -> var .
    DIVIDE          reduce using rule 52 (factor -> var .)
    TIMES           reduce using rule 52 (factor -> var .)
    MINUS           reduce using rule 52 (factor -> var .)
    PLUS            reduce using rule 52 (factor -> var .)
    RBRACKET        reduce using rule 52 (factor -> var .)
    NEQ             reduce using rule 52 (factor -> var .)
    EQ              reduce using rule 52 (factor -> var .)
    LTE             reduce using rule 52 (factor -> var .)
    GTE             reduce using rule 52 (factor -> var .)
    LT              reduce using rule 52 (factor -> var .)
    GT              reduce using rule 52 (factor -> var .)
    OR              reduce using rule 52 (factor -> var .)
    AND             reduce using rule 52 (factor -> var .)
    RPAREN          reduce using rule 52 (factor -> var .)
    COMMA           reduce using rule 52 (factor -> var .)
    SEMICOLON       reduce using rule 52 (factor -> var .)
    TO              reduce using rule 52 (factor -> var .)
    BY              reduce using rule 52 (factor -> var .)
    DO              reduce using rule 52 (factor -> var .)


state 51

    (65) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 65 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 65 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 65 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 65 (varcte -> CTEFLOAT .)
    RBRACKET        reduce using rule 65 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 65 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 65 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 65 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 65 (varcte -> CTEFLOAT .)
    LT              reduce using rule 65 (varcte -> CTEFLOAT .)
    GT              reduce using rule 65 (varcte -> CTEFLOAT .)
    OR              reduce using rule 65 (varcte -> CTEFLOAT .)
    AND             reduce using rule 65 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 65 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 65 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 65 (varcte -> CTEFLOAT .)
    TO              reduce using rule 65 (varcte -> CTEFLOAT .)
    BY              reduce using rule 65 (varcte -> CTEFLOAT .)
    DO              reduce using rule 65 (varcte -> CTEFLOAT .)


state 52

    (66) varcte -> CTEINT .
    DIVIDE          reduce using rule 66 (varcte -> CTEINT .)
    TIMES           reduce using rule 66 (varcte -> CTEINT .)
    MINUS           reduce using rule 66 (varcte -> CTEINT .)
    PLUS            reduce using rule 66 (varcte -> CTEINT .)
    RBRACKET        reduce using rule 66 (varcte -> CTEINT .)
    NEQ             reduce using rule 66 (varcte -> CTEINT .)
    EQ              reduce using rule 66 (varcte -> CTEINT .)
    LTE             reduce using rule 66 (varcte -> CTEINT .)
    GTE             reduce using rule 66 (varcte -> CTEINT .)
    LT              reduce using rule 66 (varcte -> CTEINT .)
    GT              reduce using rule 66 (varcte -> CTEINT .)
    OR              reduce using rule 66 (varcte -> CTEINT .)
    AND             reduce using rule 66 (varcte -> CTEINT .)
    RPAREN          reduce using rule 66 (varcte -> CTEINT .)
    COMMA           reduce using rule 66 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 66 (varcte -> CTEINT .)
    TO              reduce using rule 66 (varcte -> CTEINT .)
    BY              reduce using rule 66 (varcte -> CTEINT .)
    DO              reduce using rule 66 (varcte -> CTEINT .)


state 53

    (24) typefunc -> type ID changecontext LPAREN . params RPAREN returnblock
    (25) params -> . empty
    (26) params -> . type ID COMMA params
    (27) params -> . type ID
    (79) empty -> .
    (67) type -> . FLOAT
    (68) type -> . INT
    RPAREN          reduce using rule 79 (empty -> .)
    FLOAT           shift and go to state 18
    INT             shift and go to state 19

    type                           shift and go to state 81
    params                         shift and go to state 82
    empty                          shift and go to state 83

state 54

    (23) voidfunc -> VOID ID changecontext LPAREN . params RPAREN block
    (25) params -> . empty
    (26) params -> . type ID COMMA params
    (27) params -> . type ID
    (79) empty -> .
    (67) type -> . FLOAT
    (68) type -> . INT
    RPAREN          reduce using rule 79 (empty -> .)
    FLOAT           shift and go to state 18
    INT             shift and go to state 19

    params                         shift and go to state 84
    empty                          shift and go to state 83
    type                           shift and go to state 81

state 55

    (7) block -> LCURLY blockcontent . RCURLY
    RCURLY          shift and go to state 85


state 56

    (9) blockcontent -> empty .
    RCURLY          reduce using rule 9 (blockcontent -> empty .)
    RETURN          reduce using rule 9 (blockcontent -> empty .)


state 57

    (10) blockcontent -> statute . blockcontent
    (9) blockcontent -> . empty
    (10) blockcontent -> . statute blockcontent
    (79) empty -> .
    (69) statute -> . call
    (70) statute -> . decvars
    (71) statute -> . forloop
    (72) statute -> . whileloop
    (73) statute -> . read
    (74) statute -> . write
    (75) statute -> . condition
    (76) statute -> . assignment
    (28) call -> . ID LPAREN callvalues RPAREN
    (11) decvars -> . VARS decvar_line
    (53) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (54) forloop -> . FROM var ASSIGN expression TO expression DO block
    (55) whileloop -> . WHILE LPAREN expression RPAREN block
    (57) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (58) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (63) condition -> . IF LPAREN expression RPAREN block ELSE block
    (64) condition -> . IF LPAREN expression RPAREN block
    (56) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 79 (empty -> .)
    RETURN          reduce using rule 79 (empty -> .)
    ID              shift and go to state 66
    VARS            shift and go to state 10
    FROM            shift and go to state 67
    WHILE           shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71

    statute                        shift and go to state 57
    blockcontent                   shift and go to state 86
    empty                          shift and go to state 56
    call                           shift and go to state 58
    decvars                        shift and go to state 59
    forloop                        shift and go to state 60
    whileloop                      shift and go to state 61
    read                           shift and go to state 62
    write                          shift and go to state 63
    condition                      shift and go to state 64
    assignment                     shift and go to state 65

state 58

    (69) statute -> call .
    ID              reduce using rule 69 (statute -> call .)
    VARS            reduce using rule 69 (statute -> call .)
    FROM            reduce using rule 69 (statute -> call .)
    WHILE           reduce using rule 69 (statute -> call .)
    INPUT           reduce using rule 69 (statute -> call .)
    PRINT           reduce using rule 69 (statute -> call .)
    IF              reduce using rule 69 (statute -> call .)
    RCURLY          reduce using rule 69 (statute -> call .)
    RETURN          reduce using rule 69 (statute -> call .)


state 59

    (70) statute -> decvars .
    ID              reduce using rule 70 (statute -> decvars .)
    VARS            reduce using rule 70 (statute -> decvars .)
    FROM            reduce using rule 70 (statute -> decvars .)
    WHILE           reduce using rule 70 (statute -> decvars .)
    INPUT           reduce using rule 70 (statute -> decvars .)
    PRINT           reduce using rule 70 (statute -> decvars .)
    IF              reduce using rule 70 (statute -> decvars .)
    RCURLY          reduce using rule 70 (statute -> decvars .)
    RETURN          reduce using rule 70 (statute -> decvars .)


state 60

    (71) statute -> forloop .
    ID              reduce using rule 71 (statute -> forloop .)
    VARS            reduce using rule 71 (statute -> forloop .)
    FROM            reduce using rule 71 (statute -> forloop .)
    WHILE           reduce using rule 71 (statute -> forloop .)
    INPUT           reduce using rule 71 (statute -> forloop .)
    PRINT           reduce using rule 71 (statute -> forloop .)
    IF              reduce using rule 71 (statute -> forloop .)
    RCURLY          reduce using rule 71 (statute -> forloop .)
    RETURN          reduce using rule 71 (statute -> forloop .)


state 61

    (72) statute -> whileloop .
    ID              reduce using rule 72 (statute -> whileloop .)
    VARS            reduce using rule 72 (statute -> whileloop .)
    FROM            reduce using rule 72 (statute -> whileloop .)
    WHILE           reduce using rule 72 (statute -> whileloop .)
    INPUT           reduce using rule 72 (statute -> whileloop .)
    PRINT           reduce using rule 72 (statute -> whileloop .)
    IF              reduce using rule 72 (statute -> whileloop .)
    RCURLY          reduce using rule 72 (statute -> whileloop .)
    RETURN          reduce using rule 72 (statute -> whileloop .)


state 62

    (73) statute -> read .
    ID              reduce using rule 73 (statute -> read .)
    VARS            reduce using rule 73 (statute -> read .)
    FROM            reduce using rule 73 (statute -> read .)
    WHILE           reduce using rule 73 (statute -> read .)
    INPUT           reduce using rule 73 (statute -> read .)
    PRINT           reduce using rule 73 (statute -> read .)
    IF              reduce using rule 73 (statute -> read .)
    RCURLY          reduce using rule 73 (statute -> read .)
    RETURN          reduce using rule 73 (statute -> read .)


state 63

    (74) statute -> write .
    ID              reduce using rule 74 (statute -> write .)
    VARS            reduce using rule 74 (statute -> write .)
    FROM            reduce using rule 74 (statute -> write .)
    WHILE           reduce using rule 74 (statute -> write .)
    INPUT           reduce using rule 74 (statute -> write .)
    PRINT           reduce using rule 74 (statute -> write .)
    IF              reduce using rule 74 (statute -> write .)
    RCURLY          reduce using rule 74 (statute -> write .)
    RETURN          reduce using rule 74 (statute -> write .)


state 64

    (75) statute -> condition .
    ID              reduce using rule 75 (statute -> condition .)
    VARS            reduce using rule 75 (statute -> condition .)
    FROM            reduce using rule 75 (statute -> condition .)
    WHILE           reduce using rule 75 (statute -> condition .)
    INPUT           reduce using rule 75 (statute -> condition .)
    PRINT           reduce using rule 75 (statute -> condition .)
    IF              reduce using rule 75 (statute -> condition .)
    RCURLY          reduce using rule 75 (statute -> condition .)
    RETURN          reduce using rule 75 (statute -> condition .)


state 65

    (76) statute -> assignment .
    ID              reduce using rule 76 (statute -> assignment .)
    VARS            reduce using rule 76 (statute -> assignment .)
    FROM            reduce using rule 76 (statute -> assignment .)
    WHILE           reduce using rule 76 (statute -> assignment .)
    INPUT           reduce using rule 76 (statute -> assignment .)
    PRINT           reduce using rule 76 (statute -> assignment .)
    IF              reduce using rule 76 (statute -> assignment .)
    RCURLY          reduce using rule 76 (statute -> assignment .)
    RETURN          reduce using rule 76 (statute -> assignment .)


state 66

    (28) call -> ID . LPAREN callvalues RPAREN
    (56) assignment -> ID . ASSIGN expression SEMICOLON
    LPAREN          shift and go to state 72
    ASSIGN          shift and go to state 87


state 67

    (53) forloop -> FROM . var ASSIGN expression TO expression BY expression DO block
    (54) forloop -> FROM . var ASSIGN expression TO expression DO block
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    ID              shift and go to state 29

    var                            shift and go to state 88

state 68

    (55) whileloop -> WHILE . LPAREN expression RPAREN block
    LPAREN          shift and go to state 89


state 69

    (57) read -> INPUT . LPAREN decvar RPAREN SEMICOLON
    LPAREN          shift and go to state 90


state 70

    (58) write -> PRINT . LPAREN writevalues RPAREN SEMICOLON
    LPAREN          shift and go to state 91


state 71

    (63) condition -> IF . LPAREN expression RPAREN block ELSE block
    (64) condition -> IF . LPAREN expression RPAREN block
    LPAREN          shift and go to state 92


state 72

    (28) call -> ID LPAREN . callvalues RPAREN
    (29) callvalues -> . empty
    (30) callvalues -> . exp COMMA callvalues
    (31) callvalues -> . exp
    (79) empty -> .
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    RPAREN          reduce using rule 79 (empty -> .)
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    callvalues                     shift and go to state 93
    empty                          shift and go to state 94
    exp                            shift and go to state 95
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 73

    (16) var -> ID LBRACKET exp RBRACKET . LBRACKET exp RBRACKET
    (17) var -> ID LBRACKET exp RBRACKET .
    LBRACKET        shift and go to state 96
    COMMA           reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    NEQ             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    EQ              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    LTE             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    GTE             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    LT              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    GT              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    OR              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    AND             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    ASSIGN          reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    TO              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    BY              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)
    DO              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET .)


state 74

    (43) exp -> term MINUS . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    term                           shift and go to state 45
    exp                            shift and go to state 97
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 75

    (44) exp -> term PLUS . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    term                           shift and go to state 45
    exp                            shift and go to state 98
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 76

    (46) term -> factor DIVIDE . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    factor                         shift and go to state 46
    term                           shift and go to state 99
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 77

    (47) term -> factor TIMES . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    factor                         shift and go to state 46
    term                           shift and go to state 100
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 78

    (49) factor -> LPAREN super_exp . RPAREN
    RPAREN          shift and go to state 101


state 79

    (32) super_exp -> expression . OR super_exp
    (33) super_exp -> expression . AND super_exp
    (34) super_exp -> expression .
    OR              shift and go to state 102
    AND             shift and go to state 103
    RPAREN          reduce using rule 34 (super_exp -> expression .)
    COMMA           reduce using rule 34 (super_exp -> expression .)


state 80

    (35) expression -> exp . relation exp
    (36) expression -> exp .
    (37) relation -> . NEQ
    (38) relation -> . EQ
    (39) relation -> . LTE
    (40) relation -> . GTE
    (41) relation -> . LT
    (42) relation -> . GT
    OR              reduce using rule 36 (expression -> exp .)
    AND             reduce using rule 36 (expression -> exp .)
    RPAREN          reduce using rule 36 (expression -> exp .)
    SEMICOLON       reduce using rule 36 (expression -> exp .)
    COMMA           reduce using rule 36 (expression -> exp .)
    TO              reduce using rule 36 (expression -> exp .)
    BY              reduce using rule 36 (expression -> exp .)
    DO              reduce using rule 36 (expression -> exp .)
    NEQ             shift and go to state 105
    EQ              shift and go to state 106
    LTE             shift and go to state 107
    GTE             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110

    relation                       shift and go to state 104

state 81

    (26) params -> type . ID COMMA params
    (27) params -> type . ID
    ID              shift and go to state 111


state 82

    (24) typefunc -> type ID changecontext LPAREN params . RPAREN returnblock
    RPAREN          shift and go to state 112


state 83

    (25) params -> empty .
    RPAREN          reduce using rule 25 (params -> empty .)


state 84

    (23) voidfunc -> VOID ID changecontext LPAREN params . RPAREN block
    RPAREN          shift and go to state 113


state 85

    (7) block -> LCURLY blockcontent RCURLY .
    $end            reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    FUNC            reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    MAIN            reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    ID              reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    VARS            reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    FROM            reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    WHILE           reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    INPUT           reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    PRINT           reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    IF              reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    RCURLY          reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    RETURN          reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)
    ELSE            reduce using rule 7 (block -> LCURLY blockcontent RCURLY .)


state 86

    (10) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 10 (blockcontent -> statute blockcontent .)
    RETURN          reduce using rule 10 (blockcontent -> statute blockcontent .)


state 87

    (56) assignment -> ID ASSIGN . expression SEMICOLON
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    expression                     shift and go to state 114
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 88

    (53) forloop -> FROM var . ASSIGN expression TO expression BY expression DO block
    (54) forloop -> FROM var . ASSIGN expression TO expression DO block
    ASSIGN          shift and go to state 115


state 89

    (55) whileloop -> WHILE LPAREN . expression RPAREN block
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    expression                     shift and go to state 116
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 90

    (57) read -> INPUT LPAREN . decvar RPAREN SEMICOLON
    (14) decvar -> . var COMMA decvar
    (15) decvar -> . var
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    ID              shift and go to state 29

    decvar                         shift and go to state 117
    var                            shift and go to state 28

state 91

    (58) write -> PRINT LPAREN . writevalues RPAREN SEMICOLON
    (59) writevalues -> . CTESTRING COMMA writevalues
    (60) writevalues -> . super_exp COMMA writevalues
    (61) writevalues -> . CTESTRING
    (62) writevalues -> . super_exp
    (32) super_exp -> . expression OR super_exp
    (33) super_exp -> . expression AND super_exp
    (34) super_exp -> . expression
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    CTESTRING       shift and go to state 119
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    writevalues                    shift and go to state 118
    super_exp                      shift and go to state 120
    expression                     shift and go to state 79
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 92

    (63) condition -> IF LPAREN . expression RPAREN block ELSE block
    (64) condition -> IF LPAREN . expression RPAREN block
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    expression                     shift and go to state 121
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 93

    (28) call -> ID LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 122


state 94

    (29) callvalues -> empty .
    RPAREN          reduce using rule 29 (callvalues -> empty .)


state 95

    (30) callvalues -> exp . COMMA callvalues
    (31) callvalues -> exp .
    COMMA           shift and go to state 123
    RPAREN          reduce using rule 31 (callvalues -> exp .)


state 96

    (16) var -> ID LBRACKET exp RBRACKET LBRACKET . exp RBRACKET
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    exp                            shift and go to state 124
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 97

    (43) exp -> term MINUS exp .
    RBRACKET        reduce using rule 43 (exp -> term MINUS exp .)
    NEQ             reduce using rule 43 (exp -> term MINUS exp .)
    EQ              reduce using rule 43 (exp -> term MINUS exp .)
    LTE             reduce using rule 43 (exp -> term MINUS exp .)
    GTE             reduce using rule 43 (exp -> term MINUS exp .)
    LT              reduce using rule 43 (exp -> term MINUS exp .)
    GT              reduce using rule 43 (exp -> term MINUS exp .)
    OR              reduce using rule 43 (exp -> term MINUS exp .)
    AND             reduce using rule 43 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 43 (exp -> term MINUS exp .)
    COMMA           reduce using rule 43 (exp -> term MINUS exp .)
    SEMICOLON       reduce using rule 43 (exp -> term MINUS exp .)
    TO              reduce using rule 43 (exp -> term MINUS exp .)
    BY              reduce using rule 43 (exp -> term MINUS exp .)
    DO              reduce using rule 43 (exp -> term MINUS exp .)


state 98

    (44) exp -> term PLUS exp .
    RBRACKET        reduce using rule 44 (exp -> term PLUS exp .)
    NEQ             reduce using rule 44 (exp -> term PLUS exp .)
    EQ              reduce using rule 44 (exp -> term PLUS exp .)
    LTE             reduce using rule 44 (exp -> term PLUS exp .)
    GTE             reduce using rule 44 (exp -> term PLUS exp .)
    LT              reduce using rule 44 (exp -> term PLUS exp .)
    GT              reduce using rule 44 (exp -> term PLUS exp .)
    OR              reduce using rule 44 (exp -> term PLUS exp .)
    AND             reduce using rule 44 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 44 (exp -> term PLUS exp .)
    COMMA           reduce using rule 44 (exp -> term PLUS exp .)
    SEMICOLON       reduce using rule 44 (exp -> term PLUS exp .)
    TO              reduce using rule 44 (exp -> term PLUS exp .)
    BY              reduce using rule 44 (exp -> term PLUS exp .)
    DO              reduce using rule 44 (exp -> term PLUS exp .)


state 99

    (46) term -> factor DIVIDE term .
    MINUS           reduce using rule 46 (term -> factor DIVIDE term .)
    PLUS            reduce using rule 46 (term -> factor DIVIDE term .)
    RBRACKET        reduce using rule 46 (term -> factor DIVIDE term .)
    NEQ             reduce using rule 46 (term -> factor DIVIDE term .)
    EQ              reduce using rule 46 (term -> factor DIVIDE term .)
    LTE             reduce using rule 46 (term -> factor DIVIDE term .)
    GTE             reduce using rule 46 (term -> factor DIVIDE term .)
    LT              reduce using rule 46 (term -> factor DIVIDE term .)
    GT              reduce using rule 46 (term -> factor DIVIDE term .)
    OR              reduce using rule 46 (term -> factor DIVIDE term .)
    AND             reduce using rule 46 (term -> factor DIVIDE term .)
    RPAREN          reduce using rule 46 (term -> factor DIVIDE term .)
    COMMA           reduce using rule 46 (term -> factor DIVIDE term .)
    SEMICOLON       reduce using rule 46 (term -> factor DIVIDE term .)
    TO              reduce using rule 46 (term -> factor DIVIDE term .)
    BY              reduce using rule 46 (term -> factor DIVIDE term .)
    DO              reduce using rule 46 (term -> factor DIVIDE term .)


state 100

    (47) term -> factor TIMES term .
    MINUS           reduce using rule 47 (term -> factor TIMES term .)
    PLUS            reduce using rule 47 (term -> factor TIMES term .)
    RBRACKET        reduce using rule 47 (term -> factor TIMES term .)
    NEQ             reduce using rule 47 (term -> factor TIMES term .)
    EQ              reduce using rule 47 (term -> factor TIMES term .)
    LTE             reduce using rule 47 (term -> factor TIMES term .)
    GTE             reduce using rule 47 (term -> factor TIMES term .)
    LT              reduce using rule 47 (term -> factor TIMES term .)
    GT              reduce using rule 47 (term -> factor TIMES term .)
    OR              reduce using rule 47 (term -> factor TIMES term .)
    AND             reduce using rule 47 (term -> factor TIMES term .)
    RPAREN          reduce using rule 47 (term -> factor TIMES term .)
    COMMA           reduce using rule 47 (term -> factor TIMES term .)
    SEMICOLON       reduce using rule 47 (term -> factor TIMES term .)
    TO              reduce using rule 47 (term -> factor TIMES term .)
    BY              reduce using rule 47 (term -> factor TIMES term .)
    DO              reduce using rule 47 (term -> factor TIMES term .)


state 101

    (49) factor -> LPAREN super_exp RPAREN .
    DIVIDE          reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    TIMES           reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    MINUS           reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    PLUS            reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    RBRACKET        reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    NEQ             reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    EQ              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    LTE             reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    GTE             reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    LT              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    GT              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    OR              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    AND             reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    RPAREN          reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    COMMA           reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    SEMICOLON       reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    TO              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    BY              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)
    DO              reduce using rule 49 (factor -> LPAREN super_exp RPAREN .)


state 102

    (32) super_exp -> expression OR . super_exp
    (32) super_exp -> . expression OR super_exp
    (33) super_exp -> . expression AND super_exp
    (34) super_exp -> . expression
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    expression                     shift and go to state 79
    super_exp                      shift and go to state 125
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 103

    (33) super_exp -> expression AND . super_exp
    (32) super_exp -> . expression OR super_exp
    (33) super_exp -> . expression AND super_exp
    (34) super_exp -> . expression
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    expression                     shift and go to state 79
    super_exp                      shift and go to state 126
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 104

    (35) expression -> exp relation . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    exp                            shift and go to state 127
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 105

    (37) relation -> NEQ .
    LPAREN          reduce using rule 37 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 37 (relation -> NEQ .)
    CTEINT          reduce using rule 37 (relation -> NEQ .)
    ID              reduce using rule 37 (relation -> NEQ .)


state 106

    (38) relation -> EQ .
    LPAREN          reduce using rule 38 (relation -> EQ .)
    CTEFLOAT        reduce using rule 38 (relation -> EQ .)
    CTEINT          reduce using rule 38 (relation -> EQ .)
    ID              reduce using rule 38 (relation -> EQ .)


state 107

    (39) relation -> LTE .
    LPAREN          reduce using rule 39 (relation -> LTE .)
    CTEFLOAT        reduce using rule 39 (relation -> LTE .)
    CTEINT          reduce using rule 39 (relation -> LTE .)
    ID              reduce using rule 39 (relation -> LTE .)


state 108

    (40) relation -> GTE .
    LPAREN          reduce using rule 40 (relation -> GTE .)
    CTEFLOAT        reduce using rule 40 (relation -> GTE .)
    CTEINT          reduce using rule 40 (relation -> GTE .)
    ID              reduce using rule 40 (relation -> GTE .)


state 109

    (41) relation -> LT .
    LPAREN          reduce using rule 41 (relation -> LT .)
    CTEFLOAT        reduce using rule 41 (relation -> LT .)
    CTEINT          reduce using rule 41 (relation -> LT .)
    ID              reduce using rule 41 (relation -> LT .)


state 110

    (42) relation -> GT .
    LPAREN          reduce using rule 42 (relation -> GT .)
    CTEFLOAT        reduce using rule 42 (relation -> GT .)
    CTEINT          reduce using rule 42 (relation -> GT .)
    ID              reduce using rule 42 (relation -> GT .)


state 111

    (26) params -> type ID . COMMA params
    (27) params -> type ID .
    COMMA           shift and go to state 128
    RPAREN          reduce using rule 27 (params -> type ID .)


state 112

    (24) typefunc -> type ID changecontext LPAREN params RPAREN . returnblock
    (8) returnblock -> . LCURLY blockcontent RETURN factor SEMICOLON RCURLY
    LCURLY          shift and go to state 130

    returnblock                    shift and go to state 129

state 113

    (23) voidfunc -> VOID ID changecontext LPAREN params RPAREN . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 131

state 114

    (56) assignment -> ID ASSIGN expression . SEMICOLON
    SEMICOLON       shift and go to state 132


state 115

    (53) forloop -> FROM var ASSIGN . expression TO expression BY expression DO block
    (54) forloop -> FROM var ASSIGN . expression TO expression DO block
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    var                            shift and go to state 50
    expression                     shift and go to state 133
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49

state 116

    (55) whileloop -> WHILE LPAREN expression . RPAREN block
    RPAREN          shift and go to state 134


state 117

    (57) read -> INPUT LPAREN decvar . RPAREN SEMICOLON
    RPAREN          shift and go to state 135


state 118

    (58) write -> PRINT LPAREN writevalues . RPAREN SEMICOLON
    RPAREN          shift and go to state 136


state 119

    (59) writevalues -> CTESTRING . COMMA writevalues
    (61) writevalues -> CTESTRING .
    COMMA           shift and go to state 137
    RPAREN          reduce using rule 61 (writevalues -> CTESTRING .)


state 120

    (60) writevalues -> super_exp . COMMA writevalues
    (62) writevalues -> super_exp .
    COMMA           shift and go to state 138
    RPAREN          reduce using rule 62 (writevalues -> super_exp .)


state 121

    (63) condition -> IF LPAREN expression . RPAREN block ELSE block
    (64) condition -> IF LPAREN expression . RPAREN block
    RPAREN          shift and go to state 139


state 122

    (28) call -> ID LPAREN callvalues RPAREN .
    DIVIDE          reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    RBRACKET        reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    ID              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    VARS            reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    FROM            reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    IF              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    EQ              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    LTE             reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    GTE             reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    LT              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    GT              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    OR              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    AND             reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    RETURN          reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    TO              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    BY              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)
    DO              reduce using rule 28 (call -> ID LPAREN callvalues RPAREN .)


state 123

    (30) callvalues -> exp COMMA . callvalues
    (29) callvalues -> . empty
    (30) callvalues -> . exp COMMA callvalues
    (31) callvalues -> . exp
    (79) empty -> .
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    RPAREN          reduce using rule 79 (empty -> .)
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    exp                            shift and go to state 95
    callvalues                     shift and go to state 140
    empty                          shift and go to state 94
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 124

    (16) var -> ID LBRACKET exp RBRACKET LBRACKET exp . RBRACKET
    RBRACKET        shift and go to state 141


state 125

    (32) super_exp -> expression OR super_exp .
    RPAREN          reduce using rule 32 (super_exp -> expression OR super_exp .)
    COMMA           reduce using rule 32 (super_exp -> expression OR super_exp .)


state 126

    (33) super_exp -> expression AND super_exp .
    RPAREN          reduce using rule 33 (super_exp -> expression AND super_exp .)
    COMMA           reduce using rule 33 (super_exp -> expression AND super_exp .)


state 127

    (35) expression -> exp relation exp .
    OR              reduce using rule 35 (expression -> exp relation exp .)
    AND             reduce using rule 35 (expression -> exp relation exp .)
    RPAREN          reduce using rule 35 (expression -> exp relation exp .)
    SEMICOLON       reduce using rule 35 (expression -> exp relation exp .)
    COMMA           reduce using rule 35 (expression -> exp relation exp .)
    TO              reduce using rule 35 (expression -> exp relation exp .)
    BY              reduce using rule 35 (expression -> exp relation exp .)
    DO              reduce using rule 35 (expression -> exp relation exp .)


state 128

    (26) params -> type ID COMMA . params
    (25) params -> . empty
    (26) params -> . type ID COMMA params
    (27) params -> . type ID
    (79) empty -> .
    (67) type -> . FLOAT
    (68) type -> . INT
    RPAREN          reduce using rule 79 (empty -> .)
    FLOAT           shift and go to state 18
    INT             shift and go to state 19

    type                           shift and go to state 81
    params                         shift and go to state 142
    empty                          shift and go to state 83

state 129

    (24) typefunc -> type ID changecontext LPAREN params RPAREN returnblock .
    FUNC            reduce using rule 24 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)
    MAIN            reduce using rule 24 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)


state 130

    (8) returnblock -> LCURLY . blockcontent RETURN factor SEMICOLON RCURLY
    (9) blockcontent -> . empty
    (10) blockcontent -> . statute blockcontent
    (79) empty -> .
    (69) statute -> . call
    (70) statute -> . decvars
    (71) statute -> . forloop
    (72) statute -> . whileloop
    (73) statute -> . read
    (74) statute -> . write
    (75) statute -> . condition
    (76) statute -> . assignment
    (28) call -> . ID LPAREN callvalues RPAREN
    (11) decvars -> . VARS decvar_line
    (53) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (54) forloop -> . FROM var ASSIGN expression TO expression DO block
    (55) whileloop -> . WHILE LPAREN expression RPAREN block
    (57) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (58) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (63) condition -> . IF LPAREN expression RPAREN block ELSE block
    (64) condition -> . IF LPAREN expression RPAREN block
    (56) assignment -> . ID ASSIGN expression SEMICOLON
    RETURN          reduce using rule 79 (empty -> .)
    ID              shift and go to state 66
    VARS            shift and go to state 10
    FROM            shift and go to state 67
    WHILE           shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71

    blockcontent                   shift and go to state 143
    empty                          shift and go to state 56
    statute                        shift and go to state 57
    call                           shift and go to state 58
    decvars                        shift and go to state 59
    forloop                        shift and go to state 60
    whileloop                      shift and go to state 61
    read                           shift and go to state 62
    write                          shift and go to state 63
    condition                      shift and go to state 64
    assignment                     shift and go to state 65

state 131

    (23) voidfunc -> VOID ID changecontext LPAREN params RPAREN block .
    FUNC            reduce using rule 23 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)
    MAIN            reduce using rule 23 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)


state 132

    (56) assignment -> ID ASSIGN expression SEMICOLON .
    ID              reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    VARS            reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    FROM            reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    INPUT           reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    RCURLY          reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 56 (assignment -> ID ASSIGN expression SEMICOLON .)


state 133

    (53) forloop -> FROM var ASSIGN expression . TO expression BY expression DO block
    (54) forloop -> FROM var ASSIGN expression . TO expression DO block
    TO              shift and go to state 144


state 134

    (55) whileloop -> WHILE LPAREN expression RPAREN . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 145

state 135

    (57) read -> INPUT LPAREN decvar RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 146


state 136

    (58) write -> PRINT LPAREN writevalues RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 147


state 137

    (59) writevalues -> CTESTRING COMMA . writevalues
    (59) writevalues -> . CTESTRING COMMA writevalues
    (60) writevalues -> . super_exp COMMA writevalues
    (61) writevalues -> . CTESTRING
    (62) writevalues -> . super_exp
    (32) super_exp -> . expression OR super_exp
    (33) super_exp -> . expression AND super_exp
    (34) super_exp -> . expression
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    CTESTRING       shift and go to state 119
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    writevalues                    shift and go to state 148
    super_exp                      shift and go to state 120
    expression                     shift and go to state 79
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 138

    (60) writevalues -> super_exp COMMA . writevalues
    (59) writevalues -> . CTESTRING COMMA writevalues
    (60) writevalues -> . super_exp COMMA writevalues
    (61) writevalues -> . CTESTRING
    (62) writevalues -> . super_exp
    (32) super_exp -> . expression OR super_exp
    (33) super_exp -> . expression AND super_exp
    (34) super_exp -> . expression
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    CTESTRING       shift and go to state 119
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    super_exp                      shift and go to state 120
    writevalues                    shift and go to state 149
    expression                     shift and go to state 79
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 139

    (63) condition -> IF LPAREN expression RPAREN . block ELSE block
    (64) condition -> IF LPAREN expression RPAREN . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 150

state 140

    (30) callvalues -> exp COMMA callvalues .
    RPAREN          reduce using rule 30 (callvalues -> exp COMMA callvalues .)


state 141

    (16) var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .
    COMMA           reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    NEQ             reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    EQ              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LTE             reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GTE             reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LT              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GT              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    OR              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    AND             reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    ASSIGN          reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    TO              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    BY              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DO              reduce using rule 16 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)


state 142

    (26) params -> type ID COMMA params .
    RPAREN          reduce using rule 26 (params -> type ID COMMA params .)


state 143

    (8) returnblock -> LCURLY blockcontent . RETURN factor SEMICOLON RCURLY
    RETURN          shift and go to state 151


state 144

    (53) forloop -> FROM var ASSIGN expression TO . expression BY expression DO block
    (54) forloop -> FROM var ASSIGN expression TO . expression DO block
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    var                            shift and go to state 50
    expression                     shift and go to state 152
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49

state 145

    (55) whileloop -> WHILE LPAREN expression RPAREN block .
    ID              reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    VARS            reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    FROM            reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    WHILE           reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    INPUT           reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    PRINT           reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    IF              reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RETURN          reduce using rule 55 (whileloop -> WHILE LPAREN expression RPAREN block .)


state 146

    (57) read -> INPUT LPAREN decvar RPAREN SEMICOLON .
    ID              reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    VARS            reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    FROM            reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    WHILE           reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    INPUT           reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    PRINT           reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    IF              reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RCURLY          reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RETURN          reduce using rule 57 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)


state 147

    (58) write -> PRINT LPAREN writevalues RPAREN SEMICOLON .
    ID              reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    VARS            reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    FROM            reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    WHILE           reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    INPUT           reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    PRINT           reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    IF              reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RCURLY          reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RETURN          reduce using rule 58 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)


state 148

    (59) writevalues -> CTESTRING COMMA writevalues .
    RPAREN          reduce using rule 59 (writevalues -> CTESTRING COMMA writevalues .)


state 149

    (60) writevalues -> super_exp COMMA writevalues .
    RPAREN          reduce using rule 60 (writevalues -> super_exp COMMA writevalues .)


state 150

    (63) condition -> IF LPAREN expression RPAREN block . ELSE block
    (64) condition -> IF LPAREN expression RPAREN block .
    ELSE            shift and go to state 153
    ID              reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    VARS            reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    FROM            reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    WHILE           reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    INPUT           reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    PRINT           reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    IF              reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)
    RETURN          reduce using rule 64 (condition -> IF LPAREN expression RPAREN block .)


state 151

    (8) returnblock -> LCURLY blockcontent RETURN . factor SEMICOLON RCURLY
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    factor                         shift and go to state 154
    varcte                         shift and go to state 48
    call                           shift and go to state 49
    var                            shift and go to state 50

state 152

    (53) forloop -> FROM var ASSIGN expression TO expression . BY expression DO block
    (54) forloop -> FROM var ASSIGN expression TO expression . DO block
    BY              shift and go to state 155
    DO              shift and go to state 156


state 153

    (63) condition -> IF LPAREN expression RPAREN block ELSE . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 157

state 154

    (8) returnblock -> LCURLY blockcontent RETURN factor . SEMICOLON RCURLY
    SEMICOLON       shift and go to state 158


state 155

    (53) forloop -> FROM var ASSIGN expression TO expression BY . expression DO block
    (35) expression -> . exp relation exp
    (36) expression -> . exp
    (43) exp -> . term MINUS exp
    (44) exp -> . term PLUS exp
    (45) exp -> . term
    (46) term -> . factor DIVIDE term
    (47) term -> . factor TIMES term
    (48) term -> . factor
    (49) factor -> . LPAREN super_exp RPAREN
    (50) factor -> . varcte
    (51) factor -> . call
    (52) factor -> . var
    (65) varcte -> . CTEFLOAT
    (66) varcte -> . CTEINT
    (28) call -> . ID LPAREN callvalues RPAREN
    (16) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (17) var -> . ID LBRACKET exp RBRACKET
    (18) var -> . ID
    LPAREN          shift and go to state 47
    CTEFLOAT        shift and go to state 51
    CTEINT          shift and go to state 52
    ID              shift and go to state 43

    var                            shift and go to state 50
    expression                     shift and go to state 159
    exp                            shift and go to state 80
    term                           shift and go to state 45
    factor                         shift and go to state 46
    varcte                         shift and go to state 48
    call                           shift and go to state 49

state 156

    (54) forloop -> FROM var ASSIGN expression TO expression DO . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 160

state 157

    (63) condition -> IF LPAREN expression RPAREN block ELSE block .
    ID              reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    VARS            reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    FROM            reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    WHILE           reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    INPUT           reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    PRINT           reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    IF              reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RCURLY          reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RETURN          reduce using rule 63 (condition -> IF LPAREN expression RPAREN block ELSE block .)


state 158

    (8) returnblock -> LCURLY blockcontent RETURN factor SEMICOLON . RCURLY
    RCURLY          shift and go to state 161


state 159

    (53) forloop -> FROM var ASSIGN expression TO expression BY expression . DO block
    DO              shift and go to state 162


state 160

    (54) forloop -> FROM var ASSIGN expression TO expression DO block .
    ID              reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    VARS            reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    FROM            reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    WHILE           reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    INPUT           reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    PRINT           reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    IF              reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RCURLY          reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RETURN          reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression DO block .)


state 161

    (8) returnblock -> LCURLY blockcontent RETURN factor SEMICOLON RCURLY .
    FUNC            reduce using rule 8 (returnblock -> LCURLY blockcontent RETURN factor SEMICOLON RCURLY .)
    MAIN            reduce using rule 8 (returnblock -> LCURLY blockcontent RETURN factor SEMICOLON RCURLY .)


state 162

    (53) forloop -> FROM var ASSIGN expression TO expression BY expression DO . block
    (7) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 40

    block                          shift and go to state 163

state 163

    (53) forloop -> FROM var ASSIGN expression TO expression BY expression DO block .
    ID              reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    VARS            reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    FROM            reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    WHILE           reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    INPUT           reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    PRINT           reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    IF              reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RCURLY          reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RETURN          reduce using rule 53 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
