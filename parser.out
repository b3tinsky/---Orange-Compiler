Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     declare -> decvars decfuncs main_block
Rule 3     main_block -> MAIN changecontext LPAREN RPAREN block
Rule 4     block -> LCURLY decvars blockcontent RCURLY
Rule 5     returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
Rule 6     blockcontent -> empty
Rule 7     blockcontent -> statute blockcontent
Rule 8     decvars -> empty
Rule 9     decvars -> VARS decvar_line
Rule 10    decvar_line -> type decvar SEMICOLON decvar_line
Rule 11    decvar_line -> type decvar SEMICOLON
Rule 12    decvar -> var COMMA decvar
Rule 13    decvar -> var
Rule 14    var -> FLOAT
Rule 15    var -> INT
Rule 16    var -> ELSE
Rule 17    var -> IF
Rule 18    var -> PRINT
Rule 19    var -> INPUT
Rule 20    var -> WHILE
Rule 21    var -> DO
Rule 22    var -> BY
Rule 23    var -> TO
Rule 24    var -> FROM
Rule 25    var -> VOID
Rule 26    var -> RETURN
Rule 27    var -> FUNC
Rule 28    var -> MAIN
Rule 29    var -> VARS
Rule 30    var -> PROGRAM
Rule 31    var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
Rule 32    var -> ID LBRACKET CTEINT RBRACKET
Rule 33    var -> ID
Rule 34    decfuncs -> empty
Rule 35    decfuncs -> func decfuncs
Rule 36    func -> FUNC typefunc
Rule 37    func -> FUNC voidfunc
Rule 38    voidfunc -> VOID ID changecontext LPAREN params RPAREN block
Rule 39    typefunc -> type ID changecontext LPAREN params RPAREN returnblock
Rule 40    params -> empty
Rule 41    params -> type ID COMMA params
Rule 42    params -> type ID
Rule 43    call -> ID LPAREN callvalues RPAREN
Rule 44    callvalues -> empty
Rule 45    callvalues -> exp COMMA callvalues
Rule 46    callvalues -> exp
Rule 47    super_exp -> expression OR super_exp
Rule 48    super_exp -> expression AND super_exp
Rule 49    super_exp -> expression
Rule 50    expression -> exp relation exp
Rule 51    expression -> exp
Rule 52    relation -> NEQ
Rule 53    relation -> EQ
Rule 54    relation -> LTE
Rule 55    relation -> GTE
Rule 56    relation -> LT
Rule 57    relation -> GT
Rule 58    exp -> term MINUS exp
Rule 59    exp -> term PLUS exp
Rule 60    exp -> term
Rule 61    term -> factor DIVIDE term
Rule 62    term -> factor TIMES term
Rule 63    term -> factor
Rule 64    factor -> LPAREN super_exp RPAREN
Rule 65    factor -> varcte
Rule 66    factor -> call
Rule 67    factor -> var
Rule 68    forloop -> FROM var ASSIGN expression TO expression BY expression DO block
Rule 69    forloop -> FROM var ASSIGN expression TO expression DO block
Rule 70    whileloop -> WHILE LPAREN expression RPAREN block
Rule 71    assignment -> ID ASSIGN expression SEMICOLON
Rule 72    read -> INPUT LPAREN decvar RPAREN SEMICOLON
Rule 73    write -> PRINT LPAREN writevalues RPAREN SEMICOLON
Rule 74    writevalues -> CTESTRING COMMA writevalues
Rule 75    writevalues -> super_exp COMMA writevalues
Rule 76    writevalues -> CTESTRING
Rule 77    writevalues -> super_exp
Rule 78    condition -> IF LPAREN expression RPAREN block ELSE block
Rule 79    condition -> IF LPAREN expression RPAREN block
Rule 80    varcte -> CTEFLOAT
Rule 81    varcte -> CTEINT
Rule 82    type -> FLOAT
Rule 83    type -> INT
Rule 84    statute -> call
Rule 85    statute -> forloop
Rule 86    statute -> whileloop
Rule 87    statute -> read
Rule 88    statute -> write
Rule 89    statute -> condition
Rule 90    statute -> assignment
Rule 91    changecontext -> <empty>
Rule 92    saveprogramname -> <empty>
Rule 93    empty -> <empty>

Terminals, with rules where they appear:

AND                  : 48
ASSIGN               : 68 69 71
BY                   : 22 68
COMMA                : 12 41 45 74 75
CTEFLOAT             : 80
CTEINT               : 31 31 32 81
CTESTRING            : 74 76
DIVIDE               : 61
DO                   : 21 68 69
ELSE                 : 16 78
EQ                   : 53
FLOAT                : 14 82
FROM                 : 24 68 69
FUNC                 : 27 36 37
GT                   : 57
GTE                  : 55
ID                   : 1 31 32 33 38 39 41 42 43 71
IF                   : 17 78 79
INPUT                : 19 72
INT                  : 15 83
LBRACKET             : 31 31 32
LCURLY               : 4 5
LPAREN               : 3 38 39 43 64 70 72 73 78 79
LT                   : 56
LTE                  : 54
MAIN                 : 3 28
MINUS                : 58
NEQ                  : 52
OR                   : 47
PLUS                 : 59
PRINT                : 18 73
PROGRAM              : 1 30
RBRACKET             : 31 31 32
RCURLY               : 4 5
RETURN               : 5 26
RPAREN               : 3 38 39 43 64 70 72 73 78 79
SEMICOLON            : 5 10 11 71 72 73
TIMES                : 62
TO                   : 23 68 69
VARS                 : 9 29
VOID                 : 25 38
WHILE                : 20 70
error                : 

Nonterminals, with rules where they appear:

assignment           : 90
block                : 3 38 68 69 70 78 78 79
blockcontent         : 4 5 7
call                 : 66 84
callvalues           : 43 45
changecontext        : 3 38 39
condition            : 89
decfuncs             : 2 35
declare              : 1
decvar               : 10 11 12 72
decvar_line          : 9 10
decvars              : 2 4 5
empty                : 6 8 34 40 44
exp                  : 5 45 46 50 50 51 58 59
expression           : 47 48 49 68 68 68 69 69 70 71 78 79
factor               : 61 62 63
forloop              : 85
func                 : 35
main_block           : 2
params               : 38 39 41
program              : 0
read                 : 87
relation             : 50
returnblock          : 39
saveprogramname      : 1
statute              : 7
super_exp            : 47 48 64 75 77
term                 : 58 59 60 61 62
type                 : 10 11 39 41 42
typefunc             : 36
var                  : 12 13 67 68 69
varcte               : 65
voidfunc             : 37
whileloop            : 86
write                : 88
writevalues          : 73 74 75


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (92) saveprogramname -> .
    VARS            reduce using rule 92 (saveprogramname -> .)
    FUNC            reduce using rule 92 (saveprogramname -> .)
    MAIN            reduce using rule 92 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (2) declare -> . decvars decfuncs main_block
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (93) empty -> .
    VARS            shift and go to state 8
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)

    declare                        shift and go to state 5
    decvars                        shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (2) declare -> decvars . decfuncs main_block
    (34) decfuncs -> . empty
    (35) decfuncs -> . func decfuncs
    (93) empty -> .
    (36) func -> . FUNC typefunc
    (37) func -> . FUNC voidfunc
    MAIN            reduce using rule 93 (empty -> .)
    FUNC            shift and go to state 12

    decfuncs                       shift and go to state 9
    empty                          shift and go to state 10
    func                           shift and go to state 11

state 7

    (8) decvars -> empty .
    FUNC            reduce using rule 8 (decvars -> empty .)
    MAIN            reduce using rule 8 (decvars -> empty .)
    ID              reduce using rule 8 (decvars -> empty .)
    FROM            reduce using rule 8 (decvars -> empty .)
    WHILE           reduce using rule 8 (decvars -> empty .)
    INPUT           reduce using rule 8 (decvars -> empty .)
    PRINT           reduce using rule 8 (decvars -> empty .)
    IF              reduce using rule 8 (decvars -> empty .)
    RCURLY          reduce using rule 8 (decvars -> empty .)
    RETURN          reduce using rule 8 (decvars -> empty .)


state 8

    (9) decvars -> VARS . decvar_line
    (10) decvar_line -> . type decvar SEMICOLON decvar_line
    (11) decvar_line -> . type decvar SEMICOLON
    (82) type -> . FLOAT
    (83) type -> . INT
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    decvar_line                    shift and go to state 13
    type                           shift and go to state 14

state 9

    (2) declare -> decvars decfuncs . main_block
    (3) main_block -> . MAIN changecontext LPAREN RPAREN block
    MAIN            shift and go to state 18

    main_block                     shift and go to state 17

state 10

    (34) decfuncs -> empty .
    MAIN            reduce using rule 34 (decfuncs -> empty .)


state 11

    (35) decfuncs -> func . decfuncs
    (34) decfuncs -> . empty
    (35) decfuncs -> . func decfuncs
    (93) empty -> .
    (36) func -> . FUNC typefunc
    (37) func -> . FUNC voidfunc
    MAIN            reduce using rule 93 (empty -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 11
    decfuncs                       shift and go to state 19
    empty                          shift and go to state 10

state 12

    (36) func -> FUNC . typefunc
    (37) func -> FUNC . voidfunc
    (39) typefunc -> . type ID changecontext LPAREN params RPAREN returnblock
    (38) voidfunc -> . VOID ID changecontext LPAREN params RPAREN block
    (82) type -> . FLOAT
    (83) type -> . INT
    VOID            shift and go to state 23
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    typefunc                       shift and go to state 20
    voidfunc                       shift and go to state 21
    type                           shift and go to state 22

state 13

    (9) decvars -> VARS decvar_line .
    FUNC            reduce using rule 9 (decvars -> VARS decvar_line .)
    MAIN            reduce using rule 9 (decvars -> VARS decvar_line .)
    ID              reduce using rule 9 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 9 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 9 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 9 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 9 (decvars -> VARS decvar_line .)
    IF              reduce using rule 9 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 9 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 9 (decvars -> VARS decvar_line .)


state 14

    (10) decvar_line -> type . decvar SEMICOLON decvar_line
    (11) decvar_line -> type . decvar SEMICOLON
    (12) decvar -> . var COMMA decvar
    (13) decvar -> . var
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    decvar                         shift and go to state 24
    var                            shift and go to state 25

state 15

    (82) type -> FLOAT .
    FLOAT           reduce using rule 82 (type -> FLOAT .)
    INT             reduce using rule 82 (type -> FLOAT .)
    ELSE            reduce using rule 82 (type -> FLOAT .)
    IF              reduce using rule 82 (type -> FLOAT .)
    PRINT           reduce using rule 82 (type -> FLOAT .)
    INPUT           reduce using rule 82 (type -> FLOAT .)
    WHILE           reduce using rule 82 (type -> FLOAT .)
    DO              reduce using rule 82 (type -> FLOAT .)
    BY              reduce using rule 82 (type -> FLOAT .)
    TO              reduce using rule 82 (type -> FLOAT .)
    FROM            reduce using rule 82 (type -> FLOAT .)
    VOID            reduce using rule 82 (type -> FLOAT .)
    RETURN          reduce using rule 82 (type -> FLOAT .)
    FUNC            reduce using rule 82 (type -> FLOAT .)
    MAIN            reduce using rule 82 (type -> FLOAT .)
    VARS            reduce using rule 82 (type -> FLOAT .)
    PROGRAM         reduce using rule 82 (type -> FLOAT .)
    ID              reduce using rule 82 (type -> FLOAT .)


state 16

    (83) type -> INT .
    FLOAT           reduce using rule 83 (type -> INT .)
    INT             reduce using rule 83 (type -> INT .)
    ELSE            reduce using rule 83 (type -> INT .)
    IF              reduce using rule 83 (type -> INT .)
    PRINT           reduce using rule 83 (type -> INT .)
    INPUT           reduce using rule 83 (type -> INT .)
    WHILE           reduce using rule 83 (type -> INT .)
    DO              reduce using rule 83 (type -> INT .)
    BY              reduce using rule 83 (type -> INT .)
    TO              reduce using rule 83 (type -> INT .)
    FROM            reduce using rule 83 (type -> INT .)
    VOID            reduce using rule 83 (type -> INT .)
    RETURN          reduce using rule 83 (type -> INT .)
    FUNC            reduce using rule 83 (type -> INT .)
    MAIN            reduce using rule 83 (type -> INT .)
    VARS            reduce using rule 83 (type -> INT .)
    PROGRAM         reduce using rule 83 (type -> INT .)
    ID              reduce using rule 83 (type -> INT .)


state 17

    (2) declare -> decvars decfuncs main_block .
    $end            reduce using rule 2 (declare -> decvars decfuncs main_block .)


state 18

    (3) main_block -> MAIN . changecontext LPAREN RPAREN block
    (91) changecontext -> .
    LPAREN          reduce using rule 91 (changecontext -> .)

    changecontext                  shift and go to state 44

state 19

    (35) decfuncs -> func decfuncs .
    MAIN            reduce using rule 35 (decfuncs -> func decfuncs .)


state 20

    (36) func -> FUNC typefunc .
    FUNC            reduce using rule 36 (func -> FUNC typefunc .)
    MAIN            reduce using rule 36 (func -> FUNC typefunc .)


state 21

    (37) func -> FUNC voidfunc .
    FUNC            reduce using rule 37 (func -> FUNC voidfunc .)
    MAIN            reduce using rule 37 (func -> FUNC voidfunc .)


state 22

    (39) typefunc -> type . ID changecontext LPAREN params RPAREN returnblock
    ID              shift and go to state 45


state 23

    (38) voidfunc -> VOID . ID changecontext LPAREN params RPAREN block
    ID              shift and go to state 46


state 24

    (10) decvar_line -> type decvar . SEMICOLON decvar_line
    (11) decvar_line -> type decvar . SEMICOLON
    SEMICOLON       shift and go to state 47


state 25

    (12) decvar -> var . COMMA decvar
    (13) decvar -> var .
    COMMA           shift and go to state 48
    SEMICOLON       reduce using rule 13 (decvar -> var .)
    RPAREN          reduce using rule 13 (decvar -> var .)


state 26

    (14) var -> FLOAT .
    COMMA           reduce using rule 14 (var -> FLOAT .)
    SEMICOLON       reduce using rule 14 (var -> FLOAT .)
    RPAREN          reduce using rule 14 (var -> FLOAT .)
    ASSIGN          reduce using rule 14 (var -> FLOAT .)
    DIVIDE          reduce using rule 14 (var -> FLOAT .)
    TIMES           reduce using rule 14 (var -> FLOAT .)
    MINUS           reduce using rule 14 (var -> FLOAT .)
    PLUS            reduce using rule 14 (var -> FLOAT .)
    NEQ             reduce using rule 14 (var -> FLOAT .)
    EQ              reduce using rule 14 (var -> FLOAT .)
    LTE             reduce using rule 14 (var -> FLOAT .)
    GTE             reduce using rule 14 (var -> FLOAT .)
    LT              reduce using rule 14 (var -> FLOAT .)
    GT              reduce using rule 14 (var -> FLOAT .)
    OR              reduce using rule 14 (var -> FLOAT .)
    AND             reduce using rule 14 (var -> FLOAT .)
    TO              reduce using rule 14 (var -> FLOAT .)
    BY              reduce using rule 14 (var -> FLOAT .)
    DO              reduce using rule 14 (var -> FLOAT .)


state 27

    (15) var -> INT .
    COMMA           reduce using rule 15 (var -> INT .)
    SEMICOLON       reduce using rule 15 (var -> INT .)
    RPAREN          reduce using rule 15 (var -> INT .)
    ASSIGN          reduce using rule 15 (var -> INT .)
    DIVIDE          reduce using rule 15 (var -> INT .)
    TIMES           reduce using rule 15 (var -> INT .)
    MINUS           reduce using rule 15 (var -> INT .)
    PLUS            reduce using rule 15 (var -> INT .)
    NEQ             reduce using rule 15 (var -> INT .)
    EQ              reduce using rule 15 (var -> INT .)
    LTE             reduce using rule 15 (var -> INT .)
    GTE             reduce using rule 15 (var -> INT .)
    LT              reduce using rule 15 (var -> INT .)
    GT              reduce using rule 15 (var -> INT .)
    OR              reduce using rule 15 (var -> INT .)
    AND             reduce using rule 15 (var -> INT .)
    TO              reduce using rule 15 (var -> INT .)
    BY              reduce using rule 15 (var -> INT .)
    DO              reduce using rule 15 (var -> INT .)


state 28

    (16) var -> ELSE .
    COMMA           reduce using rule 16 (var -> ELSE .)
    SEMICOLON       reduce using rule 16 (var -> ELSE .)
    RPAREN          reduce using rule 16 (var -> ELSE .)
    ASSIGN          reduce using rule 16 (var -> ELSE .)
    DIVIDE          reduce using rule 16 (var -> ELSE .)
    TIMES           reduce using rule 16 (var -> ELSE .)
    MINUS           reduce using rule 16 (var -> ELSE .)
    PLUS            reduce using rule 16 (var -> ELSE .)
    NEQ             reduce using rule 16 (var -> ELSE .)
    EQ              reduce using rule 16 (var -> ELSE .)
    LTE             reduce using rule 16 (var -> ELSE .)
    GTE             reduce using rule 16 (var -> ELSE .)
    LT              reduce using rule 16 (var -> ELSE .)
    GT              reduce using rule 16 (var -> ELSE .)
    OR              reduce using rule 16 (var -> ELSE .)
    AND             reduce using rule 16 (var -> ELSE .)
    TO              reduce using rule 16 (var -> ELSE .)
    BY              reduce using rule 16 (var -> ELSE .)
    DO              reduce using rule 16 (var -> ELSE .)


state 29

    (17) var -> IF .
    COMMA           reduce using rule 17 (var -> IF .)
    SEMICOLON       reduce using rule 17 (var -> IF .)
    RPAREN          reduce using rule 17 (var -> IF .)
    ASSIGN          reduce using rule 17 (var -> IF .)
    DIVIDE          reduce using rule 17 (var -> IF .)
    TIMES           reduce using rule 17 (var -> IF .)
    MINUS           reduce using rule 17 (var -> IF .)
    PLUS            reduce using rule 17 (var -> IF .)
    NEQ             reduce using rule 17 (var -> IF .)
    EQ              reduce using rule 17 (var -> IF .)
    LTE             reduce using rule 17 (var -> IF .)
    GTE             reduce using rule 17 (var -> IF .)
    LT              reduce using rule 17 (var -> IF .)
    GT              reduce using rule 17 (var -> IF .)
    OR              reduce using rule 17 (var -> IF .)
    AND             reduce using rule 17 (var -> IF .)
    TO              reduce using rule 17 (var -> IF .)
    BY              reduce using rule 17 (var -> IF .)
    DO              reduce using rule 17 (var -> IF .)


state 30

    (18) var -> PRINT .
    COMMA           reduce using rule 18 (var -> PRINT .)
    SEMICOLON       reduce using rule 18 (var -> PRINT .)
    RPAREN          reduce using rule 18 (var -> PRINT .)
    ASSIGN          reduce using rule 18 (var -> PRINT .)
    DIVIDE          reduce using rule 18 (var -> PRINT .)
    TIMES           reduce using rule 18 (var -> PRINT .)
    MINUS           reduce using rule 18 (var -> PRINT .)
    PLUS            reduce using rule 18 (var -> PRINT .)
    NEQ             reduce using rule 18 (var -> PRINT .)
    EQ              reduce using rule 18 (var -> PRINT .)
    LTE             reduce using rule 18 (var -> PRINT .)
    GTE             reduce using rule 18 (var -> PRINT .)
    LT              reduce using rule 18 (var -> PRINT .)
    GT              reduce using rule 18 (var -> PRINT .)
    OR              reduce using rule 18 (var -> PRINT .)
    AND             reduce using rule 18 (var -> PRINT .)
    TO              reduce using rule 18 (var -> PRINT .)
    BY              reduce using rule 18 (var -> PRINT .)
    DO              reduce using rule 18 (var -> PRINT .)


state 31

    (19) var -> INPUT .
    COMMA           reduce using rule 19 (var -> INPUT .)
    SEMICOLON       reduce using rule 19 (var -> INPUT .)
    RPAREN          reduce using rule 19 (var -> INPUT .)
    ASSIGN          reduce using rule 19 (var -> INPUT .)
    DIVIDE          reduce using rule 19 (var -> INPUT .)
    TIMES           reduce using rule 19 (var -> INPUT .)
    MINUS           reduce using rule 19 (var -> INPUT .)
    PLUS            reduce using rule 19 (var -> INPUT .)
    NEQ             reduce using rule 19 (var -> INPUT .)
    EQ              reduce using rule 19 (var -> INPUT .)
    LTE             reduce using rule 19 (var -> INPUT .)
    GTE             reduce using rule 19 (var -> INPUT .)
    LT              reduce using rule 19 (var -> INPUT .)
    GT              reduce using rule 19 (var -> INPUT .)
    OR              reduce using rule 19 (var -> INPUT .)
    AND             reduce using rule 19 (var -> INPUT .)
    TO              reduce using rule 19 (var -> INPUT .)
    BY              reduce using rule 19 (var -> INPUT .)
    DO              reduce using rule 19 (var -> INPUT .)


state 32

    (20) var -> WHILE .
    COMMA           reduce using rule 20 (var -> WHILE .)
    SEMICOLON       reduce using rule 20 (var -> WHILE .)
    RPAREN          reduce using rule 20 (var -> WHILE .)
    ASSIGN          reduce using rule 20 (var -> WHILE .)
    DIVIDE          reduce using rule 20 (var -> WHILE .)
    TIMES           reduce using rule 20 (var -> WHILE .)
    MINUS           reduce using rule 20 (var -> WHILE .)
    PLUS            reduce using rule 20 (var -> WHILE .)
    NEQ             reduce using rule 20 (var -> WHILE .)
    EQ              reduce using rule 20 (var -> WHILE .)
    LTE             reduce using rule 20 (var -> WHILE .)
    GTE             reduce using rule 20 (var -> WHILE .)
    LT              reduce using rule 20 (var -> WHILE .)
    GT              reduce using rule 20 (var -> WHILE .)
    OR              reduce using rule 20 (var -> WHILE .)
    AND             reduce using rule 20 (var -> WHILE .)
    TO              reduce using rule 20 (var -> WHILE .)
    BY              reduce using rule 20 (var -> WHILE .)
    DO              reduce using rule 20 (var -> WHILE .)


state 33

    (21) var -> DO .
    COMMA           reduce using rule 21 (var -> DO .)
    SEMICOLON       reduce using rule 21 (var -> DO .)
    RPAREN          reduce using rule 21 (var -> DO .)
    ASSIGN          reduce using rule 21 (var -> DO .)
    DIVIDE          reduce using rule 21 (var -> DO .)
    TIMES           reduce using rule 21 (var -> DO .)
    MINUS           reduce using rule 21 (var -> DO .)
    PLUS            reduce using rule 21 (var -> DO .)
    NEQ             reduce using rule 21 (var -> DO .)
    EQ              reduce using rule 21 (var -> DO .)
    LTE             reduce using rule 21 (var -> DO .)
    GTE             reduce using rule 21 (var -> DO .)
    LT              reduce using rule 21 (var -> DO .)
    GT              reduce using rule 21 (var -> DO .)
    OR              reduce using rule 21 (var -> DO .)
    AND             reduce using rule 21 (var -> DO .)
    TO              reduce using rule 21 (var -> DO .)
    BY              reduce using rule 21 (var -> DO .)
    DO              reduce using rule 21 (var -> DO .)


state 34

    (22) var -> BY .
    COMMA           reduce using rule 22 (var -> BY .)
    SEMICOLON       reduce using rule 22 (var -> BY .)
    RPAREN          reduce using rule 22 (var -> BY .)
    ASSIGN          reduce using rule 22 (var -> BY .)
    DIVIDE          reduce using rule 22 (var -> BY .)
    TIMES           reduce using rule 22 (var -> BY .)
    MINUS           reduce using rule 22 (var -> BY .)
    PLUS            reduce using rule 22 (var -> BY .)
    NEQ             reduce using rule 22 (var -> BY .)
    EQ              reduce using rule 22 (var -> BY .)
    LTE             reduce using rule 22 (var -> BY .)
    GTE             reduce using rule 22 (var -> BY .)
    LT              reduce using rule 22 (var -> BY .)
    GT              reduce using rule 22 (var -> BY .)
    OR              reduce using rule 22 (var -> BY .)
    AND             reduce using rule 22 (var -> BY .)
    TO              reduce using rule 22 (var -> BY .)
    BY              reduce using rule 22 (var -> BY .)
    DO              reduce using rule 22 (var -> BY .)


state 35

    (23) var -> TO .
    COMMA           reduce using rule 23 (var -> TO .)
    SEMICOLON       reduce using rule 23 (var -> TO .)
    RPAREN          reduce using rule 23 (var -> TO .)
    ASSIGN          reduce using rule 23 (var -> TO .)
    DIVIDE          reduce using rule 23 (var -> TO .)
    TIMES           reduce using rule 23 (var -> TO .)
    MINUS           reduce using rule 23 (var -> TO .)
    PLUS            reduce using rule 23 (var -> TO .)
    NEQ             reduce using rule 23 (var -> TO .)
    EQ              reduce using rule 23 (var -> TO .)
    LTE             reduce using rule 23 (var -> TO .)
    GTE             reduce using rule 23 (var -> TO .)
    LT              reduce using rule 23 (var -> TO .)
    GT              reduce using rule 23 (var -> TO .)
    OR              reduce using rule 23 (var -> TO .)
    AND             reduce using rule 23 (var -> TO .)
    TO              reduce using rule 23 (var -> TO .)
    BY              reduce using rule 23 (var -> TO .)
    DO              reduce using rule 23 (var -> TO .)


state 36

    (24) var -> FROM .
    COMMA           reduce using rule 24 (var -> FROM .)
    SEMICOLON       reduce using rule 24 (var -> FROM .)
    RPAREN          reduce using rule 24 (var -> FROM .)
    ASSIGN          reduce using rule 24 (var -> FROM .)
    DIVIDE          reduce using rule 24 (var -> FROM .)
    TIMES           reduce using rule 24 (var -> FROM .)
    MINUS           reduce using rule 24 (var -> FROM .)
    PLUS            reduce using rule 24 (var -> FROM .)
    NEQ             reduce using rule 24 (var -> FROM .)
    EQ              reduce using rule 24 (var -> FROM .)
    LTE             reduce using rule 24 (var -> FROM .)
    GTE             reduce using rule 24 (var -> FROM .)
    LT              reduce using rule 24 (var -> FROM .)
    GT              reduce using rule 24 (var -> FROM .)
    OR              reduce using rule 24 (var -> FROM .)
    AND             reduce using rule 24 (var -> FROM .)
    TO              reduce using rule 24 (var -> FROM .)
    BY              reduce using rule 24 (var -> FROM .)
    DO              reduce using rule 24 (var -> FROM .)


state 37

    (25) var -> VOID .
    COMMA           reduce using rule 25 (var -> VOID .)
    SEMICOLON       reduce using rule 25 (var -> VOID .)
    RPAREN          reduce using rule 25 (var -> VOID .)
    ASSIGN          reduce using rule 25 (var -> VOID .)
    DIVIDE          reduce using rule 25 (var -> VOID .)
    TIMES           reduce using rule 25 (var -> VOID .)
    MINUS           reduce using rule 25 (var -> VOID .)
    PLUS            reduce using rule 25 (var -> VOID .)
    NEQ             reduce using rule 25 (var -> VOID .)
    EQ              reduce using rule 25 (var -> VOID .)
    LTE             reduce using rule 25 (var -> VOID .)
    GTE             reduce using rule 25 (var -> VOID .)
    LT              reduce using rule 25 (var -> VOID .)
    GT              reduce using rule 25 (var -> VOID .)
    OR              reduce using rule 25 (var -> VOID .)
    AND             reduce using rule 25 (var -> VOID .)
    TO              reduce using rule 25 (var -> VOID .)
    BY              reduce using rule 25 (var -> VOID .)
    DO              reduce using rule 25 (var -> VOID .)


state 38

    (26) var -> RETURN .
    COMMA           reduce using rule 26 (var -> RETURN .)
    SEMICOLON       reduce using rule 26 (var -> RETURN .)
    RPAREN          reduce using rule 26 (var -> RETURN .)
    ASSIGN          reduce using rule 26 (var -> RETURN .)
    DIVIDE          reduce using rule 26 (var -> RETURN .)
    TIMES           reduce using rule 26 (var -> RETURN .)
    MINUS           reduce using rule 26 (var -> RETURN .)
    PLUS            reduce using rule 26 (var -> RETURN .)
    NEQ             reduce using rule 26 (var -> RETURN .)
    EQ              reduce using rule 26 (var -> RETURN .)
    LTE             reduce using rule 26 (var -> RETURN .)
    GTE             reduce using rule 26 (var -> RETURN .)
    LT              reduce using rule 26 (var -> RETURN .)
    GT              reduce using rule 26 (var -> RETURN .)
    OR              reduce using rule 26 (var -> RETURN .)
    AND             reduce using rule 26 (var -> RETURN .)
    TO              reduce using rule 26 (var -> RETURN .)
    BY              reduce using rule 26 (var -> RETURN .)
    DO              reduce using rule 26 (var -> RETURN .)


state 39

    (27) var -> FUNC .
    COMMA           reduce using rule 27 (var -> FUNC .)
    SEMICOLON       reduce using rule 27 (var -> FUNC .)
    RPAREN          reduce using rule 27 (var -> FUNC .)
    ASSIGN          reduce using rule 27 (var -> FUNC .)
    DIVIDE          reduce using rule 27 (var -> FUNC .)
    TIMES           reduce using rule 27 (var -> FUNC .)
    MINUS           reduce using rule 27 (var -> FUNC .)
    PLUS            reduce using rule 27 (var -> FUNC .)
    NEQ             reduce using rule 27 (var -> FUNC .)
    EQ              reduce using rule 27 (var -> FUNC .)
    LTE             reduce using rule 27 (var -> FUNC .)
    GTE             reduce using rule 27 (var -> FUNC .)
    LT              reduce using rule 27 (var -> FUNC .)
    GT              reduce using rule 27 (var -> FUNC .)
    OR              reduce using rule 27 (var -> FUNC .)
    AND             reduce using rule 27 (var -> FUNC .)
    TO              reduce using rule 27 (var -> FUNC .)
    BY              reduce using rule 27 (var -> FUNC .)
    DO              reduce using rule 27 (var -> FUNC .)


state 40

    (28) var -> MAIN .
    COMMA           reduce using rule 28 (var -> MAIN .)
    SEMICOLON       reduce using rule 28 (var -> MAIN .)
    RPAREN          reduce using rule 28 (var -> MAIN .)
    ASSIGN          reduce using rule 28 (var -> MAIN .)
    DIVIDE          reduce using rule 28 (var -> MAIN .)
    TIMES           reduce using rule 28 (var -> MAIN .)
    MINUS           reduce using rule 28 (var -> MAIN .)
    PLUS            reduce using rule 28 (var -> MAIN .)
    NEQ             reduce using rule 28 (var -> MAIN .)
    EQ              reduce using rule 28 (var -> MAIN .)
    LTE             reduce using rule 28 (var -> MAIN .)
    GTE             reduce using rule 28 (var -> MAIN .)
    LT              reduce using rule 28 (var -> MAIN .)
    GT              reduce using rule 28 (var -> MAIN .)
    OR              reduce using rule 28 (var -> MAIN .)
    AND             reduce using rule 28 (var -> MAIN .)
    TO              reduce using rule 28 (var -> MAIN .)
    BY              reduce using rule 28 (var -> MAIN .)
    DO              reduce using rule 28 (var -> MAIN .)


state 41

    (29) var -> VARS .
    COMMA           reduce using rule 29 (var -> VARS .)
    SEMICOLON       reduce using rule 29 (var -> VARS .)
    RPAREN          reduce using rule 29 (var -> VARS .)
    ASSIGN          reduce using rule 29 (var -> VARS .)
    DIVIDE          reduce using rule 29 (var -> VARS .)
    TIMES           reduce using rule 29 (var -> VARS .)
    MINUS           reduce using rule 29 (var -> VARS .)
    PLUS            reduce using rule 29 (var -> VARS .)
    NEQ             reduce using rule 29 (var -> VARS .)
    EQ              reduce using rule 29 (var -> VARS .)
    LTE             reduce using rule 29 (var -> VARS .)
    GTE             reduce using rule 29 (var -> VARS .)
    LT              reduce using rule 29 (var -> VARS .)
    GT              reduce using rule 29 (var -> VARS .)
    OR              reduce using rule 29 (var -> VARS .)
    AND             reduce using rule 29 (var -> VARS .)
    TO              reduce using rule 29 (var -> VARS .)
    BY              reduce using rule 29 (var -> VARS .)
    DO              reduce using rule 29 (var -> VARS .)


state 42

    (30) var -> PROGRAM .
    COMMA           reduce using rule 30 (var -> PROGRAM .)
    SEMICOLON       reduce using rule 30 (var -> PROGRAM .)
    RPAREN          reduce using rule 30 (var -> PROGRAM .)
    ASSIGN          reduce using rule 30 (var -> PROGRAM .)
    DIVIDE          reduce using rule 30 (var -> PROGRAM .)
    TIMES           reduce using rule 30 (var -> PROGRAM .)
    MINUS           reduce using rule 30 (var -> PROGRAM .)
    PLUS            reduce using rule 30 (var -> PROGRAM .)
    NEQ             reduce using rule 30 (var -> PROGRAM .)
    EQ              reduce using rule 30 (var -> PROGRAM .)
    LTE             reduce using rule 30 (var -> PROGRAM .)
    GTE             reduce using rule 30 (var -> PROGRAM .)
    LT              reduce using rule 30 (var -> PROGRAM .)
    GT              reduce using rule 30 (var -> PROGRAM .)
    OR              reduce using rule 30 (var -> PROGRAM .)
    AND             reduce using rule 30 (var -> PROGRAM .)
    TO              reduce using rule 30 (var -> PROGRAM .)
    BY              reduce using rule 30 (var -> PROGRAM .)
    DO              reduce using rule 30 (var -> PROGRAM .)


state 43

    (31) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID . LBRACKET CTEINT RBRACKET
    (33) var -> ID .
    LBRACKET        shift and go to state 49
    COMMA           reduce using rule 33 (var -> ID .)
    SEMICOLON       reduce using rule 33 (var -> ID .)
    RPAREN          reduce using rule 33 (var -> ID .)
    ASSIGN          reduce using rule 33 (var -> ID .)


state 44

    (3) main_block -> MAIN changecontext . LPAREN RPAREN block
    LPAREN          shift and go to state 50


state 45

    (39) typefunc -> type ID . changecontext LPAREN params RPAREN returnblock
    (91) changecontext -> .
    LPAREN          reduce using rule 91 (changecontext -> .)

    changecontext                  shift and go to state 51

state 46

    (38) voidfunc -> VOID ID . changecontext LPAREN params RPAREN block
    (91) changecontext -> .
    LPAREN          reduce using rule 91 (changecontext -> .)

    changecontext                  shift and go to state 52

state 47

    (10) decvar_line -> type decvar SEMICOLON . decvar_line
    (11) decvar_line -> type decvar SEMICOLON .
    (10) decvar_line -> . type decvar SEMICOLON decvar_line
    (11) decvar_line -> . type decvar SEMICOLON
    (82) type -> . FLOAT
    (83) type -> . INT
    FUNC            reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    MAIN            reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    ID              reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    FROM            reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    WHILE           reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    INPUT           reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    PRINT           reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    IF              reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    RCURLY          reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    RETURN          reduce using rule 11 (decvar_line -> type decvar SEMICOLON .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    type                           shift and go to state 14
    decvar_line                    shift and go to state 53

state 48

    (12) decvar -> var COMMA . decvar
    (12) decvar -> . var COMMA decvar
    (13) decvar -> . var
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    var                            shift and go to state 25
    decvar                         shift and go to state 54

state 49

    (31) var -> ID LBRACKET . CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 55


state 50

    (3) main_block -> MAIN changecontext LPAREN . RPAREN block
    RPAREN          shift and go to state 56


state 51

    (39) typefunc -> type ID changecontext . LPAREN params RPAREN returnblock
    LPAREN          shift and go to state 57


state 52

    (38) voidfunc -> VOID ID changecontext . LPAREN params RPAREN block
    LPAREN          shift and go to state 58


state 53

    (10) decvar_line -> type decvar SEMICOLON decvar_line .
    FUNC            reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    MAIN            reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 10 (decvar_line -> type decvar SEMICOLON decvar_line .)


state 54

    (12) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 12 (decvar -> var COMMA decvar .)
    RPAREN          reduce using rule 12 (decvar -> var COMMA decvar .)


state 55

    (31) var -> ID LBRACKET CTEINT . RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 59


state 56

    (3) main_block -> MAIN changecontext LPAREN RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 60

state 57

    (39) typefunc -> type ID changecontext LPAREN . params RPAREN returnblock
    (40) params -> . empty
    (41) params -> . type ID COMMA params
    (42) params -> . type ID
    (93) empty -> .
    (82) type -> . FLOAT
    (83) type -> . INT
    RPAREN          reduce using rule 93 (empty -> .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    type                           shift and go to state 62
    params                         shift and go to state 63
    empty                          shift and go to state 64

state 58

    (38) voidfunc -> VOID ID changecontext LPAREN . params RPAREN block
    (40) params -> . empty
    (41) params -> . type ID COMMA params
    (42) params -> . type ID
    (93) empty -> .
    (82) type -> . FLOAT
    (83) type -> . INT
    RPAREN          reduce using rule 93 (empty -> .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    params                         shift and go to state 65
    empty                          shift and go to state 64
    type                           shift and go to state 62

state 59

    (31) var -> ID LBRACKET CTEINT RBRACKET . LBRACKET CTEINT RBRACKET
    (32) var -> ID LBRACKET CTEINT RBRACKET .
    LBRACKET        shift and go to state 66
    COMMA           reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    BY              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 32 (var -> ID LBRACKET CTEINT RBRACKET .)


state 60

    (3) main_block -> MAIN changecontext LPAREN RPAREN block .
    $end            reduce using rule 3 (main_block -> MAIN changecontext LPAREN RPAREN block .)


state 61

    (4) block -> LCURLY . decvars blockcontent RCURLY
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (93) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 93 (empty -> .)
    FROM            reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    INPUT           reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)

    decvars                        shift and go to state 67
    empty                          shift and go to state 7

state 62

    (41) params -> type . ID COMMA params
    (42) params -> type . ID
    ID              shift and go to state 68


state 63

    (39) typefunc -> type ID changecontext LPAREN params . RPAREN returnblock
    RPAREN          shift and go to state 69


state 64

    (40) params -> empty .
    RPAREN          reduce using rule 40 (params -> empty .)


state 65

    (38) voidfunc -> VOID ID changecontext LPAREN params . RPAREN block
    RPAREN          shift and go to state 70


state 66

    (31) var -> ID LBRACKET CTEINT RBRACKET LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 71


state 67

    (4) block -> LCURLY decvars . blockcontent RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (93) empty -> .
    (84) statute -> . call
    (85) statute -> . forloop
    (86) statute -> . whileloop
    (87) statute -> . read
    (88) statute -> . write
    (89) statute -> . condition
    (90) statute -> . assignment
    (43) call -> . ID LPAREN callvalues RPAREN
    (68) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (69) forloop -> . FROM var ASSIGN expression TO expression DO block
    (70) whileloop -> . WHILE LPAREN expression RPAREN block
    (72) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (73) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (78) condition -> . IF LPAREN expression RPAREN block ELSE block
    (79) condition -> . IF LPAREN expression RPAREN block
    (71) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 93 (empty -> .)
    ID              shift and go to state 82
    FROM            shift and go to state 83
    WHILE           shift and go to state 84
    INPUT           shift and go to state 85
    PRINT           shift and go to state 86
    IF              shift and go to state 87

    blockcontent                   shift and go to state 72
    empty                          shift and go to state 73
    statute                        shift and go to state 74
    call                           shift and go to state 75
    forloop                        shift and go to state 76
    whileloop                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    condition                      shift and go to state 80
    assignment                     shift and go to state 81

state 68

    (41) params -> type ID . COMMA params
    (42) params -> type ID .
    COMMA           shift and go to state 88
    RPAREN          reduce using rule 42 (params -> type ID .)


state 69

    (39) typefunc -> type ID changecontext LPAREN params RPAREN . returnblock
    (5) returnblock -> . LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
    LCURLY          shift and go to state 90

    returnblock                    shift and go to state 89

state 70

    (38) voidfunc -> VOID ID changecontext LPAREN params RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 91

state 71

    (31) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 92


state 72

    (4) block -> LCURLY decvars blockcontent . RCURLY
    RCURLY          shift and go to state 93


state 73

    (6) blockcontent -> empty .
    RCURLY          reduce using rule 6 (blockcontent -> empty .)
    RETURN          reduce using rule 6 (blockcontent -> empty .)


state 74

    (7) blockcontent -> statute . blockcontent
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (93) empty -> .
    (84) statute -> . call
    (85) statute -> . forloop
    (86) statute -> . whileloop
    (87) statute -> . read
    (88) statute -> . write
    (89) statute -> . condition
    (90) statute -> . assignment
    (43) call -> . ID LPAREN callvalues RPAREN
    (68) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (69) forloop -> . FROM var ASSIGN expression TO expression DO block
    (70) whileloop -> . WHILE LPAREN expression RPAREN block
    (72) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (73) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (78) condition -> . IF LPAREN expression RPAREN block ELSE block
    (79) condition -> . IF LPAREN expression RPAREN block
    (71) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    ID              shift and go to state 82
    FROM            shift and go to state 83
    WHILE           shift and go to state 84
    INPUT           shift and go to state 85
    PRINT           shift and go to state 86
    IF              shift and go to state 87

    statute                        shift and go to state 74
    blockcontent                   shift and go to state 94
    empty                          shift and go to state 73
    call                           shift and go to state 75
    forloop                        shift and go to state 76
    whileloop                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    condition                      shift and go to state 80
    assignment                     shift and go to state 81

state 75

    (84) statute -> call .
    ID              reduce using rule 84 (statute -> call .)
    FROM            reduce using rule 84 (statute -> call .)
    WHILE           reduce using rule 84 (statute -> call .)
    INPUT           reduce using rule 84 (statute -> call .)
    PRINT           reduce using rule 84 (statute -> call .)
    IF              reduce using rule 84 (statute -> call .)
    RCURLY          reduce using rule 84 (statute -> call .)
    RETURN          reduce using rule 84 (statute -> call .)


state 76

    (85) statute -> forloop .
    ID              reduce using rule 85 (statute -> forloop .)
    FROM            reduce using rule 85 (statute -> forloop .)
    WHILE           reduce using rule 85 (statute -> forloop .)
    INPUT           reduce using rule 85 (statute -> forloop .)
    PRINT           reduce using rule 85 (statute -> forloop .)
    IF              reduce using rule 85 (statute -> forloop .)
    RCURLY          reduce using rule 85 (statute -> forloop .)
    RETURN          reduce using rule 85 (statute -> forloop .)


state 77

    (86) statute -> whileloop .
    ID              reduce using rule 86 (statute -> whileloop .)
    FROM            reduce using rule 86 (statute -> whileloop .)
    WHILE           reduce using rule 86 (statute -> whileloop .)
    INPUT           reduce using rule 86 (statute -> whileloop .)
    PRINT           reduce using rule 86 (statute -> whileloop .)
    IF              reduce using rule 86 (statute -> whileloop .)
    RCURLY          reduce using rule 86 (statute -> whileloop .)
    RETURN          reduce using rule 86 (statute -> whileloop .)


state 78

    (87) statute -> read .
    ID              reduce using rule 87 (statute -> read .)
    FROM            reduce using rule 87 (statute -> read .)
    WHILE           reduce using rule 87 (statute -> read .)
    INPUT           reduce using rule 87 (statute -> read .)
    PRINT           reduce using rule 87 (statute -> read .)
    IF              reduce using rule 87 (statute -> read .)
    RCURLY          reduce using rule 87 (statute -> read .)
    RETURN          reduce using rule 87 (statute -> read .)


state 79

    (88) statute -> write .
    ID              reduce using rule 88 (statute -> write .)
    FROM            reduce using rule 88 (statute -> write .)
    WHILE           reduce using rule 88 (statute -> write .)
    INPUT           reduce using rule 88 (statute -> write .)
    PRINT           reduce using rule 88 (statute -> write .)
    IF              reduce using rule 88 (statute -> write .)
    RCURLY          reduce using rule 88 (statute -> write .)
    RETURN          reduce using rule 88 (statute -> write .)


state 80

    (89) statute -> condition .
    ID              reduce using rule 89 (statute -> condition .)
    FROM            reduce using rule 89 (statute -> condition .)
    WHILE           reduce using rule 89 (statute -> condition .)
    INPUT           reduce using rule 89 (statute -> condition .)
    PRINT           reduce using rule 89 (statute -> condition .)
    IF              reduce using rule 89 (statute -> condition .)
    RCURLY          reduce using rule 89 (statute -> condition .)
    RETURN          reduce using rule 89 (statute -> condition .)


state 81

    (90) statute -> assignment .
    ID              reduce using rule 90 (statute -> assignment .)
    FROM            reduce using rule 90 (statute -> assignment .)
    WHILE           reduce using rule 90 (statute -> assignment .)
    INPUT           reduce using rule 90 (statute -> assignment .)
    PRINT           reduce using rule 90 (statute -> assignment .)
    IF              reduce using rule 90 (statute -> assignment .)
    RCURLY          reduce using rule 90 (statute -> assignment .)
    RETURN          reduce using rule 90 (statute -> assignment .)


state 82

    (43) call -> ID . LPAREN callvalues RPAREN
    (71) assignment -> ID . ASSIGN expression SEMICOLON
    LPAREN          shift and go to state 95
    ASSIGN          shift and go to state 96


state 83

    (68) forloop -> FROM . var ASSIGN expression TO expression BY expression DO block
    (69) forloop -> FROM . var ASSIGN expression TO expression DO block
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    var                            shift and go to state 97

state 84

    (70) whileloop -> WHILE . LPAREN expression RPAREN block
    LPAREN          shift and go to state 98


state 85

    (72) read -> INPUT . LPAREN decvar RPAREN SEMICOLON
    LPAREN          shift and go to state 99


state 86

    (73) write -> PRINT . LPAREN writevalues RPAREN SEMICOLON
    LPAREN          shift and go to state 100


state 87

    (78) condition -> IF . LPAREN expression RPAREN block ELSE block
    (79) condition -> IF . LPAREN expression RPAREN block
    LPAREN          shift and go to state 101


state 88

    (41) params -> type ID COMMA . params
    (40) params -> . empty
    (41) params -> . type ID COMMA params
    (42) params -> . type ID
    (93) empty -> .
    (82) type -> . FLOAT
    (83) type -> . INT
    RPAREN          reduce using rule 93 (empty -> .)
    FLOAT           shift and go to state 15
    INT             shift and go to state 16

    type                           shift and go to state 62
    params                         shift and go to state 102
    empty                          shift and go to state 64

state 89

    (39) typefunc -> type ID changecontext LPAREN params RPAREN returnblock .
    FUNC            reduce using rule 39 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)
    MAIN            reduce using rule 39 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)


state 90

    (5) returnblock -> LCURLY . decvars blockcontent RETURN exp SEMICOLON RCURLY
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (93) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 93 (empty -> .)
    FROM            reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    INPUT           reduce using rule 93 (empty -> .)
    PRINT           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)

    decvars                        shift and go to state 103
    empty                          shift and go to state 7

state 91

    (38) voidfunc -> VOID ID changecontext LPAREN params RPAREN block .
    FUNC            reduce using rule 38 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)
    MAIN            reduce using rule 38 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)


state 92

    (31) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .
    COMMA           reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    BY              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 31 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)


state 93

    (4) block -> LCURLY decvars blockcontent RCURLY .
    $end            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    FUNC            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    MAIN            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    ID              reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    FROM            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    WHILE           reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    INPUT           reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    PRINT           reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    IF              reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    RCURLY          reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    RETURN          reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)
    ELSE            reduce using rule 4 (block -> LCURLY decvars blockcontent RCURLY .)


state 94

    (7) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 7 (blockcontent -> statute blockcontent .)
    RETURN          reduce using rule 7 (blockcontent -> statute blockcontent .)


state 95

    (43) call -> ID LPAREN . callvalues RPAREN
    (44) callvalues -> . empty
    (45) callvalues -> . exp COMMA callvalues
    (46) callvalues -> . exp
    (93) empty -> .
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    RPAREN          reduce using rule 93 (empty -> .)
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    callvalues                     shift and go to state 106
    empty                          shift and go to state 107
    exp                            shift and go to state 108
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 96

    (71) assignment -> ID ASSIGN . expression SEMICOLON
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 116
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 97

    (68) forloop -> FROM var . ASSIGN expression TO expression BY expression DO block
    (69) forloop -> FROM var . ASSIGN expression TO expression DO block
    ASSIGN          shift and go to state 118


state 98

    (70) whileloop -> WHILE LPAREN . expression RPAREN block
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 119
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 99

    (72) read -> INPUT LPAREN . decvar RPAREN SEMICOLON
    (12) decvar -> . var COMMA decvar
    (13) decvar -> . var
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42
    ID              shift and go to state 43

    decvar                         shift and go to state 120
    var                            shift and go to state 25

state 100

    (73) write -> PRINT LPAREN . writevalues RPAREN SEMICOLON
    (74) writevalues -> . CTESTRING COMMA writevalues
    (75) writevalues -> . super_exp COMMA writevalues
    (76) writevalues -> . CTESTRING
    (77) writevalues -> . super_exp
    (47) super_exp -> . expression OR super_exp
    (48) super_exp -> . expression AND super_exp
    (49) super_exp -> . expression
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    CTESTRING       shift and go to state 122
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    writevalues                    shift and go to state 121
    super_exp                      shift and go to state 123
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 101

    (78) condition -> IF LPAREN . expression RPAREN block ELSE block
    (79) condition -> IF LPAREN . expression RPAREN block
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 125
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 102

    (41) params -> type ID COMMA params .
    RPAREN          reduce using rule 41 (params -> type ID COMMA params .)


state 103

    (5) returnblock -> LCURLY decvars . blockcontent RETURN exp SEMICOLON RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (93) empty -> .
    (84) statute -> . call
    (85) statute -> . forloop
    (86) statute -> . whileloop
    (87) statute -> . read
    (88) statute -> . write
    (89) statute -> . condition
    (90) statute -> . assignment
    (43) call -> . ID LPAREN callvalues RPAREN
    (68) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (69) forloop -> . FROM var ASSIGN expression TO expression DO block
    (70) whileloop -> . WHILE LPAREN expression RPAREN block
    (72) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (73) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (78) condition -> . IF LPAREN expression RPAREN block ELSE block
    (79) condition -> . IF LPAREN expression RPAREN block
    (71) assignment -> . ID ASSIGN expression SEMICOLON
    RETURN          reduce using rule 93 (empty -> .)
    ID              shift and go to state 82
    FROM            shift and go to state 83
    WHILE           shift and go to state 84
    INPUT           shift and go to state 85
    PRINT           shift and go to state 86
    IF              shift and go to state 87

    blockcontent                   shift and go to state 126
    empty                          shift and go to state 73
    statute                        shift and go to state 74
    call                           shift and go to state 75
    forloop                        shift and go to state 76
    whileloop                      shift and go to state 77
    read                           shift and go to state 78
    write                          shift and go to state 79
    condition                      shift and go to state 80
    assignment                     shift and go to state 81

state 104

    (43) call -> ID . LPAREN callvalues RPAREN
    (31) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> ID . LBRACKET CTEINT RBRACKET
    (33) var -> ID .
    LPAREN          shift and go to state 95
    LBRACKET        shift and go to state 49
    DIVIDE          reduce using rule 33 (var -> ID .)
    TIMES           reduce using rule 33 (var -> ID .)
    MINUS           reduce using rule 33 (var -> ID .)
    PLUS            reduce using rule 33 (var -> ID .)
    COMMA           reduce using rule 33 (var -> ID .)
    RPAREN          reduce using rule 33 (var -> ID .)
    NEQ             reduce using rule 33 (var -> ID .)
    EQ              reduce using rule 33 (var -> ID .)
    LTE             reduce using rule 33 (var -> ID .)
    GTE             reduce using rule 33 (var -> ID .)
    LT              reduce using rule 33 (var -> ID .)
    GT              reduce using rule 33 (var -> ID .)
    SEMICOLON       reduce using rule 33 (var -> ID .)
    OR              reduce using rule 33 (var -> ID .)
    AND             reduce using rule 33 (var -> ID .)
    TO              reduce using rule 33 (var -> ID .)
    BY              reduce using rule 33 (var -> ID .)
    DO              reduce using rule 33 (var -> ID .)


state 105

    (64) factor -> LPAREN . super_exp RPAREN
    (47) super_exp -> . expression OR super_exp
    (48) super_exp -> . expression AND super_exp
    (49) super_exp -> . expression
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    super_exp                      shift and go to state 127
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 106

    (43) call -> ID LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 128


state 107

    (44) callvalues -> empty .
    RPAREN          reduce using rule 44 (callvalues -> empty .)


state 108

    (45) callvalues -> exp . COMMA callvalues
    (46) callvalues -> exp .
    COMMA           shift and go to state 129
    RPAREN          reduce using rule 46 (callvalues -> exp .)


state 109

    (58) exp -> term . MINUS exp
    (59) exp -> term . PLUS exp
    (60) exp -> term .
    MINUS           shift and go to state 130
    PLUS            shift and go to state 131
    COMMA           reduce using rule 60 (exp -> term .)
    RPAREN          reduce using rule 60 (exp -> term .)
    NEQ             reduce using rule 60 (exp -> term .)
    EQ              reduce using rule 60 (exp -> term .)
    LTE             reduce using rule 60 (exp -> term .)
    GTE             reduce using rule 60 (exp -> term .)
    LT              reduce using rule 60 (exp -> term .)
    GT              reduce using rule 60 (exp -> term .)
    SEMICOLON       reduce using rule 60 (exp -> term .)
    OR              reduce using rule 60 (exp -> term .)
    AND             reduce using rule 60 (exp -> term .)
    TO              reduce using rule 60 (exp -> term .)
    BY              reduce using rule 60 (exp -> term .)
    DO              reduce using rule 60 (exp -> term .)


state 110

    (61) term -> factor . DIVIDE term
    (62) term -> factor . TIMES term
    (63) term -> factor .
    DIVIDE          shift and go to state 132
    TIMES           shift and go to state 133
    MINUS           reduce using rule 63 (term -> factor .)
    PLUS            reduce using rule 63 (term -> factor .)
    COMMA           reduce using rule 63 (term -> factor .)
    RPAREN          reduce using rule 63 (term -> factor .)
    NEQ             reduce using rule 63 (term -> factor .)
    EQ              reduce using rule 63 (term -> factor .)
    LTE             reduce using rule 63 (term -> factor .)
    GTE             reduce using rule 63 (term -> factor .)
    LT              reduce using rule 63 (term -> factor .)
    GT              reduce using rule 63 (term -> factor .)
    SEMICOLON       reduce using rule 63 (term -> factor .)
    OR              reduce using rule 63 (term -> factor .)
    AND             reduce using rule 63 (term -> factor .)
    TO              reduce using rule 63 (term -> factor .)
    BY              reduce using rule 63 (term -> factor .)
    DO              reduce using rule 63 (term -> factor .)


state 111

    (65) factor -> varcte .
    DIVIDE          reduce using rule 65 (factor -> varcte .)
    TIMES           reduce using rule 65 (factor -> varcte .)
    MINUS           reduce using rule 65 (factor -> varcte .)
    PLUS            reduce using rule 65 (factor -> varcte .)
    COMMA           reduce using rule 65 (factor -> varcte .)
    RPAREN          reduce using rule 65 (factor -> varcte .)
    NEQ             reduce using rule 65 (factor -> varcte .)
    EQ              reduce using rule 65 (factor -> varcte .)
    LTE             reduce using rule 65 (factor -> varcte .)
    GTE             reduce using rule 65 (factor -> varcte .)
    LT              reduce using rule 65 (factor -> varcte .)
    GT              reduce using rule 65 (factor -> varcte .)
    SEMICOLON       reduce using rule 65 (factor -> varcte .)
    OR              reduce using rule 65 (factor -> varcte .)
    AND             reduce using rule 65 (factor -> varcte .)
    TO              reduce using rule 65 (factor -> varcte .)
    BY              reduce using rule 65 (factor -> varcte .)
    DO              reduce using rule 65 (factor -> varcte .)


state 112

    (66) factor -> call .
    DIVIDE          reduce using rule 66 (factor -> call .)
    TIMES           reduce using rule 66 (factor -> call .)
    MINUS           reduce using rule 66 (factor -> call .)
    PLUS            reduce using rule 66 (factor -> call .)
    COMMA           reduce using rule 66 (factor -> call .)
    RPAREN          reduce using rule 66 (factor -> call .)
    NEQ             reduce using rule 66 (factor -> call .)
    EQ              reduce using rule 66 (factor -> call .)
    LTE             reduce using rule 66 (factor -> call .)
    GTE             reduce using rule 66 (factor -> call .)
    LT              reduce using rule 66 (factor -> call .)
    GT              reduce using rule 66 (factor -> call .)
    SEMICOLON       reduce using rule 66 (factor -> call .)
    OR              reduce using rule 66 (factor -> call .)
    AND             reduce using rule 66 (factor -> call .)
    TO              reduce using rule 66 (factor -> call .)
    BY              reduce using rule 66 (factor -> call .)
    DO              reduce using rule 66 (factor -> call .)


state 113

    (67) factor -> var .
    DIVIDE          reduce using rule 67 (factor -> var .)
    TIMES           reduce using rule 67 (factor -> var .)
    MINUS           reduce using rule 67 (factor -> var .)
    PLUS            reduce using rule 67 (factor -> var .)
    COMMA           reduce using rule 67 (factor -> var .)
    RPAREN          reduce using rule 67 (factor -> var .)
    NEQ             reduce using rule 67 (factor -> var .)
    EQ              reduce using rule 67 (factor -> var .)
    LTE             reduce using rule 67 (factor -> var .)
    GTE             reduce using rule 67 (factor -> var .)
    LT              reduce using rule 67 (factor -> var .)
    GT              reduce using rule 67 (factor -> var .)
    SEMICOLON       reduce using rule 67 (factor -> var .)
    OR              reduce using rule 67 (factor -> var .)
    AND             reduce using rule 67 (factor -> var .)
    TO              reduce using rule 67 (factor -> var .)
    BY              reduce using rule 67 (factor -> var .)
    DO              reduce using rule 67 (factor -> var .)


state 114

    (80) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 80 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 80 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 80 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 80 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 80 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 80 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 80 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 80 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 80 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 80 (varcte -> CTEFLOAT .)
    LT              reduce using rule 80 (varcte -> CTEFLOAT .)
    GT              reduce using rule 80 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 80 (varcte -> CTEFLOAT .)
    OR              reduce using rule 80 (varcte -> CTEFLOAT .)
    AND             reduce using rule 80 (varcte -> CTEFLOAT .)
    TO              reduce using rule 80 (varcte -> CTEFLOAT .)
    BY              reduce using rule 80 (varcte -> CTEFLOAT .)
    DO              reduce using rule 80 (varcte -> CTEFLOAT .)


state 115

    (81) varcte -> CTEINT .
    DIVIDE          reduce using rule 81 (varcte -> CTEINT .)
    TIMES           reduce using rule 81 (varcte -> CTEINT .)
    MINUS           reduce using rule 81 (varcte -> CTEINT .)
    PLUS            reduce using rule 81 (varcte -> CTEINT .)
    COMMA           reduce using rule 81 (varcte -> CTEINT .)
    RPAREN          reduce using rule 81 (varcte -> CTEINT .)
    NEQ             reduce using rule 81 (varcte -> CTEINT .)
    EQ              reduce using rule 81 (varcte -> CTEINT .)
    LTE             reduce using rule 81 (varcte -> CTEINT .)
    GTE             reduce using rule 81 (varcte -> CTEINT .)
    LT              reduce using rule 81 (varcte -> CTEINT .)
    GT              reduce using rule 81 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 81 (varcte -> CTEINT .)
    OR              reduce using rule 81 (varcte -> CTEINT .)
    AND             reduce using rule 81 (varcte -> CTEINT .)
    TO              reduce using rule 81 (varcte -> CTEINT .)
    BY              reduce using rule 81 (varcte -> CTEINT .)
    DO              reduce using rule 81 (varcte -> CTEINT .)


state 116

    (71) assignment -> ID ASSIGN expression . SEMICOLON
    SEMICOLON       shift and go to state 134


state 117

    (50) expression -> exp . relation exp
    (51) expression -> exp .
    (52) relation -> . NEQ
    (53) relation -> . EQ
    (54) relation -> . LTE
    (55) relation -> . GTE
    (56) relation -> . LT
    (57) relation -> . GT
    SEMICOLON       reduce using rule 51 (expression -> exp .)
    RPAREN          reduce using rule 51 (expression -> exp .)
    OR              reduce using rule 51 (expression -> exp .)
    AND             reduce using rule 51 (expression -> exp .)
    COMMA           reduce using rule 51 (expression -> exp .)
    TO              reduce using rule 51 (expression -> exp .)
    BY              reduce using rule 51 (expression -> exp .)
    DO              reduce using rule 51 (expression -> exp .)
    NEQ             shift and go to state 136
    EQ              shift and go to state 137
    LTE             shift and go to state 138
    GTE             shift and go to state 139
    LT              shift and go to state 140
    GT              shift and go to state 141

    relation                       shift and go to state 135

state 118

    (68) forloop -> FROM var ASSIGN . expression TO expression BY expression DO block
    (69) forloop -> FROM var ASSIGN . expression TO expression DO block
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    var                            shift and go to state 113
    expression                     shift and go to state 142
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112

state 119

    (70) whileloop -> WHILE LPAREN expression . RPAREN block
    RPAREN          shift and go to state 143


state 120

    (72) read -> INPUT LPAREN decvar . RPAREN SEMICOLON
    RPAREN          shift and go to state 144


state 121

    (73) write -> PRINT LPAREN writevalues . RPAREN SEMICOLON
    RPAREN          shift and go to state 145


state 122

    (74) writevalues -> CTESTRING . COMMA writevalues
    (76) writevalues -> CTESTRING .
    COMMA           shift and go to state 146
    RPAREN          reduce using rule 76 (writevalues -> CTESTRING .)


state 123

    (75) writevalues -> super_exp . COMMA writevalues
    (77) writevalues -> super_exp .
    COMMA           shift and go to state 147
    RPAREN          reduce using rule 77 (writevalues -> super_exp .)


state 124

    (47) super_exp -> expression . OR super_exp
    (48) super_exp -> expression . AND super_exp
    (49) super_exp -> expression .
    OR              shift and go to state 148
    AND             shift and go to state 149
    COMMA           reduce using rule 49 (super_exp -> expression .)
    RPAREN          reduce using rule 49 (super_exp -> expression .)


state 125

    (78) condition -> IF LPAREN expression . RPAREN block ELSE block
    (79) condition -> IF LPAREN expression . RPAREN block
    RPAREN          shift and go to state 150


state 126

    (5) returnblock -> LCURLY decvars blockcontent . RETURN exp SEMICOLON RCURLY
    RETURN          shift and go to state 151


state 127

    (64) factor -> LPAREN super_exp . RPAREN
    RPAREN          shift and go to state 152


state 128

    (43) call -> ID LPAREN callvalues RPAREN .
    ID              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    FROM            reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    IF              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    RETURN          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    DIVIDE          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    EQ              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    LTE             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    GTE             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    LT              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    GT              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    OR              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    AND             reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    TO              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    BY              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)
    DO              reduce using rule 43 (call -> ID LPAREN callvalues RPAREN .)


state 129

    (45) callvalues -> exp COMMA . callvalues
    (44) callvalues -> . empty
    (45) callvalues -> . exp COMMA callvalues
    (46) callvalues -> . exp
    (93) empty -> .
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    RPAREN          reduce using rule 93 (empty -> .)
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    exp                            shift and go to state 108
    callvalues                     shift and go to state 153
    empty                          shift and go to state 107
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 130

    (58) exp -> term MINUS . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    term                           shift and go to state 109
    exp                            shift and go to state 154
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 131

    (59) exp -> term PLUS . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    term                           shift and go to state 109
    exp                            shift and go to state 155
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 132

    (61) term -> factor DIVIDE . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    factor                         shift and go to state 110
    term                           shift and go to state 156
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 133

    (62) term -> factor TIMES . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    factor                         shift and go to state 110
    term                           shift and go to state 157
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 134

    (71) assignment -> ID ASSIGN expression SEMICOLON .
    ID              reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    FROM            reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    INPUT           reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    RCURLY          reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 71 (assignment -> ID ASSIGN expression SEMICOLON .)


state 135

    (50) expression -> exp relation . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    exp                            shift and go to state 158
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 136

    (52) relation -> NEQ .
    LPAREN          reduce using rule 52 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 52 (relation -> NEQ .)
    CTEINT          reduce using rule 52 (relation -> NEQ .)
    ID              reduce using rule 52 (relation -> NEQ .)
    FLOAT           reduce using rule 52 (relation -> NEQ .)
    INT             reduce using rule 52 (relation -> NEQ .)
    ELSE            reduce using rule 52 (relation -> NEQ .)
    IF              reduce using rule 52 (relation -> NEQ .)
    PRINT           reduce using rule 52 (relation -> NEQ .)
    INPUT           reduce using rule 52 (relation -> NEQ .)
    WHILE           reduce using rule 52 (relation -> NEQ .)
    DO              reduce using rule 52 (relation -> NEQ .)
    BY              reduce using rule 52 (relation -> NEQ .)
    TO              reduce using rule 52 (relation -> NEQ .)
    FROM            reduce using rule 52 (relation -> NEQ .)
    VOID            reduce using rule 52 (relation -> NEQ .)
    RETURN          reduce using rule 52 (relation -> NEQ .)
    FUNC            reduce using rule 52 (relation -> NEQ .)
    MAIN            reduce using rule 52 (relation -> NEQ .)
    VARS            reduce using rule 52 (relation -> NEQ .)
    PROGRAM         reduce using rule 52 (relation -> NEQ .)


state 137

    (53) relation -> EQ .
    LPAREN          reduce using rule 53 (relation -> EQ .)
    CTEFLOAT        reduce using rule 53 (relation -> EQ .)
    CTEINT          reduce using rule 53 (relation -> EQ .)
    ID              reduce using rule 53 (relation -> EQ .)
    FLOAT           reduce using rule 53 (relation -> EQ .)
    INT             reduce using rule 53 (relation -> EQ .)
    ELSE            reduce using rule 53 (relation -> EQ .)
    IF              reduce using rule 53 (relation -> EQ .)
    PRINT           reduce using rule 53 (relation -> EQ .)
    INPUT           reduce using rule 53 (relation -> EQ .)
    WHILE           reduce using rule 53 (relation -> EQ .)
    DO              reduce using rule 53 (relation -> EQ .)
    BY              reduce using rule 53 (relation -> EQ .)
    TO              reduce using rule 53 (relation -> EQ .)
    FROM            reduce using rule 53 (relation -> EQ .)
    VOID            reduce using rule 53 (relation -> EQ .)
    RETURN          reduce using rule 53 (relation -> EQ .)
    FUNC            reduce using rule 53 (relation -> EQ .)
    MAIN            reduce using rule 53 (relation -> EQ .)
    VARS            reduce using rule 53 (relation -> EQ .)
    PROGRAM         reduce using rule 53 (relation -> EQ .)


state 138

    (54) relation -> LTE .
    LPAREN          reduce using rule 54 (relation -> LTE .)
    CTEFLOAT        reduce using rule 54 (relation -> LTE .)
    CTEINT          reduce using rule 54 (relation -> LTE .)
    ID              reduce using rule 54 (relation -> LTE .)
    FLOAT           reduce using rule 54 (relation -> LTE .)
    INT             reduce using rule 54 (relation -> LTE .)
    ELSE            reduce using rule 54 (relation -> LTE .)
    IF              reduce using rule 54 (relation -> LTE .)
    PRINT           reduce using rule 54 (relation -> LTE .)
    INPUT           reduce using rule 54 (relation -> LTE .)
    WHILE           reduce using rule 54 (relation -> LTE .)
    DO              reduce using rule 54 (relation -> LTE .)
    BY              reduce using rule 54 (relation -> LTE .)
    TO              reduce using rule 54 (relation -> LTE .)
    FROM            reduce using rule 54 (relation -> LTE .)
    VOID            reduce using rule 54 (relation -> LTE .)
    RETURN          reduce using rule 54 (relation -> LTE .)
    FUNC            reduce using rule 54 (relation -> LTE .)
    MAIN            reduce using rule 54 (relation -> LTE .)
    VARS            reduce using rule 54 (relation -> LTE .)
    PROGRAM         reduce using rule 54 (relation -> LTE .)


state 139

    (55) relation -> GTE .
    LPAREN          reduce using rule 55 (relation -> GTE .)
    CTEFLOAT        reduce using rule 55 (relation -> GTE .)
    CTEINT          reduce using rule 55 (relation -> GTE .)
    ID              reduce using rule 55 (relation -> GTE .)
    FLOAT           reduce using rule 55 (relation -> GTE .)
    INT             reduce using rule 55 (relation -> GTE .)
    ELSE            reduce using rule 55 (relation -> GTE .)
    IF              reduce using rule 55 (relation -> GTE .)
    PRINT           reduce using rule 55 (relation -> GTE .)
    INPUT           reduce using rule 55 (relation -> GTE .)
    WHILE           reduce using rule 55 (relation -> GTE .)
    DO              reduce using rule 55 (relation -> GTE .)
    BY              reduce using rule 55 (relation -> GTE .)
    TO              reduce using rule 55 (relation -> GTE .)
    FROM            reduce using rule 55 (relation -> GTE .)
    VOID            reduce using rule 55 (relation -> GTE .)
    RETURN          reduce using rule 55 (relation -> GTE .)
    FUNC            reduce using rule 55 (relation -> GTE .)
    MAIN            reduce using rule 55 (relation -> GTE .)
    VARS            reduce using rule 55 (relation -> GTE .)
    PROGRAM         reduce using rule 55 (relation -> GTE .)


state 140

    (56) relation -> LT .
    LPAREN          reduce using rule 56 (relation -> LT .)
    CTEFLOAT        reduce using rule 56 (relation -> LT .)
    CTEINT          reduce using rule 56 (relation -> LT .)
    ID              reduce using rule 56 (relation -> LT .)
    FLOAT           reduce using rule 56 (relation -> LT .)
    INT             reduce using rule 56 (relation -> LT .)
    ELSE            reduce using rule 56 (relation -> LT .)
    IF              reduce using rule 56 (relation -> LT .)
    PRINT           reduce using rule 56 (relation -> LT .)
    INPUT           reduce using rule 56 (relation -> LT .)
    WHILE           reduce using rule 56 (relation -> LT .)
    DO              reduce using rule 56 (relation -> LT .)
    BY              reduce using rule 56 (relation -> LT .)
    TO              reduce using rule 56 (relation -> LT .)
    FROM            reduce using rule 56 (relation -> LT .)
    VOID            reduce using rule 56 (relation -> LT .)
    RETURN          reduce using rule 56 (relation -> LT .)
    FUNC            reduce using rule 56 (relation -> LT .)
    MAIN            reduce using rule 56 (relation -> LT .)
    VARS            reduce using rule 56 (relation -> LT .)
    PROGRAM         reduce using rule 56 (relation -> LT .)


state 141

    (57) relation -> GT .
    LPAREN          reduce using rule 57 (relation -> GT .)
    CTEFLOAT        reduce using rule 57 (relation -> GT .)
    CTEINT          reduce using rule 57 (relation -> GT .)
    ID              reduce using rule 57 (relation -> GT .)
    FLOAT           reduce using rule 57 (relation -> GT .)
    INT             reduce using rule 57 (relation -> GT .)
    ELSE            reduce using rule 57 (relation -> GT .)
    IF              reduce using rule 57 (relation -> GT .)
    PRINT           reduce using rule 57 (relation -> GT .)
    INPUT           reduce using rule 57 (relation -> GT .)
    WHILE           reduce using rule 57 (relation -> GT .)
    DO              reduce using rule 57 (relation -> GT .)
    BY              reduce using rule 57 (relation -> GT .)
    TO              reduce using rule 57 (relation -> GT .)
    FROM            reduce using rule 57 (relation -> GT .)
    VOID            reduce using rule 57 (relation -> GT .)
    RETURN          reduce using rule 57 (relation -> GT .)
    FUNC            reduce using rule 57 (relation -> GT .)
    MAIN            reduce using rule 57 (relation -> GT .)
    VARS            reduce using rule 57 (relation -> GT .)
    PROGRAM         reduce using rule 57 (relation -> GT .)


state 142

    (68) forloop -> FROM var ASSIGN expression . TO expression BY expression DO block
    (69) forloop -> FROM var ASSIGN expression . TO expression DO block
    TO              shift and go to state 159


state 143

    (70) whileloop -> WHILE LPAREN expression RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 160

state 144

    (72) read -> INPUT LPAREN decvar RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 161


state 145

    (73) write -> PRINT LPAREN writevalues RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 162


state 146

    (74) writevalues -> CTESTRING COMMA . writevalues
    (74) writevalues -> . CTESTRING COMMA writevalues
    (75) writevalues -> . super_exp COMMA writevalues
    (76) writevalues -> . CTESTRING
    (77) writevalues -> . super_exp
    (47) super_exp -> . expression OR super_exp
    (48) super_exp -> . expression AND super_exp
    (49) super_exp -> . expression
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    CTESTRING       shift and go to state 122
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    writevalues                    shift and go to state 163
    super_exp                      shift and go to state 123
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 147

    (75) writevalues -> super_exp COMMA . writevalues
    (74) writevalues -> . CTESTRING COMMA writevalues
    (75) writevalues -> . super_exp COMMA writevalues
    (76) writevalues -> . CTESTRING
    (77) writevalues -> . super_exp
    (47) super_exp -> . expression OR super_exp
    (48) super_exp -> . expression AND super_exp
    (49) super_exp -> . expression
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    CTESTRING       shift and go to state 122
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    super_exp                      shift and go to state 123
    writevalues                    shift and go to state 164
    expression                     shift and go to state 124
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 148

    (47) super_exp -> expression OR . super_exp
    (47) super_exp -> . expression OR super_exp
    (48) super_exp -> . expression AND super_exp
    (49) super_exp -> . expression
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 124
    super_exp                      shift and go to state 165
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 149

    (48) super_exp -> expression AND . super_exp
    (47) super_exp -> . expression OR super_exp
    (48) super_exp -> . expression AND super_exp
    (49) super_exp -> . expression
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    expression                     shift and go to state 124
    super_exp                      shift and go to state 166
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 150

    (78) condition -> IF LPAREN expression RPAREN . block ELSE block
    (79) condition -> IF LPAREN expression RPAREN . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 167

state 151

    (5) returnblock -> LCURLY decvars blockcontent RETURN . exp SEMICOLON RCURLY
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    exp                            shift and go to state 168
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112
    var                            shift and go to state 113

state 152

    (64) factor -> LPAREN super_exp RPAREN .
    DIVIDE          reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    TIMES           reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    PLUS            reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    COMMA           reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    NEQ             reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    EQ              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    LTE             reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    GTE             reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    LT              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    GT              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    OR              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    AND             reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    TO              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    BY              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)
    DO              reduce using rule 64 (factor -> LPAREN super_exp RPAREN .)


state 153

    (45) callvalues -> exp COMMA callvalues .
    RPAREN          reduce using rule 45 (callvalues -> exp COMMA callvalues .)


state 154

    (58) exp -> term MINUS exp .
    COMMA           reduce using rule 58 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 58 (exp -> term MINUS exp .)
    NEQ             reduce using rule 58 (exp -> term MINUS exp .)
    EQ              reduce using rule 58 (exp -> term MINUS exp .)
    LTE             reduce using rule 58 (exp -> term MINUS exp .)
    GTE             reduce using rule 58 (exp -> term MINUS exp .)
    LT              reduce using rule 58 (exp -> term MINUS exp .)
    GT              reduce using rule 58 (exp -> term MINUS exp .)
    SEMICOLON       reduce using rule 58 (exp -> term MINUS exp .)
    OR              reduce using rule 58 (exp -> term MINUS exp .)
    AND             reduce using rule 58 (exp -> term MINUS exp .)
    TO              reduce using rule 58 (exp -> term MINUS exp .)
    BY              reduce using rule 58 (exp -> term MINUS exp .)
    DO              reduce using rule 58 (exp -> term MINUS exp .)


state 155

    (59) exp -> term PLUS exp .
    COMMA           reduce using rule 59 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 59 (exp -> term PLUS exp .)
    NEQ             reduce using rule 59 (exp -> term PLUS exp .)
    EQ              reduce using rule 59 (exp -> term PLUS exp .)
    LTE             reduce using rule 59 (exp -> term PLUS exp .)
    GTE             reduce using rule 59 (exp -> term PLUS exp .)
    LT              reduce using rule 59 (exp -> term PLUS exp .)
    GT              reduce using rule 59 (exp -> term PLUS exp .)
    SEMICOLON       reduce using rule 59 (exp -> term PLUS exp .)
    OR              reduce using rule 59 (exp -> term PLUS exp .)
    AND             reduce using rule 59 (exp -> term PLUS exp .)
    TO              reduce using rule 59 (exp -> term PLUS exp .)
    BY              reduce using rule 59 (exp -> term PLUS exp .)
    DO              reduce using rule 59 (exp -> term PLUS exp .)


state 156

    (61) term -> factor DIVIDE term .
    MINUS           reduce using rule 61 (term -> factor DIVIDE term .)
    PLUS            reduce using rule 61 (term -> factor DIVIDE term .)
    COMMA           reduce using rule 61 (term -> factor DIVIDE term .)
    RPAREN          reduce using rule 61 (term -> factor DIVIDE term .)
    NEQ             reduce using rule 61 (term -> factor DIVIDE term .)
    EQ              reduce using rule 61 (term -> factor DIVIDE term .)
    LTE             reduce using rule 61 (term -> factor DIVIDE term .)
    GTE             reduce using rule 61 (term -> factor DIVIDE term .)
    LT              reduce using rule 61 (term -> factor DIVIDE term .)
    GT              reduce using rule 61 (term -> factor DIVIDE term .)
    SEMICOLON       reduce using rule 61 (term -> factor DIVIDE term .)
    OR              reduce using rule 61 (term -> factor DIVIDE term .)
    AND             reduce using rule 61 (term -> factor DIVIDE term .)
    TO              reduce using rule 61 (term -> factor DIVIDE term .)
    BY              reduce using rule 61 (term -> factor DIVIDE term .)
    DO              reduce using rule 61 (term -> factor DIVIDE term .)


state 157

    (62) term -> factor TIMES term .
    MINUS           reduce using rule 62 (term -> factor TIMES term .)
    PLUS            reduce using rule 62 (term -> factor TIMES term .)
    COMMA           reduce using rule 62 (term -> factor TIMES term .)
    RPAREN          reduce using rule 62 (term -> factor TIMES term .)
    NEQ             reduce using rule 62 (term -> factor TIMES term .)
    EQ              reduce using rule 62 (term -> factor TIMES term .)
    LTE             reduce using rule 62 (term -> factor TIMES term .)
    GTE             reduce using rule 62 (term -> factor TIMES term .)
    LT              reduce using rule 62 (term -> factor TIMES term .)
    GT              reduce using rule 62 (term -> factor TIMES term .)
    SEMICOLON       reduce using rule 62 (term -> factor TIMES term .)
    OR              reduce using rule 62 (term -> factor TIMES term .)
    AND             reduce using rule 62 (term -> factor TIMES term .)
    TO              reduce using rule 62 (term -> factor TIMES term .)
    BY              reduce using rule 62 (term -> factor TIMES term .)
    DO              reduce using rule 62 (term -> factor TIMES term .)


state 158

    (50) expression -> exp relation exp .
    SEMICOLON       reduce using rule 50 (expression -> exp relation exp .)
    RPAREN          reduce using rule 50 (expression -> exp relation exp .)
    OR              reduce using rule 50 (expression -> exp relation exp .)
    AND             reduce using rule 50 (expression -> exp relation exp .)
    COMMA           reduce using rule 50 (expression -> exp relation exp .)
    TO              reduce using rule 50 (expression -> exp relation exp .)
    BY              reduce using rule 50 (expression -> exp relation exp .)
    DO              reduce using rule 50 (expression -> exp relation exp .)


state 159

    (68) forloop -> FROM var ASSIGN expression TO . expression BY expression DO block
    (69) forloop -> FROM var ASSIGN expression TO . expression DO block
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    var                            shift and go to state 113
    expression                     shift and go to state 169
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112

state 160

    (70) whileloop -> WHILE LPAREN expression RPAREN block .
    ID              reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    FROM            reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    WHILE           reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    INPUT           reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    PRINT           reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    IF              reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RETURN          reduce using rule 70 (whileloop -> WHILE LPAREN expression RPAREN block .)


state 161

    (72) read -> INPUT LPAREN decvar RPAREN SEMICOLON .
    ID              reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    FROM            reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    WHILE           reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    INPUT           reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    PRINT           reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    IF              reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RCURLY          reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RETURN          reduce using rule 72 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)


state 162

    (73) write -> PRINT LPAREN writevalues RPAREN SEMICOLON .
    ID              reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    FROM            reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    WHILE           reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    INPUT           reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    PRINT           reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    IF              reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RCURLY          reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RETURN          reduce using rule 73 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)


state 163

    (74) writevalues -> CTESTRING COMMA writevalues .
    RPAREN          reduce using rule 74 (writevalues -> CTESTRING COMMA writevalues .)


state 164

    (75) writevalues -> super_exp COMMA writevalues .
    RPAREN          reduce using rule 75 (writevalues -> super_exp COMMA writevalues .)


state 165

    (47) super_exp -> expression OR super_exp .
    COMMA           reduce using rule 47 (super_exp -> expression OR super_exp .)
    RPAREN          reduce using rule 47 (super_exp -> expression OR super_exp .)


state 166

    (48) super_exp -> expression AND super_exp .
    COMMA           reduce using rule 48 (super_exp -> expression AND super_exp .)
    RPAREN          reduce using rule 48 (super_exp -> expression AND super_exp .)


state 167

    (78) condition -> IF LPAREN expression RPAREN block . ELSE block
    (79) condition -> IF LPAREN expression RPAREN block .
    ELSE            shift and go to state 170
    ID              reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    FROM            reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    WHILE           reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    INPUT           reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    PRINT           reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    IF              reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)
    RETURN          reduce using rule 79 (condition -> IF LPAREN expression RPAREN block .)


state 168

    (5) returnblock -> LCURLY decvars blockcontent RETURN exp . SEMICOLON RCURLY
    SEMICOLON       shift and go to state 171


state 169

    (68) forloop -> FROM var ASSIGN expression TO expression . BY expression DO block
    (69) forloop -> FROM var ASSIGN expression TO expression . DO block
    BY              shift and go to state 172
    DO              shift and go to state 173


state 170

    (78) condition -> IF LPAREN expression RPAREN block ELSE . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 174

state 171

    (5) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON . RCURLY
    RCURLY          shift and go to state 175


state 172

    (68) forloop -> FROM var ASSIGN expression TO expression BY . expression DO block
    (50) expression -> . exp relation exp
    (51) expression -> . exp
    (58) exp -> . term MINUS exp
    (59) exp -> . term PLUS exp
    (60) exp -> . term
    (61) term -> . factor DIVIDE term
    (62) term -> . factor TIMES term
    (63) term -> . factor
    (64) factor -> . LPAREN super_exp RPAREN
    (65) factor -> . varcte
    (66) factor -> . call
    (67) factor -> . var
    (80) varcte -> . CTEFLOAT
    (81) varcte -> . CTEINT
    (43) call -> . ID LPAREN callvalues RPAREN
    (14) var -> . FLOAT
    (15) var -> . INT
    (16) var -> . ELSE
    (17) var -> . IF
    (18) var -> . PRINT
    (19) var -> . INPUT
    (20) var -> . WHILE
    (21) var -> . DO
    (22) var -> . BY
    (23) var -> . TO
    (24) var -> . FROM
    (25) var -> . VOID
    (26) var -> . RETURN
    (27) var -> . FUNC
    (28) var -> . MAIN
    (29) var -> . VARS
    (30) var -> . PROGRAM
    (31) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (32) var -> . ID LBRACKET CTEINT RBRACKET
    (33) var -> . ID
    LPAREN          shift and go to state 105
    CTEFLOAT        shift and go to state 114
    CTEINT          shift and go to state 115
    ID              shift and go to state 104
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    ELSE            shift and go to state 28
    IF              shift and go to state 29
    PRINT           shift and go to state 30
    INPUT           shift and go to state 31
    WHILE           shift and go to state 32
    DO              shift and go to state 33
    BY              shift and go to state 34
    TO              shift and go to state 35
    FROM            shift and go to state 36
    VOID            shift and go to state 37
    RETURN          shift and go to state 38
    FUNC            shift and go to state 39
    MAIN            shift and go to state 40
    VARS            shift and go to state 41
    PROGRAM         shift and go to state 42

    var                            shift and go to state 113
    expression                     shift and go to state 176
    exp                            shift and go to state 117
    term                           shift and go to state 109
    factor                         shift and go to state 110
    varcte                         shift and go to state 111
    call                           shift and go to state 112

state 173

    (69) forloop -> FROM var ASSIGN expression TO expression DO . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 177

state 174

    (78) condition -> IF LPAREN expression RPAREN block ELSE block .
    ID              reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    FROM            reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    WHILE           reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    INPUT           reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    PRINT           reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    IF              reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RCURLY          reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RETURN          reduce using rule 78 (condition -> IF LPAREN expression RPAREN block ELSE block .)


state 175

    (5) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .
    FUNC            reduce using rule 5 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)
    MAIN            reduce using rule 5 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)


state 176

    (68) forloop -> FROM var ASSIGN expression TO expression BY expression . DO block
    DO              shift and go to state 178


state 177

    (69) forloop -> FROM var ASSIGN expression TO expression DO block .
    ID              reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    FROM            reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    WHILE           reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    INPUT           reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    PRINT           reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    IF              reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RCURLY          reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RETURN          reduce using rule 69 (forloop -> FROM var ASSIGN expression TO expression DO block .)


state 178

    (68) forloop -> FROM var ASSIGN expression TO expression BY expression DO . block
    (4) block -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 61

    block                          shift and go to state 179

state 179

    (68) forloop -> FROM var ASSIGN expression TO expression BY expression DO block .
    ID              reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    FROM            reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    WHILE           reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    INPUT           reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    PRINT           reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    IF              reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RCURLY          reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RETURN          reduce using rule 68 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
