Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     declare -> decvars decfuncs main_block
Rule 3     main_block -> MAIN changecontext LPAREN RPAREN declareblock
Rule 4     block -> LCURLY blockcontent RCURLY
Rule 5     declareblock -> LCURLY decvars blockcontent RCURLY
Rule 6     returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
Rule 7     blockcontent -> empty
Rule 8     blockcontent -> statute blockcontent
Rule 9     decvars -> empty
Rule 10    decvars -> VARS decvar_line
Rule 11    decvar_line -> decvar_type decvar SEMICOLON decvar_line
Rule 12    decvar_line -> decvar_type decvar SEMICOLON
Rule 13    decvar_type -> type
Rule 14    decvar -> var COMMA decvar
Rule 15    decvar -> var
Rule 16    var -> BOOL
Rule 17    var -> FLOAT
Rule 18    var -> INT
Rule 19    var -> ELSE
Rule 20    var -> IF
Rule 21    var -> PRINT
Rule 22    var -> INPUT
Rule 23    var -> WHILE
Rule 24    var -> DO
Rule 25    var -> BY
Rule 26    var -> TO
Rule 27    var -> FROM
Rule 28    var -> VOID
Rule 29    var -> RETURN
Rule 30    var -> FUNC
Rule 31    var -> MAIN
Rule 32    var -> VARS
Rule 33    var -> PROGRAM
Rule 34    var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
Rule 35    var -> ID LBRACKET CTEINT RBRACKET
Rule 36    var -> ID
Rule 37    decfuncs -> empty
Rule 38    decfuncs -> func decfuncs
Rule 39    func -> FUNC typefunc
Rule 40    func -> FUNC voidfunc
Rule 41    voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock
Rule 42    typefunc -> type ID changecontext LPAREN params RPAREN returnblock
Rule 43    params -> empty
Rule 44    params -> param params_aux
Rule 45    param -> type ID
Rule 46    params_aux -> empty
Rule 47    params_aux -> COMMA params
Rule 48    call -> ID generate_era LPAREN callvalues RPAREN
Rule 49    generate_era -> <empty>
Rule 50    callvalues_aux -> COMMA callvalues
Rule 51    callvalues_aux -> empty
Rule 52    callvalues -> exp generate_param callvalues_aux
Rule 53    generate_param -> <empty>
Rule 54    super_exp_aux -> logic super_exp
Rule 55    super_exp_aux -> empty
Rule 56    super_exp -> expression super_exp_quadgen super_exp_aux
Rule 57    logic -> OR
Rule 58    logic -> AND
Rule 59    super_exp_quadgen -> <empty>
Rule 60    expression_aux -> relation expression
Rule 61    expression_aux -> empty
Rule 62    expression -> exp expression_quadgen expression_aux
Rule 63    relation -> NEQ
Rule 64    relation -> EQ
Rule 65    relation -> LTE
Rule 66    relation -> GTE
Rule 67    relation -> LT
Rule 68    relation -> GT
Rule 69    expression_quadgen -> <empty>
Rule 70    exp_aux -> exp_sign exp
Rule 71    exp_aux -> empty
Rule 72    exp -> term exp_quadgen exp_aux
Rule 73    exp_sign -> MINUS
Rule 74    exp_sign -> PLUS
Rule 75    exp_quadgen -> <empty>
Rule 76    term_aux -> term_sign term
Rule 77    term_aux -> empty
Rule 78    term -> factor term_quadgen term_aux
Rule 79    term_sign -> DIVIDE
Rule 80    term_sign -> TIMES
Rule 81    term_quadgen -> <empty>
Rule 82    factor -> LPAREN fakefloor super_exp RPAREN
Rule 83    factor -> varcte
Rule 84    factor -> call
Rule 85    factor -> var
Rule 86    fakefloor -> <empty>
Rule 87    forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
Rule 88    forloopcontrolvar -> var
Rule 89    validatecontrolvar -> <empty>
Rule 90    createfinaltempvar -> <empty>
Rule 91    validateloopend -> <empty>
Rule 92    whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
Rule 93    dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
Rule 94    assignment -> assignment_var assignment_sign expression SEMICOLON
Rule 95    assignment_sign -> ASSIGN
Rule 96    assignment_var -> ID
Rule 97    read -> INPUT LPAREN readaux RPAREN SEMICOLON
Rule 98    readaux -> readvalue COMMA readaux
Rule 99    readaux -> readvalue
Rule 100   readvalue -> var
Rule 101   write -> PRINT LPAREN writeaux RPAREN SEMICOLON
Rule 102   writeaux -> writevalues
Rule 103   writeaux -> writevalues COMMA writeaux
Rule 104   writevalues -> CTESTRING
Rule 105   writevalues -> super_exp
Rule 106   condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps
Rule 107   condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
Rule 108   openjumpslot -> <empty>
Rule 109   saveposition -> <empty>
Rule 110   filljumps -> <empty>
Rule 111   varcte -> CTEBOOL
Rule 112   varcte -> CTEFLOAT
Rule 113   varcte -> CTEINT
Rule 114   type -> BOOL
Rule 115   type -> FLOAT
Rule 116   type -> INT
Rule 117   statute -> call
Rule 118   statute -> forloop
Rule 119   statute -> dowhileloop
Rule 120   statute -> whileloop
Rule 121   statute -> read
Rule 122   statute -> write
Rule 123   statute -> condition
Rule 124   statute -> assignment
Rule 125   changecontext -> <empty>
Rule 126   saveprogramname -> <empty>
Rule 127   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 58
ASSIGN               : 95
BOOL                 : 16 114
BY                   : 25
COMMA                : 14 47 50 98 103
CTEBOOL              : 111
CTEFLOAT             : 112
CTEINT               : 34 34 35 113
CTESTRING            : 104
DIVIDE               : 79
DO                   : 24 87 93
ELSE                 : 19 107
EQ                   : 64
FLOAT                : 17 115
FROM                 : 27 87
FUNC                 : 30 39 40
GT                   : 68
GTE                  : 66
ID                   : 1 34 35 36 41 42 45 48 96
IF                   : 20 106 107
INPUT                : 22 97
INT                  : 18 116
LBRACKET             : 34 34 35
LCURLY               : 4 5 6
LPAREN               : 3 41 42 48 82 92 93 97 101 106 107
LT                   : 67
LTE                  : 65
MAIN                 : 3 31
MINUS                : 73
NEQ                  : 63
OR                   : 57
PLUS                 : 74
PRINT                : 21 101
PROGRAM              : 1 33
RBRACKET             : 34 34 35
RCURLY               : 4 5 6
RETURN               : 6 29
RPAREN               : 3 41 42 48 82 92 93 97 101 106 107
SEMICOLON            : 6 11 12 94 97 101
TIMES                : 80
TO                   : 26 87
VARS                 : 10 32
VOID                 : 28 41
WHILE                : 23 92 93
error                : 

Nonterminals, with rules where they appear:

assignment           : 124
assignment_sign      : 87 94
assignment_var       : 94
block                : 87 92 93 106 107 107
blockcontent         : 4 5 6 8
call                 : 84 117
callvalues           : 48 50
callvalues_aux       : 52
changecontext        : 3 41 42
condition            : 123
createfinaltempvar   : 87
decfuncs             : 2 38
declare              : 1
declareblock         : 3 41
decvar               : 11 12 14
decvar_line          : 10 11
decvar_type          : 11 12
decvars              : 2 5 6
dowhileloop          : 119
empty                : 7 9 37 43 46 51 55 61 71 77
exp                  : 6 52 62 70
exp_aux              : 72
exp_quadgen          : 72
exp_sign             : 70
expression           : 56 60 87 87 92 93 94
expression_aux       : 62
expression_quadgen   : 62
factor               : 78
fakefloor            : 82
filljumps            : 87 92 106 107 107
forloop              : 118
forloopcontrolvar    : 87
func                 : 38
generate_era         : 48
generate_param       : 52
logic                : 54
main_block           : 2
openjumpslot         : 87 92 93 106 107 107
param                : 44
params               : 41 42 47
params_aux           : 44
program              : 0
read                 : 121
readaux              : 97 98
readvalue            : 98 99
relation             : 60
returnblock          : 42
saveposition         : 92 93
saveprogramname      : 1
statute              : 8
super_exp            : 54 82 105 106 107
super_exp_aux        : 56
super_exp_quadgen    : 56
term                 : 72 76
term_aux             : 78
term_quadgen         : 78
term_sign            : 76
type                 : 13 42 45
typefunc             : 39
validatecontrolvar   : 87
validateloopend      : 87
var                  : 14 15 85 88 100
varcte               : 83
voidfunc             : 40
whileloop            : 120
write                : 122
writeaux             : 101 103
writevalues          : 102 103


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (126) saveprogramname -> .
    VARS            reduce using rule 126 (saveprogramname -> .)
    FUNC            reduce using rule 126 (saveprogramname -> .)
    MAIN            reduce using rule 126 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (2) declare -> . decvars decfuncs main_block
    (9) decvars -> . empty
    (10) decvars -> . VARS decvar_line
    (127) empty -> .
    VARS            shift and go to state 8
    FUNC            reduce using rule 127 (empty -> .)
    MAIN            reduce using rule 127 (empty -> .)

    declare                        shift and go to state 5
    decvars                        shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (2) declare -> decvars . decfuncs main_block
    (37) decfuncs -> . empty
    (38) decfuncs -> . func decfuncs
    (127) empty -> .
    (39) func -> . FUNC typefunc
    (40) func -> . FUNC voidfunc
    MAIN            reduce using rule 127 (empty -> .)
    FUNC            shift and go to state 12

    decfuncs                       shift and go to state 9
    empty                          shift and go to state 10
    func                           shift and go to state 11

state 7

    (9) decvars -> empty .
    FUNC            reduce using rule 9 (decvars -> empty .)
    MAIN            reduce using rule 9 (decvars -> empty .)
    ID              reduce using rule 9 (decvars -> empty .)
    FROM            reduce using rule 9 (decvars -> empty .)
    DO              reduce using rule 9 (decvars -> empty .)
    WHILE           reduce using rule 9 (decvars -> empty .)
    INPUT           reduce using rule 9 (decvars -> empty .)
    PRINT           reduce using rule 9 (decvars -> empty .)
    IF              reduce using rule 9 (decvars -> empty .)
    RCURLY          reduce using rule 9 (decvars -> empty .)
    RETURN          reduce using rule 9 (decvars -> empty .)


state 8

    (10) decvars -> VARS . decvar_line
    (11) decvar_line -> . decvar_type decvar SEMICOLON decvar_line
    (12) decvar_line -> . decvar_type decvar SEMICOLON
    (13) decvar_type -> . type
    (114) type -> . BOOL
    (115) type -> . FLOAT
    (116) type -> . INT
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    decvar_line                    shift and go to state 13
    decvar_type                    shift and go to state 14
    type                           shift and go to state 15

state 9

    (2) declare -> decvars decfuncs . main_block
    (3) main_block -> . MAIN changecontext LPAREN RPAREN declareblock
    MAIN            shift and go to state 20

    main_block                     shift and go to state 19

state 10

    (37) decfuncs -> empty .
    MAIN            reduce using rule 37 (decfuncs -> empty .)


state 11

    (38) decfuncs -> func . decfuncs
    (37) decfuncs -> . empty
    (38) decfuncs -> . func decfuncs
    (127) empty -> .
    (39) func -> . FUNC typefunc
    (40) func -> . FUNC voidfunc
    MAIN            reduce using rule 127 (empty -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 11
    decfuncs                       shift and go to state 21
    empty                          shift and go to state 10

state 12

    (39) func -> FUNC . typefunc
    (40) func -> FUNC . voidfunc
    (42) typefunc -> . type ID changecontext LPAREN params RPAREN returnblock
    (41) voidfunc -> . VOID ID changecontext LPAREN params RPAREN declareblock
    (114) type -> . BOOL
    (115) type -> . FLOAT
    (116) type -> . INT
    VOID            shift and go to state 25
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    typefunc                       shift and go to state 22
    voidfunc                       shift and go to state 23
    type                           shift and go to state 24

state 13

    (10) decvars -> VARS decvar_line .
    FUNC            reduce using rule 10 (decvars -> VARS decvar_line .)
    MAIN            reduce using rule 10 (decvars -> VARS decvar_line .)
    ID              reduce using rule 10 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 10 (decvars -> VARS decvar_line .)
    DO              reduce using rule 10 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 10 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 10 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 10 (decvars -> VARS decvar_line .)
    IF              reduce using rule 10 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 10 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 10 (decvars -> VARS decvar_line .)


state 14

    (11) decvar_line -> decvar_type . decvar SEMICOLON decvar_line
    (12) decvar_line -> decvar_type . decvar SEMICOLON
    (14) decvar -> . var COMMA decvar
    (15) decvar -> . var
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45
    ID              shift and go to state 46

    decvar                         shift and go to state 26
    var                            shift and go to state 27

state 15

    (13) decvar_type -> type .
    BOOL            reduce using rule 13 (decvar_type -> type .)
    FLOAT           reduce using rule 13 (decvar_type -> type .)
    INT             reduce using rule 13 (decvar_type -> type .)
    ELSE            reduce using rule 13 (decvar_type -> type .)
    IF              reduce using rule 13 (decvar_type -> type .)
    PRINT           reduce using rule 13 (decvar_type -> type .)
    INPUT           reduce using rule 13 (decvar_type -> type .)
    WHILE           reduce using rule 13 (decvar_type -> type .)
    DO              reduce using rule 13 (decvar_type -> type .)
    BY              reduce using rule 13 (decvar_type -> type .)
    TO              reduce using rule 13 (decvar_type -> type .)
    FROM            reduce using rule 13 (decvar_type -> type .)
    VOID            reduce using rule 13 (decvar_type -> type .)
    RETURN          reduce using rule 13 (decvar_type -> type .)
    FUNC            reduce using rule 13 (decvar_type -> type .)
    MAIN            reduce using rule 13 (decvar_type -> type .)
    VARS            reduce using rule 13 (decvar_type -> type .)
    PROGRAM         reduce using rule 13 (decvar_type -> type .)
    ID              reduce using rule 13 (decvar_type -> type .)


state 16

    (114) type -> BOOL .
    BOOL            reduce using rule 114 (type -> BOOL .)
    FLOAT           reduce using rule 114 (type -> BOOL .)
    INT             reduce using rule 114 (type -> BOOL .)
    ELSE            reduce using rule 114 (type -> BOOL .)
    IF              reduce using rule 114 (type -> BOOL .)
    PRINT           reduce using rule 114 (type -> BOOL .)
    INPUT           reduce using rule 114 (type -> BOOL .)
    WHILE           reduce using rule 114 (type -> BOOL .)
    DO              reduce using rule 114 (type -> BOOL .)
    BY              reduce using rule 114 (type -> BOOL .)
    TO              reduce using rule 114 (type -> BOOL .)
    FROM            reduce using rule 114 (type -> BOOL .)
    VOID            reduce using rule 114 (type -> BOOL .)
    RETURN          reduce using rule 114 (type -> BOOL .)
    FUNC            reduce using rule 114 (type -> BOOL .)
    MAIN            reduce using rule 114 (type -> BOOL .)
    VARS            reduce using rule 114 (type -> BOOL .)
    PROGRAM         reduce using rule 114 (type -> BOOL .)
    ID              reduce using rule 114 (type -> BOOL .)


state 17

    (115) type -> FLOAT .
    BOOL            reduce using rule 115 (type -> FLOAT .)
    FLOAT           reduce using rule 115 (type -> FLOAT .)
    INT             reduce using rule 115 (type -> FLOAT .)
    ELSE            reduce using rule 115 (type -> FLOAT .)
    IF              reduce using rule 115 (type -> FLOAT .)
    PRINT           reduce using rule 115 (type -> FLOAT .)
    INPUT           reduce using rule 115 (type -> FLOAT .)
    WHILE           reduce using rule 115 (type -> FLOAT .)
    DO              reduce using rule 115 (type -> FLOAT .)
    BY              reduce using rule 115 (type -> FLOAT .)
    TO              reduce using rule 115 (type -> FLOAT .)
    FROM            reduce using rule 115 (type -> FLOAT .)
    VOID            reduce using rule 115 (type -> FLOAT .)
    RETURN          reduce using rule 115 (type -> FLOAT .)
    FUNC            reduce using rule 115 (type -> FLOAT .)
    MAIN            reduce using rule 115 (type -> FLOAT .)
    VARS            reduce using rule 115 (type -> FLOAT .)
    PROGRAM         reduce using rule 115 (type -> FLOAT .)
    ID              reduce using rule 115 (type -> FLOAT .)


state 18

    (116) type -> INT .
    BOOL            reduce using rule 116 (type -> INT .)
    FLOAT           reduce using rule 116 (type -> INT .)
    INT             reduce using rule 116 (type -> INT .)
    ELSE            reduce using rule 116 (type -> INT .)
    IF              reduce using rule 116 (type -> INT .)
    PRINT           reduce using rule 116 (type -> INT .)
    INPUT           reduce using rule 116 (type -> INT .)
    WHILE           reduce using rule 116 (type -> INT .)
    DO              reduce using rule 116 (type -> INT .)
    BY              reduce using rule 116 (type -> INT .)
    TO              reduce using rule 116 (type -> INT .)
    FROM            reduce using rule 116 (type -> INT .)
    VOID            reduce using rule 116 (type -> INT .)
    RETURN          reduce using rule 116 (type -> INT .)
    FUNC            reduce using rule 116 (type -> INT .)
    MAIN            reduce using rule 116 (type -> INT .)
    VARS            reduce using rule 116 (type -> INT .)
    PROGRAM         reduce using rule 116 (type -> INT .)
    ID              reduce using rule 116 (type -> INT .)


state 19

    (2) declare -> decvars decfuncs main_block .
    $end            reduce using rule 2 (declare -> decvars decfuncs main_block .)


state 20

    (3) main_block -> MAIN . changecontext LPAREN RPAREN declareblock
    (125) changecontext -> .
    LPAREN          reduce using rule 125 (changecontext -> .)

    changecontext                  shift and go to state 47

state 21

    (38) decfuncs -> func decfuncs .
    MAIN            reduce using rule 38 (decfuncs -> func decfuncs .)


state 22

    (39) func -> FUNC typefunc .
    FUNC            reduce using rule 39 (func -> FUNC typefunc .)
    MAIN            reduce using rule 39 (func -> FUNC typefunc .)


state 23

    (40) func -> FUNC voidfunc .
    FUNC            reduce using rule 40 (func -> FUNC voidfunc .)
    MAIN            reduce using rule 40 (func -> FUNC voidfunc .)


state 24

    (42) typefunc -> type . ID changecontext LPAREN params RPAREN returnblock
    ID              shift and go to state 48


state 25

    (41) voidfunc -> VOID . ID changecontext LPAREN params RPAREN declareblock
    ID              shift and go to state 49


state 26

    (11) decvar_line -> decvar_type decvar . SEMICOLON decvar_line
    (12) decvar_line -> decvar_type decvar . SEMICOLON
    SEMICOLON       shift and go to state 50


state 27

    (14) decvar -> var . COMMA decvar
    (15) decvar -> var .
    COMMA           shift and go to state 51
    SEMICOLON       reduce using rule 15 (decvar -> var .)


state 28

    (16) var -> BOOL .
    COMMA           reduce using rule 16 (var -> BOOL .)
    SEMICOLON       reduce using rule 16 (var -> BOOL .)
    ASSIGN          reduce using rule 16 (var -> BOOL .)
    RPAREN          reduce using rule 16 (var -> BOOL .)
    DIVIDE          reduce using rule 16 (var -> BOOL .)
    TIMES           reduce using rule 16 (var -> BOOL .)
    MINUS           reduce using rule 16 (var -> BOOL .)
    PLUS            reduce using rule 16 (var -> BOOL .)
    NEQ             reduce using rule 16 (var -> BOOL .)
    EQ              reduce using rule 16 (var -> BOOL .)
    LTE             reduce using rule 16 (var -> BOOL .)
    GTE             reduce using rule 16 (var -> BOOL .)
    LT              reduce using rule 16 (var -> BOOL .)
    GT              reduce using rule 16 (var -> BOOL .)
    OR              reduce using rule 16 (var -> BOOL .)
    AND             reduce using rule 16 (var -> BOOL .)
    TO              reduce using rule 16 (var -> BOOL .)
    DO              reduce using rule 16 (var -> BOOL .)


state 29

    (17) var -> FLOAT .
    COMMA           reduce using rule 17 (var -> FLOAT .)
    SEMICOLON       reduce using rule 17 (var -> FLOAT .)
    ASSIGN          reduce using rule 17 (var -> FLOAT .)
    RPAREN          reduce using rule 17 (var -> FLOAT .)
    DIVIDE          reduce using rule 17 (var -> FLOAT .)
    TIMES           reduce using rule 17 (var -> FLOAT .)
    MINUS           reduce using rule 17 (var -> FLOAT .)
    PLUS            reduce using rule 17 (var -> FLOAT .)
    NEQ             reduce using rule 17 (var -> FLOAT .)
    EQ              reduce using rule 17 (var -> FLOAT .)
    LTE             reduce using rule 17 (var -> FLOAT .)
    GTE             reduce using rule 17 (var -> FLOAT .)
    LT              reduce using rule 17 (var -> FLOAT .)
    GT              reduce using rule 17 (var -> FLOAT .)
    OR              reduce using rule 17 (var -> FLOAT .)
    AND             reduce using rule 17 (var -> FLOAT .)
    TO              reduce using rule 17 (var -> FLOAT .)
    DO              reduce using rule 17 (var -> FLOAT .)


state 30

    (18) var -> INT .
    COMMA           reduce using rule 18 (var -> INT .)
    SEMICOLON       reduce using rule 18 (var -> INT .)
    ASSIGN          reduce using rule 18 (var -> INT .)
    RPAREN          reduce using rule 18 (var -> INT .)
    DIVIDE          reduce using rule 18 (var -> INT .)
    TIMES           reduce using rule 18 (var -> INT .)
    MINUS           reduce using rule 18 (var -> INT .)
    PLUS            reduce using rule 18 (var -> INT .)
    NEQ             reduce using rule 18 (var -> INT .)
    EQ              reduce using rule 18 (var -> INT .)
    LTE             reduce using rule 18 (var -> INT .)
    GTE             reduce using rule 18 (var -> INT .)
    LT              reduce using rule 18 (var -> INT .)
    GT              reduce using rule 18 (var -> INT .)
    OR              reduce using rule 18 (var -> INT .)
    AND             reduce using rule 18 (var -> INT .)
    TO              reduce using rule 18 (var -> INT .)
    DO              reduce using rule 18 (var -> INT .)


state 31

    (19) var -> ELSE .
    COMMA           reduce using rule 19 (var -> ELSE .)
    SEMICOLON       reduce using rule 19 (var -> ELSE .)
    ASSIGN          reduce using rule 19 (var -> ELSE .)
    RPAREN          reduce using rule 19 (var -> ELSE .)
    DIVIDE          reduce using rule 19 (var -> ELSE .)
    TIMES           reduce using rule 19 (var -> ELSE .)
    MINUS           reduce using rule 19 (var -> ELSE .)
    PLUS            reduce using rule 19 (var -> ELSE .)
    NEQ             reduce using rule 19 (var -> ELSE .)
    EQ              reduce using rule 19 (var -> ELSE .)
    LTE             reduce using rule 19 (var -> ELSE .)
    GTE             reduce using rule 19 (var -> ELSE .)
    LT              reduce using rule 19 (var -> ELSE .)
    GT              reduce using rule 19 (var -> ELSE .)
    OR              reduce using rule 19 (var -> ELSE .)
    AND             reduce using rule 19 (var -> ELSE .)
    TO              reduce using rule 19 (var -> ELSE .)
    DO              reduce using rule 19 (var -> ELSE .)


state 32

    (20) var -> IF .
    COMMA           reduce using rule 20 (var -> IF .)
    SEMICOLON       reduce using rule 20 (var -> IF .)
    ASSIGN          reduce using rule 20 (var -> IF .)
    RPAREN          reduce using rule 20 (var -> IF .)
    DIVIDE          reduce using rule 20 (var -> IF .)
    TIMES           reduce using rule 20 (var -> IF .)
    MINUS           reduce using rule 20 (var -> IF .)
    PLUS            reduce using rule 20 (var -> IF .)
    NEQ             reduce using rule 20 (var -> IF .)
    EQ              reduce using rule 20 (var -> IF .)
    LTE             reduce using rule 20 (var -> IF .)
    GTE             reduce using rule 20 (var -> IF .)
    LT              reduce using rule 20 (var -> IF .)
    GT              reduce using rule 20 (var -> IF .)
    OR              reduce using rule 20 (var -> IF .)
    AND             reduce using rule 20 (var -> IF .)
    TO              reduce using rule 20 (var -> IF .)
    DO              reduce using rule 20 (var -> IF .)


state 33

    (21) var -> PRINT .
    COMMA           reduce using rule 21 (var -> PRINT .)
    SEMICOLON       reduce using rule 21 (var -> PRINT .)
    ASSIGN          reduce using rule 21 (var -> PRINT .)
    RPAREN          reduce using rule 21 (var -> PRINT .)
    DIVIDE          reduce using rule 21 (var -> PRINT .)
    TIMES           reduce using rule 21 (var -> PRINT .)
    MINUS           reduce using rule 21 (var -> PRINT .)
    PLUS            reduce using rule 21 (var -> PRINT .)
    NEQ             reduce using rule 21 (var -> PRINT .)
    EQ              reduce using rule 21 (var -> PRINT .)
    LTE             reduce using rule 21 (var -> PRINT .)
    GTE             reduce using rule 21 (var -> PRINT .)
    LT              reduce using rule 21 (var -> PRINT .)
    GT              reduce using rule 21 (var -> PRINT .)
    OR              reduce using rule 21 (var -> PRINT .)
    AND             reduce using rule 21 (var -> PRINT .)
    TO              reduce using rule 21 (var -> PRINT .)
    DO              reduce using rule 21 (var -> PRINT .)


state 34

    (22) var -> INPUT .
    COMMA           reduce using rule 22 (var -> INPUT .)
    SEMICOLON       reduce using rule 22 (var -> INPUT .)
    ASSIGN          reduce using rule 22 (var -> INPUT .)
    RPAREN          reduce using rule 22 (var -> INPUT .)
    DIVIDE          reduce using rule 22 (var -> INPUT .)
    TIMES           reduce using rule 22 (var -> INPUT .)
    MINUS           reduce using rule 22 (var -> INPUT .)
    PLUS            reduce using rule 22 (var -> INPUT .)
    NEQ             reduce using rule 22 (var -> INPUT .)
    EQ              reduce using rule 22 (var -> INPUT .)
    LTE             reduce using rule 22 (var -> INPUT .)
    GTE             reduce using rule 22 (var -> INPUT .)
    LT              reduce using rule 22 (var -> INPUT .)
    GT              reduce using rule 22 (var -> INPUT .)
    OR              reduce using rule 22 (var -> INPUT .)
    AND             reduce using rule 22 (var -> INPUT .)
    TO              reduce using rule 22 (var -> INPUT .)
    DO              reduce using rule 22 (var -> INPUT .)


state 35

    (23) var -> WHILE .
    COMMA           reduce using rule 23 (var -> WHILE .)
    SEMICOLON       reduce using rule 23 (var -> WHILE .)
    ASSIGN          reduce using rule 23 (var -> WHILE .)
    RPAREN          reduce using rule 23 (var -> WHILE .)
    DIVIDE          reduce using rule 23 (var -> WHILE .)
    TIMES           reduce using rule 23 (var -> WHILE .)
    MINUS           reduce using rule 23 (var -> WHILE .)
    PLUS            reduce using rule 23 (var -> WHILE .)
    NEQ             reduce using rule 23 (var -> WHILE .)
    EQ              reduce using rule 23 (var -> WHILE .)
    LTE             reduce using rule 23 (var -> WHILE .)
    GTE             reduce using rule 23 (var -> WHILE .)
    LT              reduce using rule 23 (var -> WHILE .)
    GT              reduce using rule 23 (var -> WHILE .)
    OR              reduce using rule 23 (var -> WHILE .)
    AND             reduce using rule 23 (var -> WHILE .)
    TO              reduce using rule 23 (var -> WHILE .)
    DO              reduce using rule 23 (var -> WHILE .)


state 36

    (24) var -> DO .
    COMMA           reduce using rule 24 (var -> DO .)
    SEMICOLON       reduce using rule 24 (var -> DO .)
    ASSIGN          reduce using rule 24 (var -> DO .)
    RPAREN          reduce using rule 24 (var -> DO .)
    DIVIDE          reduce using rule 24 (var -> DO .)
    TIMES           reduce using rule 24 (var -> DO .)
    MINUS           reduce using rule 24 (var -> DO .)
    PLUS            reduce using rule 24 (var -> DO .)
    NEQ             reduce using rule 24 (var -> DO .)
    EQ              reduce using rule 24 (var -> DO .)
    LTE             reduce using rule 24 (var -> DO .)
    GTE             reduce using rule 24 (var -> DO .)
    LT              reduce using rule 24 (var -> DO .)
    GT              reduce using rule 24 (var -> DO .)
    OR              reduce using rule 24 (var -> DO .)
    AND             reduce using rule 24 (var -> DO .)
    TO              reduce using rule 24 (var -> DO .)
    DO              reduce using rule 24 (var -> DO .)


state 37

    (25) var -> BY .
    COMMA           reduce using rule 25 (var -> BY .)
    SEMICOLON       reduce using rule 25 (var -> BY .)
    ASSIGN          reduce using rule 25 (var -> BY .)
    RPAREN          reduce using rule 25 (var -> BY .)
    DIVIDE          reduce using rule 25 (var -> BY .)
    TIMES           reduce using rule 25 (var -> BY .)
    MINUS           reduce using rule 25 (var -> BY .)
    PLUS            reduce using rule 25 (var -> BY .)
    NEQ             reduce using rule 25 (var -> BY .)
    EQ              reduce using rule 25 (var -> BY .)
    LTE             reduce using rule 25 (var -> BY .)
    GTE             reduce using rule 25 (var -> BY .)
    LT              reduce using rule 25 (var -> BY .)
    GT              reduce using rule 25 (var -> BY .)
    OR              reduce using rule 25 (var -> BY .)
    AND             reduce using rule 25 (var -> BY .)
    TO              reduce using rule 25 (var -> BY .)
    DO              reduce using rule 25 (var -> BY .)


state 38

    (26) var -> TO .
    COMMA           reduce using rule 26 (var -> TO .)
    SEMICOLON       reduce using rule 26 (var -> TO .)
    ASSIGN          reduce using rule 26 (var -> TO .)
    RPAREN          reduce using rule 26 (var -> TO .)
    DIVIDE          reduce using rule 26 (var -> TO .)
    TIMES           reduce using rule 26 (var -> TO .)
    MINUS           reduce using rule 26 (var -> TO .)
    PLUS            reduce using rule 26 (var -> TO .)
    NEQ             reduce using rule 26 (var -> TO .)
    EQ              reduce using rule 26 (var -> TO .)
    LTE             reduce using rule 26 (var -> TO .)
    GTE             reduce using rule 26 (var -> TO .)
    LT              reduce using rule 26 (var -> TO .)
    GT              reduce using rule 26 (var -> TO .)
    OR              reduce using rule 26 (var -> TO .)
    AND             reduce using rule 26 (var -> TO .)
    TO              reduce using rule 26 (var -> TO .)
    DO              reduce using rule 26 (var -> TO .)


state 39

    (27) var -> FROM .
    COMMA           reduce using rule 27 (var -> FROM .)
    SEMICOLON       reduce using rule 27 (var -> FROM .)
    ASSIGN          reduce using rule 27 (var -> FROM .)
    RPAREN          reduce using rule 27 (var -> FROM .)
    DIVIDE          reduce using rule 27 (var -> FROM .)
    TIMES           reduce using rule 27 (var -> FROM .)
    MINUS           reduce using rule 27 (var -> FROM .)
    PLUS            reduce using rule 27 (var -> FROM .)
    NEQ             reduce using rule 27 (var -> FROM .)
    EQ              reduce using rule 27 (var -> FROM .)
    LTE             reduce using rule 27 (var -> FROM .)
    GTE             reduce using rule 27 (var -> FROM .)
    LT              reduce using rule 27 (var -> FROM .)
    GT              reduce using rule 27 (var -> FROM .)
    OR              reduce using rule 27 (var -> FROM .)
    AND             reduce using rule 27 (var -> FROM .)
    TO              reduce using rule 27 (var -> FROM .)
    DO              reduce using rule 27 (var -> FROM .)


state 40

    (28) var -> VOID .
    COMMA           reduce using rule 28 (var -> VOID .)
    SEMICOLON       reduce using rule 28 (var -> VOID .)
    ASSIGN          reduce using rule 28 (var -> VOID .)
    RPAREN          reduce using rule 28 (var -> VOID .)
    DIVIDE          reduce using rule 28 (var -> VOID .)
    TIMES           reduce using rule 28 (var -> VOID .)
    MINUS           reduce using rule 28 (var -> VOID .)
    PLUS            reduce using rule 28 (var -> VOID .)
    NEQ             reduce using rule 28 (var -> VOID .)
    EQ              reduce using rule 28 (var -> VOID .)
    LTE             reduce using rule 28 (var -> VOID .)
    GTE             reduce using rule 28 (var -> VOID .)
    LT              reduce using rule 28 (var -> VOID .)
    GT              reduce using rule 28 (var -> VOID .)
    OR              reduce using rule 28 (var -> VOID .)
    AND             reduce using rule 28 (var -> VOID .)
    TO              reduce using rule 28 (var -> VOID .)
    DO              reduce using rule 28 (var -> VOID .)


state 41

    (29) var -> RETURN .
    COMMA           reduce using rule 29 (var -> RETURN .)
    SEMICOLON       reduce using rule 29 (var -> RETURN .)
    ASSIGN          reduce using rule 29 (var -> RETURN .)
    RPAREN          reduce using rule 29 (var -> RETURN .)
    DIVIDE          reduce using rule 29 (var -> RETURN .)
    TIMES           reduce using rule 29 (var -> RETURN .)
    MINUS           reduce using rule 29 (var -> RETURN .)
    PLUS            reduce using rule 29 (var -> RETURN .)
    NEQ             reduce using rule 29 (var -> RETURN .)
    EQ              reduce using rule 29 (var -> RETURN .)
    LTE             reduce using rule 29 (var -> RETURN .)
    GTE             reduce using rule 29 (var -> RETURN .)
    LT              reduce using rule 29 (var -> RETURN .)
    GT              reduce using rule 29 (var -> RETURN .)
    OR              reduce using rule 29 (var -> RETURN .)
    AND             reduce using rule 29 (var -> RETURN .)
    TO              reduce using rule 29 (var -> RETURN .)
    DO              reduce using rule 29 (var -> RETURN .)


state 42

    (30) var -> FUNC .
    COMMA           reduce using rule 30 (var -> FUNC .)
    SEMICOLON       reduce using rule 30 (var -> FUNC .)
    ASSIGN          reduce using rule 30 (var -> FUNC .)
    RPAREN          reduce using rule 30 (var -> FUNC .)
    DIVIDE          reduce using rule 30 (var -> FUNC .)
    TIMES           reduce using rule 30 (var -> FUNC .)
    MINUS           reduce using rule 30 (var -> FUNC .)
    PLUS            reduce using rule 30 (var -> FUNC .)
    NEQ             reduce using rule 30 (var -> FUNC .)
    EQ              reduce using rule 30 (var -> FUNC .)
    LTE             reduce using rule 30 (var -> FUNC .)
    GTE             reduce using rule 30 (var -> FUNC .)
    LT              reduce using rule 30 (var -> FUNC .)
    GT              reduce using rule 30 (var -> FUNC .)
    OR              reduce using rule 30 (var -> FUNC .)
    AND             reduce using rule 30 (var -> FUNC .)
    TO              reduce using rule 30 (var -> FUNC .)
    DO              reduce using rule 30 (var -> FUNC .)


state 43

    (31) var -> MAIN .
    COMMA           reduce using rule 31 (var -> MAIN .)
    SEMICOLON       reduce using rule 31 (var -> MAIN .)
    ASSIGN          reduce using rule 31 (var -> MAIN .)
    RPAREN          reduce using rule 31 (var -> MAIN .)
    DIVIDE          reduce using rule 31 (var -> MAIN .)
    TIMES           reduce using rule 31 (var -> MAIN .)
    MINUS           reduce using rule 31 (var -> MAIN .)
    PLUS            reduce using rule 31 (var -> MAIN .)
    NEQ             reduce using rule 31 (var -> MAIN .)
    EQ              reduce using rule 31 (var -> MAIN .)
    LTE             reduce using rule 31 (var -> MAIN .)
    GTE             reduce using rule 31 (var -> MAIN .)
    LT              reduce using rule 31 (var -> MAIN .)
    GT              reduce using rule 31 (var -> MAIN .)
    OR              reduce using rule 31 (var -> MAIN .)
    AND             reduce using rule 31 (var -> MAIN .)
    TO              reduce using rule 31 (var -> MAIN .)
    DO              reduce using rule 31 (var -> MAIN .)


state 44

    (32) var -> VARS .
    COMMA           reduce using rule 32 (var -> VARS .)
    SEMICOLON       reduce using rule 32 (var -> VARS .)
    ASSIGN          reduce using rule 32 (var -> VARS .)
    RPAREN          reduce using rule 32 (var -> VARS .)
    DIVIDE          reduce using rule 32 (var -> VARS .)
    TIMES           reduce using rule 32 (var -> VARS .)
    MINUS           reduce using rule 32 (var -> VARS .)
    PLUS            reduce using rule 32 (var -> VARS .)
    NEQ             reduce using rule 32 (var -> VARS .)
    EQ              reduce using rule 32 (var -> VARS .)
    LTE             reduce using rule 32 (var -> VARS .)
    GTE             reduce using rule 32 (var -> VARS .)
    LT              reduce using rule 32 (var -> VARS .)
    GT              reduce using rule 32 (var -> VARS .)
    OR              reduce using rule 32 (var -> VARS .)
    AND             reduce using rule 32 (var -> VARS .)
    TO              reduce using rule 32 (var -> VARS .)
    DO              reduce using rule 32 (var -> VARS .)


state 45

    (33) var -> PROGRAM .
    COMMA           reduce using rule 33 (var -> PROGRAM .)
    SEMICOLON       reduce using rule 33 (var -> PROGRAM .)
    ASSIGN          reduce using rule 33 (var -> PROGRAM .)
    RPAREN          reduce using rule 33 (var -> PROGRAM .)
    DIVIDE          reduce using rule 33 (var -> PROGRAM .)
    TIMES           reduce using rule 33 (var -> PROGRAM .)
    MINUS           reduce using rule 33 (var -> PROGRAM .)
    PLUS            reduce using rule 33 (var -> PROGRAM .)
    NEQ             reduce using rule 33 (var -> PROGRAM .)
    EQ              reduce using rule 33 (var -> PROGRAM .)
    LTE             reduce using rule 33 (var -> PROGRAM .)
    GTE             reduce using rule 33 (var -> PROGRAM .)
    LT              reduce using rule 33 (var -> PROGRAM .)
    GT              reduce using rule 33 (var -> PROGRAM .)
    OR              reduce using rule 33 (var -> PROGRAM .)
    AND             reduce using rule 33 (var -> PROGRAM .)
    TO              reduce using rule 33 (var -> PROGRAM .)
    DO              reduce using rule 33 (var -> PROGRAM .)


state 46

    (34) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> ID . LBRACKET CTEINT RBRACKET
    (36) var -> ID .
    LBRACKET        shift and go to state 52
    COMMA           reduce using rule 36 (var -> ID .)
    SEMICOLON       reduce using rule 36 (var -> ID .)
    ASSIGN          reduce using rule 36 (var -> ID .)
    RPAREN          reduce using rule 36 (var -> ID .)


state 47

    (3) main_block -> MAIN changecontext . LPAREN RPAREN declareblock
    LPAREN          shift and go to state 53


state 48

    (42) typefunc -> type ID . changecontext LPAREN params RPAREN returnblock
    (125) changecontext -> .
    LPAREN          reduce using rule 125 (changecontext -> .)

    changecontext                  shift and go to state 54

state 49

    (41) voidfunc -> VOID ID . changecontext LPAREN params RPAREN declareblock
    (125) changecontext -> .
    LPAREN          reduce using rule 125 (changecontext -> .)

    changecontext                  shift and go to state 55

state 50

    (11) decvar_line -> decvar_type decvar SEMICOLON . decvar_line
    (12) decvar_line -> decvar_type decvar SEMICOLON .
    (11) decvar_line -> . decvar_type decvar SEMICOLON decvar_line
    (12) decvar_line -> . decvar_type decvar SEMICOLON
    (13) decvar_type -> . type
    (114) type -> . BOOL
    (115) type -> . FLOAT
    (116) type -> . INT
    FUNC            reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    MAIN            reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    ID              reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    FROM            reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    DO              reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    WHILE           reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    INPUT           reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    PRINT           reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    IF              reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    RCURLY          reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    RETURN          reduce using rule 12 (decvar_line -> decvar_type decvar SEMICOLON .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    decvar_type                    shift and go to state 14
    decvar_line                    shift and go to state 56
    type                           shift and go to state 15

state 51

    (14) decvar -> var COMMA . decvar
    (14) decvar -> . var COMMA decvar
    (15) decvar -> . var
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45
    ID              shift and go to state 46

    var                            shift and go to state 27
    decvar                         shift and go to state 57

state 52

    (34) var -> ID LBRACKET . CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> ID LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 58


state 53

    (3) main_block -> MAIN changecontext LPAREN . RPAREN declareblock
    RPAREN          shift and go to state 59


state 54

    (42) typefunc -> type ID changecontext . LPAREN params RPAREN returnblock
    LPAREN          shift and go to state 60


state 55

    (41) voidfunc -> VOID ID changecontext . LPAREN params RPAREN declareblock
    LPAREN          shift and go to state 61


state 56

    (11) decvar_line -> decvar_type decvar SEMICOLON decvar_line .
    FUNC            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    MAIN            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    DO              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)


state 57

    (14) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 14 (decvar -> var COMMA decvar .)


state 58

    (34) var -> ID LBRACKET CTEINT . RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> ID LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 62


state 59

    (3) main_block -> MAIN changecontext LPAREN RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 64

    declareblock                   shift and go to state 63

state 60

    (42) typefunc -> type ID changecontext LPAREN . params RPAREN returnblock
    (43) params -> . empty
    (44) params -> . param params_aux
    (127) empty -> .
    (45) param -> . type ID
    (114) type -> . BOOL
    (115) type -> . FLOAT
    (116) type -> . INT
    RPAREN          reduce using rule 127 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    type                           shift and go to state 65
    params                         shift and go to state 66
    empty                          shift and go to state 67
    param                          shift and go to state 68

state 61

    (41) voidfunc -> VOID ID changecontext LPAREN . params RPAREN declareblock
    (43) params -> . empty
    (44) params -> . param params_aux
    (127) empty -> .
    (45) param -> . type ID
    (114) type -> . BOOL
    (115) type -> . FLOAT
    (116) type -> . INT
    RPAREN          reduce using rule 127 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    params                         shift and go to state 69
    empty                          shift and go to state 67
    param                          shift and go to state 68
    type                           shift and go to state 65

state 62

    (34) var -> ID LBRACKET CTEINT RBRACKET . LBRACKET CTEINT RBRACKET
    (35) var -> ID LBRACKET CTEINT RBRACKET .
    LBRACKET        shift and go to state 70
    COMMA           reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 35 (var -> ID LBRACKET CTEINT RBRACKET .)


state 63

    (3) main_block -> MAIN changecontext LPAREN RPAREN declareblock .
    $end            reduce using rule 3 (main_block -> MAIN changecontext LPAREN RPAREN declareblock .)


state 64

    (5) declareblock -> LCURLY . decvars blockcontent RCURLY
    (9) decvars -> . empty
    (10) decvars -> . VARS decvar_line
    (127) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)

    decvars                        shift and go to state 71
    empty                          shift and go to state 7

state 65

    (45) param -> type . ID
    ID              shift and go to state 72


state 66

    (42) typefunc -> type ID changecontext LPAREN params . RPAREN returnblock
    RPAREN          shift and go to state 73


state 67

    (43) params -> empty .
    RPAREN          reduce using rule 43 (params -> empty .)


state 68

    (44) params -> param . params_aux
    (46) params_aux -> . empty
    (47) params_aux -> . COMMA params
    (127) empty -> .
    COMMA           shift and go to state 76
    RPAREN          reduce using rule 127 (empty -> .)

    params_aux                     shift and go to state 74
    empty                          shift and go to state 75

state 69

    (41) voidfunc -> VOID ID changecontext LPAREN params . RPAREN declareblock
    RPAREN          shift and go to state 77


state 70

    (34) var -> ID LBRACKET CTEINT RBRACKET LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 78


state 71

    (5) declareblock -> LCURLY decvars . blockcontent RCURLY
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (127) empty -> .
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (87) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (93) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (92) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (97) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (101) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (106) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (107) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (94) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (96) assignment_var -> . ID
    RCURLY          reduce using rule 127 (empty -> .)
    ID              shift and go to state 90
    FROM            shift and go to state 91
    DO              shift and go to state 92
    WHILE           shift and go to state 93
    INPUT           shift and go to state 94
    PRINT           shift and go to state 95
    IF              shift and go to state 96

    blockcontent                   shift and go to state 79
    empty                          shift and go to state 80
    statute                        shift and go to state 81
    call                           shift and go to state 82
    forloop                        shift and go to state 83
    dowhileloop                    shift and go to state 84
    whileloop                      shift and go to state 85
    read                           shift and go to state 86
    write                          shift and go to state 87
    condition                      shift and go to state 88
    assignment                     shift and go to state 89
    assignment_var                 shift and go to state 97

state 72

    (45) param -> type ID .
    COMMA           reduce using rule 45 (param -> type ID .)
    RPAREN          reduce using rule 45 (param -> type ID .)


state 73

    (42) typefunc -> type ID changecontext LPAREN params RPAREN . returnblock
    (6) returnblock -> . LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
    LCURLY          shift and go to state 99

    returnblock                    shift and go to state 98

state 74

    (44) params -> param params_aux .
    RPAREN          reduce using rule 44 (params -> param params_aux .)


state 75

    (46) params_aux -> empty .
    RPAREN          reduce using rule 46 (params_aux -> empty .)


state 76

    (47) params_aux -> COMMA . params
    (43) params -> . empty
    (44) params -> . param params_aux
    (127) empty -> .
    (45) param -> . type ID
    (114) type -> . BOOL
    (115) type -> . FLOAT
    (116) type -> . INT
    RPAREN          reduce using rule 127 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    params                         shift and go to state 100
    empty                          shift and go to state 67
    param                          shift and go to state 68
    type                           shift and go to state 65

state 77

    (41) voidfunc -> VOID ID changecontext LPAREN params RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 64

    declareblock                   shift and go to state 101

state 78

    (34) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 102


state 79

    (5) declareblock -> LCURLY decvars blockcontent . RCURLY
    RCURLY          shift and go to state 103


state 80

    (7) blockcontent -> empty .
    RCURLY          reduce using rule 7 (blockcontent -> empty .)
    RETURN          reduce using rule 7 (blockcontent -> empty .)


state 81

    (8) blockcontent -> statute . blockcontent
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (127) empty -> .
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (87) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (93) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (92) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (97) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (101) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (106) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (107) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (94) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (96) assignment_var -> . ID
    RCURLY          reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    ID              shift and go to state 90
    FROM            shift and go to state 91
    DO              shift and go to state 92
    WHILE           shift and go to state 93
    INPUT           shift and go to state 94
    PRINT           shift and go to state 95
    IF              shift and go to state 96

    statute                        shift and go to state 81
    blockcontent                   shift and go to state 104
    empty                          shift and go to state 80
    call                           shift and go to state 82
    forloop                        shift and go to state 83
    dowhileloop                    shift and go to state 84
    whileloop                      shift and go to state 85
    read                           shift and go to state 86
    write                          shift and go to state 87
    condition                      shift and go to state 88
    assignment                     shift and go to state 89
    assignment_var                 shift and go to state 97

state 82

    (117) statute -> call .
    ID              reduce using rule 117 (statute -> call .)
    FROM            reduce using rule 117 (statute -> call .)
    DO              reduce using rule 117 (statute -> call .)
    WHILE           reduce using rule 117 (statute -> call .)
    INPUT           reduce using rule 117 (statute -> call .)
    PRINT           reduce using rule 117 (statute -> call .)
    IF              reduce using rule 117 (statute -> call .)
    RCURLY          reduce using rule 117 (statute -> call .)
    RETURN          reduce using rule 117 (statute -> call .)


state 83

    (118) statute -> forloop .
    ID              reduce using rule 118 (statute -> forloop .)
    FROM            reduce using rule 118 (statute -> forloop .)
    DO              reduce using rule 118 (statute -> forloop .)
    WHILE           reduce using rule 118 (statute -> forloop .)
    INPUT           reduce using rule 118 (statute -> forloop .)
    PRINT           reduce using rule 118 (statute -> forloop .)
    IF              reduce using rule 118 (statute -> forloop .)
    RCURLY          reduce using rule 118 (statute -> forloop .)
    RETURN          reduce using rule 118 (statute -> forloop .)


state 84

    (119) statute -> dowhileloop .
    ID              reduce using rule 119 (statute -> dowhileloop .)
    FROM            reduce using rule 119 (statute -> dowhileloop .)
    DO              reduce using rule 119 (statute -> dowhileloop .)
    WHILE           reduce using rule 119 (statute -> dowhileloop .)
    INPUT           reduce using rule 119 (statute -> dowhileloop .)
    PRINT           reduce using rule 119 (statute -> dowhileloop .)
    IF              reduce using rule 119 (statute -> dowhileloop .)
    RCURLY          reduce using rule 119 (statute -> dowhileloop .)
    RETURN          reduce using rule 119 (statute -> dowhileloop .)


state 85

    (120) statute -> whileloop .
    ID              reduce using rule 120 (statute -> whileloop .)
    FROM            reduce using rule 120 (statute -> whileloop .)
    DO              reduce using rule 120 (statute -> whileloop .)
    WHILE           reduce using rule 120 (statute -> whileloop .)
    INPUT           reduce using rule 120 (statute -> whileloop .)
    PRINT           reduce using rule 120 (statute -> whileloop .)
    IF              reduce using rule 120 (statute -> whileloop .)
    RCURLY          reduce using rule 120 (statute -> whileloop .)
    RETURN          reduce using rule 120 (statute -> whileloop .)


state 86

    (121) statute -> read .
    ID              reduce using rule 121 (statute -> read .)
    FROM            reduce using rule 121 (statute -> read .)
    DO              reduce using rule 121 (statute -> read .)
    WHILE           reduce using rule 121 (statute -> read .)
    INPUT           reduce using rule 121 (statute -> read .)
    PRINT           reduce using rule 121 (statute -> read .)
    IF              reduce using rule 121 (statute -> read .)
    RCURLY          reduce using rule 121 (statute -> read .)
    RETURN          reduce using rule 121 (statute -> read .)


state 87

    (122) statute -> write .
    ID              reduce using rule 122 (statute -> write .)
    FROM            reduce using rule 122 (statute -> write .)
    DO              reduce using rule 122 (statute -> write .)
    WHILE           reduce using rule 122 (statute -> write .)
    INPUT           reduce using rule 122 (statute -> write .)
    PRINT           reduce using rule 122 (statute -> write .)
    IF              reduce using rule 122 (statute -> write .)
    RCURLY          reduce using rule 122 (statute -> write .)
    RETURN          reduce using rule 122 (statute -> write .)


state 88

    (123) statute -> condition .
    ID              reduce using rule 123 (statute -> condition .)
    FROM            reduce using rule 123 (statute -> condition .)
    DO              reduce using rule 123 (statute -> condition .)
    WHILE           reduce using rule 123 (statute -> condition .)
    INPUT           reduce using rule 123 (statute -> condition .)
    PRINT           reduce using rule 123 (statute -> condition .)
    IF              reduce using rule 123 (statute -> condition .)
    RCURLY          reduce using rule 123 (statute -> condition .)
    RETURN          reduce using rule 123 (statute -> condition .)


state 89

    (124) statute -> assignment .
    ID              reduce using rule 124 (statute -> assignment .)
    FROM            reduce using rule 124 (statute -> assignment .)
    DO              reduce using rule 124 (statute -> assignment .)
    WHILE           reduce using rule 124 (statute -> assignment .)
    INPUT           reduce using rule 124 (statute -> assignment .)
    PRINT           reduce using rule 124 (statute -> assignment .)
    IF              reduce using rule 124 (statute -> assignment .)
    RCURLY          reduce using rule 124 (statute -> assignment .)
    RETURN          reduce using rule 124 (statute -> assignment .)


state 90

    (48) call -> ID . generate_era LPAREN callvalues RPAREN
    (96) assignment_var -> ID .
    (49) generate_era -> .
    ASSIGN          reduce using rule 96 (assignment_var -> ID .)
    LPAREN          reduce using rule 49 (generate_era -> .)

    generate_era                   shift and go to state 105

state 91

    (87) forloop -> FROM . forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (88) forloopcontrolvar -> . var
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45
    ID              shift and go to state 46

    forloopcontrolvar              shift and go to state 106
    var                            shift and go to state 107

state 92

    (93) dowhileloop -> DO . saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (109) saveposition -> .
    LCURLY          reduce using rule 109 (saveposition -> .)

    saveposition                   shift and go to state 108

state 93

    (92) whileloop -> WHILE . saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (109) saveposition -> .
    LPAREN          reduce using rule 109 (saveposition -> .)

    saveposition                   shift and go to state 109

state 94

    (97) read -> INPUT . LPAREN readaux RPAREN SEMICOLON
    LPAREN          shift and go to state 110


state 95

    (101) write -> PRINT . LPAREN writeaux RPAREN SEMICOLON
    LPAREN          shift and go to state 111


state 96

    (106) condition -> IF . LPAREN super_exp RPAREN openjumpslot block filljumps
    (107) condition -> IF . LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    LPAREN          shift and go to state 112


state 97

    (94) assignment -> assignment_var . assignment_sign expression SEMICOLON
    (95) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 114

    assignment_sign                shift and go to state 113

state 98

    (42) typefunc -> type ID changecontext LPAREN params RPAREN returnblock .
    FUNC            reduce using rule 42 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)
    MAIN            reduce using rule 42 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)


state 99

    (6) returnblock -> LCURLY . decvars blockcontent RETURN exp SEMICOLON RCURLY
    (9) decvars -> . empty
    (10) decvars -> . VARS decvar_line
    (127) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)

    decvars                        shift and go to state 115
    empty                          shift and go to state 7

state 100

    (47) params_aux -> COMMA params .
    RPAREN          reduce using rule 47 (params_aux -> COMMA params .)


state 101

    (41) voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock .
    FUNC            reduce using rule 41 (voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock .)
    MAIN            reduce using rule 41 (voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock .)


state 102

    (34) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .
    COMMA           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)


state 103

    (5) declareblock -> LCURLY decvars blockcontent RCURLY .
    $end            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    FUNC            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    MAIN            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)


state 104

    (8) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 8 (blockcontent -> statute blockcontent .)
    RETURN          reduce using rule 8 (blockcontent -> statute blockcontent .)


state 105

    (48) call -> ID generate_era . LPAREN callvalues RPAREN
    LPAREN          shift and go to state 116


state 106

    (87) forloop -> FROM forloopcontrolvar . assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (95) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 114

    assignment_sign                shift and go to state 117

state 107

    (88) forloopcontrolvar -> var .
    ASSIGN          reduce using rule 88 (forloopcontrolvar -> var .)


state 108

    (93) dowhileloop -> DO saveposition . block WHILE LPAREN expression RPAREN openjumpslot
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 119

    block                          shift and go to state 118

state 109

    (92) whileloop -> WHILE saveposition . LPAREN expression RPAREN openjumpslot block filljumps
    LPAREN          shift and go to state 120


state 110

    (97) read -> INPUT LPAREN . readaux RPAREN SEMICOLON
    (98) readaux -> . readvalue COMMA readaux
    (99) readaux -> . readvalue
    (100) readvalue -> . var
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45
    ID              shift and go to state 46

    readaux                        shift and go to state 121
    readvalue                      shift and go to state 122
    var                            shift and go to state 123

state 111

    (101) write -> PRINT LPAREN . writeaux RPAREN SEMICOLON
    (102) writeaux -> . writevalues
    (103) writeaux -> . writevalues COMMA writeaux
    (104) writevalues -> . CTESTRING
    (105) writevalues -> . super_exp
    (56) super_exp -> . expression super_exp_quadgen super_exp_aux
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    CTESTRING       shift and go to state 127
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    writeaux                       shift and go to state 125
    writevalues                    shift and go to state 126
    super_exp                      shift and go to state 128
    expression                     shift and go to state 129
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 112

    (106) condition -> IF LPAREN . super_exp RPAREN openjumpslot block filljumps
    (107) condition -> IF LPAREN . super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (56) super_exp -> . expression super_exp_quadgen super_exp_aux
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    super_exp                      shift and go to state 140
    expression                     shift and go to state 129
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 113

    (94) assignment -> assignment_var assignment_sign . expression SEMICOLON
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    expression                     shift and go to state 141
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 114

    (95) assignment_sign -> ASSIGN .
    LPAREN          reduce using rule 95 (assignment_sign -> ASSIGN .)
    CTEBOOL         reduce using rule 95 (assignment_sign -> ASSIGN .)
    CTEFLOAT        reduce using rule 95 (assignment_sign -> ASSIGN .)
    CTEINT          reduce using rule 95 (assignment_sign -> ASSIGN .)
    ID              reduce using rule 95 (assignment_sign -> ASSIGN .)
    BOOL            reduce using rule 95 (assignment_sign -> ASSIGN .)
    FLOAT           reduce using rule 95 (assignment_sign -> ASSIGN .)
    INT             reduce using rule 95 (assignment_sign -> ASSIGN .)
    ELSE            reduce using rule 95 (assignment_sign -> ASSIGN .)
    IF              reduce using rule 95 (assignment_sign -> ASSIGN .)
    PRINT           reduce using rule 95 (assignment_sign -> ASSIGN .)
    INPUT           reduce using rule 95 (assignment_sign -> ASSIGN .)
    WHILE           reduce using rule 95 (assignment_sign -> ASSIGN .)
    DO              reduce using rule 95 (assignment_sign -> ASSIGN .)
    BY              reduce using rule 95 (assignment_sign -> ASSIGN .)
    TO              reduce using rule 95 (assignment_sign -> ASSIGN .)
    FROM            reduce using rule 95 (assignment_sign -> ASSIGN .)
    VOID            reduce using rule 95 (assignment_sign -> ASSIGN .)
    RETURN          reduce using rule 95 (assignment_sign -> ASSIGN .)
    FUNC            reduce using rule 95 (assignment_sign -> ASSIGN .)
    MAIN            reduce using rule 95 (assignment_sign -> ASSIGN .)
    VARS            reduce using rule 95 (assignment_sign -> ASSIGN .)
    PROGRAM         reduce using rule 95 (assignment_sign -> ASSIGN .)


state 115

    (6) returnblock -> LCURLY decvars . blockcontent RETURN exp SEMICOLON RCURLY
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (127) empty -> .
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (87) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (93) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (92) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (97) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (101) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (106) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (107) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (94) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (96) assignment_var -> . ID
    RETURN          reduce using rule 127 (empty -> .)
    ID              shift and go to state 90
    FROM            shift and go to state 91
    DO              shift and go to state 92
    WHILE           shift and go to state 93
    INPUT           shift and go to state 94
    PRINT           shift and go to state 95
    IF              shift and go to state 96

    blockcontent                   shift and go to state 142
    empty                          shift and go to state 80
    statute                        shift and go to state 81
    call                           shift and go to state 82
    forloop                        shift and go to state 83
    dowhileloop                    shift and go to state 84
    whileloop                      shift and go to state 85
    read                           shift and go to state 86
    write                          shift and go to state 87
    condition                      shift and go to state 88
    assignment                     shift and go to state 89
    assignment_var                 shift and go to state 97

state 116

    (48) call -> ID generate_era LPAREN . callvalues RPAREN
    (52) callvalues -> . exp generate_param callvalues_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    callvalues                     shift and go to state 143
    exp                            shift and go to state 144
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 117

    (87) forloop -> FROM forloopcontrolvar assignment_sign . expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    expression                     shift and go to state 145
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 118

    (93) dowhileloop -> DO saveposition block . WHILE LPAREN expression RPAREN openjumpslot
    WHILE           shift and go to state 146


state 119

    (4) block -> LCURLY . blockcontent RCURLY
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (127) empty -> .
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (87) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (93) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (92) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (97) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (101) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (106) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (107) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (94) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (96) assignment_var -> . ID
    RCURLY          reduce using rule 127 (empty -> .)
    ID              shift and go to state 90
    FROM            shift and go to state 91
    DO              shift and go to state 92
    WHILE           shift and go to state 93
    INPUT           shift and go to state 94
    PRINT           shift and go to state 95
    IF              shift and go to state 96

    blockcontent                   shift and go to state 147
    empty                          shift and go to state 80
    statute                        shift and go to state 81
    call                           shift and go to state 82
    forloop                        shift and go to state 83
    dowhileloop                    shift and go to state 84
    whileloop                      shift and go to state 85
    read                           shift and go to state 86
    write                          shift and go to state 87
    condition                      shift and go to state 88
    assignment                     shift and go to state 89
    assignment_var                 shift and go to state 97

state 120

    (92) whileloop -> WHILE saveposition LPAREN . expression RPAREN openjumpslot block filljumps
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    expression                     shift and go to state 148
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 121

    (97) read -> INPUT LPAREN readaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 149


state 122

    (98) readaux -> readvalue . COMMA readaux
    (99) readaux -> readvalue .
    COMMA           shift and go to state 150
    RPAREN          reduce using rule 99 (readaux -> readvalue .)


state 123

    (100) readvalue -> var .
    COMMA           reduce using rule 100 (readvalue -> var .)
    RPAREN          reduce using rule 100 (readvalue -> var .)


state 124

    (82) factor -> LPAREN . fakefloor super_exp RPAREN
    (86) fakefloor -> .
    LPAREN          reduce using rule 86 (fakefloor -> .)
    CTEBOOL         reduce using rule 86 (fakefloor -> .)
    CTEFLOAT        reduce using rule 86 (fakefloor -> .)
    CTEINT          reduce using rule 86 (fakefloor -> .)
    ID              reduce using rule 86 (fakefloor -> .)
    BOOL            reduce using rule 86 (fakefloor -> .)
    FLOAT           reduce using rule 86 (fakefloor -> .)
    INT             reduce using rule 86 (fakefloor -> .)
    ELSE            reduce using rule 86 (fakefloor -> .)
    IF              reduce using rule 86 (fakefloor -> .)
    PRINT           reduce using rule 86 (fakefloor -> .)
    INPUT           reduce using rule 86 (fakefloor -> .)
    WHILE           reduce using rule 86 (fakefloor -> .)
    DO              reduce using rule 86 (fakefloor -> .)
    BY              reduce using rule 86 (fakefloor -> .)
    TO              reduce using rule 86 (fakefloor -> .)
    FROM            reduce using rule 86 (fakefloor -> .)
    VOID            reduce using rule 86 (fakefloor -> .)
    RETURN          reduce using rule 86 (fakefloor -> .)
    FUNC            reduce using rule 86 (fakefloor -> .)
    MAIN            reduce using rule 86 (fakefloor -> .)
    VARS            reduce using rule 86 (fakefloor -> .)
    PROGRAM         reduce using rule 86 (fakefloor -> .)

    fakefloor                      shift and go to state 151

state 125

    (101) write -> PRINT LPAREN writeaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 152


state 126

    (102) writeaux -> writevalues .
    (103) writeaux -> writevalues . COMMA writeaux
    RPAREN          reduce using rule 102 (writeaux -> writevalues .)
    COMMA           shift and go to state 153


state 127

    (104) writevalues -> CTESTRING .
    COMMA           reduce using rule 104 (writevalues -> CTESTRING .)
    RPAREN          reduce using rule 104 (writevalues -> CTESTRING .)


state 128

    (105) writevalues -> super_exp .
    COMMA           reduce using rule 105 (writevalues -> super_exp .)
    RPAREN          reduce using rule 105 (writevalues -> super_exp .)


state 129

    (56) super_exp -> expression . super_exp_quadgen super_exp_aux
    (59) super_exp_quadgen -> .
    OR              reduce using rule 59 (super_exp_quadgen -> .)
    AND             reduce using rule 59 (super_exp_quadgen -> .)
    COMMA           reduce using rule 59 (super_exp_quadgen -> .)
    RPAREN          reduce using rule 59 (super_exp_quadgen -> .)

    super_exp_quadgen              shift and go to state 154

state 130

    (62) expression -> exp . expression_quadgen expression_aux
    (69) expression_quadgen -> .
    NEQ             reduce using rule 69 (expression_quadgen -> .)
    EQ              reduce using rule 69 (expression_quadgen -> .)
    LTE             reduce using rule 69 (expression_quadgen -> .)
    GTE             reduce using rule 69 (expression_quadgen -> .)
    LT              reduce using rule 69 (expression_quadgen -> .)
    GT              reduce using rule 69 (expression_quadgen -> .)
    OR              reduce using rule 69 (expression_quadgen -> .)
    AND             reduce using rule 69 (expression_quadgen -> .)
    COMMA           reduce using rule 69 (expression_quadgen -> .)
    RPAREN          reduce using rule 69 (expression_quadgen -> .)
    SEMICOLON       reduce using rule 69 (expression_quadgen -> .)
    TO              reduce using rule 69 (expression_quadgen -> .)
    DO              reduce using rule 69 (expression_quadgen -> .)

    expression_quadgen             shift and go to state 155

state 131

    (72) exp -> term . exp_quadgen exp_aux
    (75) exp_quadgen -> .
    MINUS           reduce using rule 75 (exp_quadgen -> .)
    PLUS            reduce using rule 75 (exp_quadgen -> .)
    NEQ             reduce using rule 75 (exp_quadgen -> .)
    EQ              reduce using rule 75 (exp_quadgen -> .)
    LTE             reduce using rule 75 (exp_quadgen -> .)
    GTE             reduce using rule 75 (exp_quadgen -> .)
    LT              reduce using rule 75 (exp_quadgen -> .)
    GT              reduce using rule 75 (exp_quadgen -> .)
    OR              reduce using rule 75 (exp_quadgen -> .)
    AND             reduce using rule 75 (exp_quadgen -> .)
    COMMA           reduce using rule 75 (exp_quadgen -> .)
    RPAREN          reduce using rule 75 (exp_quadgen -> .)
    SEMICOLON       reduce using rule 75 (exp_quadgen -> .)
    TO              reduce using rule 75 (exp_quadgen -> .)
    DO              reduce using rule 75 (exp_quadgen -> .)

    exp_quadgen                    shift and go to state 156

state 132

    (78) term -> factor . term_quadgen term_aux
    (81) term_quadgen -> .
    DIVIDE          reduce using rule 81 (term_quadgen -> .)
    TIMES           reduce using rule 81 (term_quadgen -> .)
    MINUS           reduce using rule 81 (term_quadgen -> .)
    PLUS            reduce using rule 81 (term_quadgen -> .)
    NEQ             reduce using rule 81 (term_quadgen -> .)
    EQ              reduce using rule 81 (term_quadgen -> .)
    LTE             reduce using rule 81 (term_quadgen -> .)
    GTE             reduce using rule 81 (term_quadgen -> .)
    LT              reduce using rule 81 (term_quadgen -> .)
    GT              reduce using rule 81 (term_quadgen -> .)
    OR              reduce using rule 81 (term_quadgen -> .)
    AND             reduce using rule 81 (term_quadgen -> .)
    COMMA           reduce using rule 81 (term_quadgen -> .)
    RPAREN          reduce using rule 81 (term_quadgen -> .)
    SEMICOLON       reduce using rule 81 (term_quadgen -> .)
    TO              reduce using rule 81 (term_quadgen -> .)
    DO              reduce using rule 81 (term_quadgen -> .)

    term_quadgen                   shift and go to state 157

state 133

    (83) factor -> varcte .
    DIVIDE          reduce using rule 83 (factor -> varcte .)
    TIMES           reduce using rule 83 (factor -> varcte .)
    MINUS           reduce using rule 83 (factor -> varcte .)
    PLUS            reduce using rule 83 (factor -> varcte .)
    NEQ             reduce using rule 83 (factor -> varcte .)
    EQ              reduce using rule 83 (factor -> varcte .)
    LTE             reduce using rule 83 (factor -> varcte .)
    GTE             reduce using rule 83 (factor -> varcte .)
    LT              reduce using rule 83 (factor -> varcte .)
    GT              reduce using rule 83 (factor -> varcte .)
    OR              reduce using rule 83 (factor -> varcte .)
    AND             reduce using rule 83 (factor -> varcte .)
    COMMA           reduce using rule 83 (factor -> varcte .)
    RPAREN          reduce using rule 83 (factor -> varcte .)
    SEMICOLON       reduce using rule 83 (factor -> varcte .)
    TO              reduce using rule 83 (factor -> varcte .)
    DO              reduce using rule 83 (factor -> varcte .)


state 134

    (84) factor -> call .
    DIVIDE          reduce using rule 84 (factor -> call .)
    TIMES           reduce using rule 84 (factor -> call .)
    MINUS           reduce using rule 84 (factor -> call .)
    PLUS            reduce using rule 84 (factor -> call .)
    NEQ             reduce using rule 84 (factor -> call .)
    EQ              reduce using rule 84 (factor -> call .)
    LTE             reduce using rule 84 (factor -> call .)
    GTE             reduce using rule 84 (factor -> call .)
    LT              reduce using rule 84 (factor -> call .)
    GT              reduce using rule 84 (factor -> call .)
    OR              reduce using rule 84 (factor -> call .)
    AND             reduce using rule 84 (factor -> call .)
    COMMA           reduce using rule 84 (factor -> call .)
    RPAREN          reduce using rule 84 (factor -> call .)
    SEMICOLON       reduce using rule 84 (factor -> call .)
    TO              reduce using rule 84 (factor -> call .)
    DO              reduce using rule 84 (factor -> call .)


state 135

    (85) factor -> var .
    DIVIDE          reduce using rule 85 (factor -> var .)
    TIMES           reduce using rule 85 (factor -> var .)
    MINUS           reduce using rule 85 (factor -> var .)
    PLUS            reduce using rule 85 (factor -> var .)
    NEQ             reduce using rule 85 (factor -> var .)
    EQ              reduce using rule 85 (factor -> var .)
    LTE             reduce using rule 85 (factor -> var .)
    GTE             reduce using rule 85 (factor -> var .)
    LT              reduce using rule 85 (factor -> var .)
    GT              reduce using rule 85 (factor -> var .)
    OR              reduce using rule 85 (factor -> var .)
    AND             reduce using rule 85 (factor -> var .)
    COMMA           reduce using rule 85 (factor -> var .)
    RPAREN          reduce using rule 85 (factor -> var .)
    SEMICOLON       reduce using rule 85 (factor -> var .)
    TO              reduce using rule 85 (factor -> var .)
    DO              reduce using rule 85 (factor -> var .)


state 136

    (111) varcte -> CTEBOOL .
    DIVIDE          reduce using rule 111 (varcte -> CTEBOOL .)
    TIMES           reduce using rule 111 (varcte -> CTEBOOL .)
    MINUS           reduce using rule 111 (varcte -> CTEBOOL .)
    PLUS            reduce using rule 111 (varcte -> CTEBOOL .)
    NEQ             reduce using rule 111 (varcte -> CTEBOOL .)
    EQ              reduce using rule 111 (varcte -> CTEBOOL .)
    LTE             reduce using rule 111 (varcte -> CTEBOOL .)
    GTE             reduce using rule 111 (varcte -> CTEBOOL .)
    LT              reduce using rule 111 (varcte -> CTEBOOL .)
    GT              reduce using rule 111 (varcte -> CTEBOOL .)
    OR              reduce using rule 111 (varcte -> CTEBOOL .)
    AND             reduce using rule 111 (varcte -> CTEBOOL .)
    COMMA           reduce using rule 111 (varcte -> CTEBOOL .)
    RPAREN          reduce using rule 111 (varcte -> CTEBOOL .)
    SEMICOLON       reduce using rule 111 (varcte -> CTEBOOL .)
    TO              reduce using rule 111 (varcte -> CTEBOOL .)
    DO              reduce using rule 111 (varcte -> CTEBOOL .)


state 137

    (112) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 112 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 112 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 112 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 112 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 112 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 112 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 112 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 112 (varcte -> CTEFLOAT .)
    LT              reduce using rule 112 (varcte -> CTEFLOAT .)
    GT              reduce using rule 112 (varcte -> CTEFLOAT .)
    OR              reduce using rule 112 (varcte -> CTEFLOAT .)
    AND             reduce using rule 112 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 112 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 112 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 112 (varcte -> CTEFLOAT .)
    TO              reduce using rule 112 (varcte -> CTEFLOAT .)
    DO              reduce using rule 112 (varcte -> CTEFLOAT .)


state 138

    (113) varcte -> CTEINT .
    DIVIDE          reduce using rule 113 (varcte -> CTEINT .)
    TIMES           reduce using rule 113 (varcte -> CTEINT .)
    MINUS           reduce using rule 113 (varcte -> CTEINT .)
    PLUS            reduce using rule 113 (varcte -> CTEINT .)
    NEQ             reduce using rule 113 (varcte -> CTEINT .)
    EQ              reduce using rule 113 (varcte -> CTEINT .)
    LTE             reduce using rule 113 (varcte -> CTEINT .)
    GTE             reduce using rule 113 (varcte -> CTEINT .)
    LT              reduce using rule 113 (varcte -> CTEINT .)
    GT              reduce using rule 113 (varcte -> CTEINT .)
    OR              reduce using rule 113 (varcte -> CTEINT .)
    AND             reduce using rule 113 (varcte -> CTEINT .)
    COMMA           reduce using rule 113 (varcte -> CTEINT .)
    RPAREN          reduce using rule 113 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 113 (varcte -> CTEINT .)
    TO              reduce using rule 113 (varcte -> CTEINT .)
    DO              reduce using rule 113 (varcte -> CTEINT .)


state 139

    (48) call -> ID . generate_era LPAREN callvalues RPAREN
    (34) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> ID . LBRACKET CTEINT RBRACKET
    (36) var -> ID .
    (49) generate_era -> .
    LBRACKET        shift and go to state 52
    DIVIDE          reduce using rule 36 (var -> ID .)
    TIMES           reduce using rule 36 (var -> ID .)
    MINUS           reduce using rule 36 (var -> ID .)
    PLUS            reduce using rule 36 (var -> ID .)
    NEQ             reduce using rule 36 (var -> ID .)
    EQ              reduce using rule 36 (var -> ID .)
    LTE             reduce using rule 36 (var -> ID .)
    GTE             reduce using rule 36 (var -> ID .)
    LT              reduce using rule 36 (var -> ID .)
    GT              reduce using rule 36 (var -> ID .)
    OR              reduce using rule 36 (var -> ID .)
    AND             reduce using rule 36 (var -> ID .)
    COMMA           reduce using rule 36 (var -> ID .)
    RPAREN          reduce using rule 36 (var -> ID .)
    SEMICOLON       reduce using rule 36 (var -> ID .)
    TO              reduce using rule 36 (var -> ID .)
    DO              reduce using rule 36 (var -> ID .)
    LPAREN          reduce using rule 49 (generate_era -> .)

    generate_era                   shift and go to state 105

state 140

    (106) condition -> IF LPAREN super_exp . RPAREN openjumpslot block filljumps
    (107) condition -> IF LPAREN super_exp . RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    RPAREN          shift and go to state 158


state 141

    (94) assignment -> assignment_var assignment_sign expression . SEMICOLON
    SEMICOLON       shift and go to state 159


state 142

    (6) returnblock -> LCURLY decvars blockcontent . RETURN exp SEMICOLON RCURLY
    RETURN          shift and go to state 160


state 143

    (48) call -> ID generate_era LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 161


state 144

    (52) callvalues -> exp . generate_param callvalues_aux
    (53) generate_param -> .
    COMMA           reduce using rule 53 (generate_param -> .)
    RPAREN          reduce using rule 53 (generate_param -> .)

    generate_param                 shift and go to state 162

state 145

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression . validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (89) validatecontrolvar -> .
    TO              reduce using rule 89 (validatecontrolvar -> .)

    validatecontrolvar             shift and go to state 163

state 146

    (93) dowhileloop -> DO saveposition block WHILE . LPAREN expression RPAREN openjumpslot
    LPAREN          shift and go to state 164


state 147

    (4) block -> LCURLY blockcontent . RCURLY
    RCURLY          shift and go to state 165


state 148

    (92) whileloop -> WHILE saveposition LPAREN expression . RPAREN openjumpslot block filljumps
    RPAREN          shift and go to state 166


state 149

    (97) read -> INPUT LPAREN readaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 167


state 150

    (98) readaux -> readvalue COMMA . readaux
    (98) readaux -> . readvalue COMMA readaux
    (99) readaux -> . readvalue
    (100) readvalue -> . var
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45
    ID              shift and go to state 46

    readvalue                      shift and go to state 122
    readaux                        shift and go to state 168
    var                            shift and go to state 123

state 151

    (82) factor -> LPAREN fakefloor . super_exp RPAREN
    (56) super_exp -> . expression super_exp_quadgen super_exp_aux
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    super_exp                      shift and go to state 169
    expression                     shift and go to state 129
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 152

    (101) write -> PRINT LPAREN writeaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 170


state 153

    (103) writeaux -> writevalues COMMA . writeaux
    (102) writeaux -> . writevalues
    (103) writeaux -> . writevalues COMMA writeaux
    (104) writevalues -> . CTESTRING
    (105) writevalues -> . super_exp
    (56) super_exp -> . expression super_exp_quadgen super_exp_aux
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    CTESTRING       shift and go to state 127
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    writevalues                    shift and go to state 126
    writeaux                       shift and go to state 171
    super_exp                      shift and go to state 128
    expression                     shift and go to state 129
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 154

    (56) super_exp -> expression super_exp_quadgen . super_exp_aux
    (54) super_exp_aux -> . logic super_exp
    (55) super_exp_aux -> . empty
    (57) logic -> . OR
    (58) logic -> . AND
    (127) empty -> .
    OR              shift and go to state 175
    AND             shift and go to state 176
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    super_exp_aux                  shift and go to state 172
    logic                          shift and go to state 173
    empty                          shift and go to state 174

state 155

    (62) expression -> exp expression_quadgen . expression_aux
    (60) expression_aux -> . relation expression
    (61) expression_aux -> . empty
    (63) relation -> . NEQ
    (64) relation -> . EQ
    (65) relation -> . LTE
    (66) relation -> . GTE
    (67) relation -> . LT
    (68) relation -> . GT
    (127) empty -> .
    NEQ             shift and go to state 180
    EQ              shift and go to state 181
    LTE             shift and go to state 182
    GTE             shift and go to state 183
    LT              shift and go to state 184
    GT              shift and go to state 185
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)

    expression_aux                 shift and go to state 177
    relation                       shift and go to state 178
    empty                          shift and go to state 179

state 156

    (72) exp -> term exp_quadgen . exp_aux
    (70) exp_aux -> . exp_sign exp
    (71) exp_aux -> . empty
    (73) exp_sign -> . MINUS
    (74) exp_sign -> . PLUS
    (127) empty -> .
    MINUS           shift and go to state 189
    PLUS            shift and go to state 190
    NEQ             reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    LTE             reduce using rule 127 (empty -> .)
    GTE             reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)

    exp_aux                        shift and go to state 186
    exp_sign                       shift and go to state 187
    empty                          shift and go to state 188

state 157

    (78) term -> factor term_quadgen . term_aux
    (76) term_aux -> . term_sign term
    (77) term_aux -> . empty
    (79) term_sign -> . DIVIDE
    (80) term_sign -> . TIMES
    (127) empty -> .
    DIVIDE          shift and go to state 194
    TIMES           shift and go to state 195
    MINUS           reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    LTE             reduce using rule 127 (empty -> .)
    GTE             reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)

    term_aux                       shift and go to state 191
    term_sign                      shift and go to state 192
    empty                          shift and go to state 193

state 158

    (106) condition -> IF LPAREN super_exp RPAREN . openjumpslot block filljumps
    (107) condition -> IF LPAREN super_exp RPAREN . openjumpslot block ELSE filljumps openjumpslot block filljumps
    (108) openjumpslot -> .
    LCURLY          reduce using rule 108 (openjumpslot -> .)

    openjumpslot                   shift and go to state 196

state 159

    (94) assignment -> assignment_var assignment_sign expression SEMICOLON .
    ID              reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    FROM            reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    DO              reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    WHILE           reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    INPUT           reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    PRINT           reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    IF              reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    RCURLY          reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    RETURN          reduce using rule 94 (assignment -> assignment_var assignment_sign expression SEMICOLON .)


state 160

    (6) returnblock -> LCURLY decvars blockcontent RETURN . exp SEMICOLON RCURLY
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    exp                            shift and go to state 197
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 161

    (48) call -> ID generate_era LPAREN callvalues RPAREN .
    ID              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    FROM            reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    DO              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    IF              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RETURN          reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    DIVIDE          reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    EQ              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    LTE             reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    GTE             reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    LT              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    GT              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    OR              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    AND             reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)
    TO              reduce using rule 48 (call -> ID generate_era LPAREN callvalues RPAREN .)


state 162

    (52) callvalues -> exp generate_param . callvalues_aux
    (50) callvalues_aux -> . COMMA callvalues
    (51) callvalues_aux -> . empty
    (127) empty -> .
    COMMA           shift and go to state 199
    RPAREN          reduce using rule 127 (empty -> .)

    callvalues_aux                 shift and go to state 198
    empty                          shift and go to state 200

state 163

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar . TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    TO              shift and go to state 201


state 164

    (93) dowhileloop -> DO saveposition block WHILE LPAREN . expression RPAREN openjumpslot
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    expression                     shift and go to state 202
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 165

    (4) block -> LCURLY blockcontent RCURLY .
    WHILE           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ELSE            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ID              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    FROM            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    DO              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    INPUT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    PRINT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    IF              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RCURLY          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RETURN          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)


state 166

    (92) whileloop -> WHILE saveposition LPAREN expression RPAREN . openjumpslot block filljumps
    (108) openjumpslot -> .
    LCURLY          reduce using rule 108 (openjumpslot -> .)

    openjumpslot                   shift and go to state 203

state 167

    (97) read -> INPUT LPAREN readaux RPAREN SEMICOLON .
    ID              reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    FROM            reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    DO              reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    IF              reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    RETURN          reduce using rule 97 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)


state 168

    (98) readaux -> readvalue COMMA readaux .
    RPAREN          reduce using rule 98 (readaux -> readvalue COMMA readaux .)


state 169

    (82) factor -> LPAREN fakefloor super_exp . RPAREN
    RPAREN          shift and go to state 204


state 170

    (101) write -> PRINT LPAREN writeaux RPAREN SEMICOLON .
    ID              reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    FROM            reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    DO              reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    IF              reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    RETURN          reduce using rule 101 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)


state 171

    (103) writeaux -> writevalues COMMA writeaux .
    RPAREN          reduce using rule 103 (writeaux -> writevalues COMMA writeaux .)


state 172

    (56) super_exp -> expression super_exp_quadgen super_exp_aux .
    COMMA           reduce using rule 56 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RPAREN          reduce using rule 56 (super_exp -> expression super_exp_quadgen super_exp_aux .)


state 173

    (54) super_exp_aux -> logic . super_exp
    (56) super_exp -> . expression super_exp_quadgen super_exp_aux
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    super_exp                      shift and go to state 205
    expression                     shift and go to state 129
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 174

    (55) super_exp_aux -> empty .
    COMMA           reduce using rule 55 (super_exp_aux -> empty .)
    RPAREN          reduce using rule 55 (super_exp_aux -> empty .)


state 175

    (57) logic -> OR .
    LPAREN          reduce using rule 57 (logic -> OR .)
    CTEBOOL         reduce using rule 57 (logic -> OR .)
    CTEFLOAT        reduce using rule 57 (logic -> OR .)
    CTEINT          reduce using rule 57 (logic -> OR .)
    ID              reduce using rule 57 (logic -> OR .)
    BOOL            reduce using rule 57 (logic -> OR .)
    FLOAT           reduce using rule 57 (logic -> OR .)
    INT             reduce using rule 57 (logic -> OR .)
    ELSE            reduce using rule 57 (logic -> OR .)
    IF              reduce using rule 57 (logic -> OR .)
    PRINT           reduce using rule 57 (logic -> OR .)
    INPUT           reduce using rule 57 (logic -> OR .)
    WHILE           reduce using rule 57 (logic -> OR .)
    DO              reduce using rule 57 (logic -> OR .)
    BY              reduce using rule 57 (logic -> OR .)
    TO              reduce using rule 57 (logic -> OR .)
    FROM            reduce using rule 57 (logic -> OR .)
    VOID            reduce using rule 57 (logic -> OR .)
    RETURN          reduce using rule 57 (logic -> OR .)
    FUNC            reduce using rule 57 (logic -> OR .)
    MAIN            reduce using rule 57 (logic -> OR .)
    VARS            reduce using rule 57 (logic -> OR .)
    PROGRAM         reduce using rule 57 (logic -> OR .)


state 176

    (58) logic -> AND .
    LPAREN          reduce using rule 58 (logic -> AND .)
    CTEBOOL         reduce using rule 58 (logic -> AND .)
    CTEFLOAT        reduce using rule 58 (logic -> AND .)
    CTEINT          reduce using rule 58 (logic -> AND .)
    ID              reduce using rule 58 (logic -> AND .)
    BOOL            reduce using rule 58 (logic -> AND .)
    FLOAT           reduce using rule 58 (logic -> AND .)
    INT             reduce using rule 58 (logic -> AND .)
    ELSE            reduce using rule 58 (logic -> AND .)
    IF              reduce using rule 58 (logic -> AND .)
    PRINT           reduce using rule 58 (logic -> AND .)
    INPUT           reduce using rule 58 (logic -> AND .)
    WHILE           reduce using rule 58 (logic -> AND .)
    DO              reduce using rule 58 (logic -> AND .)
    BY              reduce using rule 58 (logic -> AND .)
    TO              reduce using rule 58 (logic -> AND .)
    FROM            reduce using rule 58 (logic -> AND .)
    VOID            reduce using rule 58 (logic -> AND .)
    RETURN          reduce using rule 58 (logic -> AND .)
    FUNC            reduce using rule 58 (logic -> AND .)
    MAIN            reduce using rule 58 (logic -> AND .)
    VARS            reduce using rule 58 (logic -> AND .)
    PROGRAM         reduce using rule 58 (logic -> AND .)


state 177

    (62) expression -> exp expression_quadgen expression_aux .
    OR              reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)
    AND             reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)
    COMMA           reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)
    RPAREN          reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)
    SEMICOLON       reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)
    TO              reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)
    DO              reduce using rule 62 (expression -> exp expression_quadgen expression_aux .)


state 178

    (60) expression_aux -> relation . expression
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    expression                     shift and go to state 206
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 179

    (61) expression_aux -> empty .
    OR              reduce using rule 61 (expression_aux -> empty .)
    AND             reduce using rule 61 (expression_aux -> empty .)
    COMMA           reduce using rule 61 (expression_aux -> empty .)
    RPAREN          reduce using rule 61 (expression_aux -> empty .)
    SEMICOLON       reduce using rule 61 (expression_aux -> empty .)
    TO              reduce using rule 61 (expression_aux -> empty .)
    DO              reduce using rule 61 (expression_aux -> empty .)


state 180

    (63) relation -> NEQ .
    LPAREN          reduce using rule 63 (relation -> NEQ .)
    CTEBOOL         reduce using rule 63 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 63 (relation -> NEQ .)
    CTEINT          reduce using rule 63 (relation -> NEQ .)
    ID              reduce using rule 63 (relation -> NEQ .)
    BOOL            reduce using rule 63 (relation -> NEQ .)
    FLOAT           reduce using rule 63 (relation -> NEQ .)
    INT             reduce using rule 63 (relation -> NEQ .)
    ELSE            reduce using rule 63 (relation -> NEQ .)
    IF              reduce using rule 63 (relation -> NEQ .)
    PRINT           reduce using rule 63 (relation -> NEQ .)
    INPUT           reduce using rule 63 (relation -> NEQ .)
    WHILE           reduce using rule 63 (relation -> NEQ .)
    DO              reduce using rule 63 (relation -> NEQ .)
    BY              reduce using rule 63 (relation -> NEQ .)
    TO              reduce using rule 63 (relation -> NEQ .)
    FROM            reduce using rule 63 (relation -> NEQ .)
    VOID            reduce using rule 63 (relation -> NEQ .)
    RETURN          reduce using rule 63 (relation -> NEQ .)
    FUNC            reduce using rule 63 (relation -> NEQ .)
    MAIN            reduce using rule 63 (relation -> NEQ .)
    VARS            reduce using rule 63 (relation -> NEQ .)
    PROGRAM         reduce using rule 63 (relation -> NEQ .)


state 181

    (64) relation -> EQ .
    LPAREN          reduce using rule 64 (relation -> EQ .)
    CTEBOOL         reduce using rule 64 (relation -> EQ .)
    CTEFLOAT        reduce using rule 64 (relation -> EQ .)
    CTEINT          reduce using rule 64 (relation -> EQ .)
    ID              reduce using rule 64 (relation -> EQ .)
    BOOL            reduce using rule 64 (relation -> EQ .)
    FLOAT           reduce using rule 64 (relation -> EQ .)
    INT             reduce using rule 64 (relation -> EQ .)
    ELSE            reduce using rule 64 (relation -> EQ .)
    IF              reduce using rule 64 (relation -> EQ .)
    PRINT           reduce using rule 64 (relation -> EQ .)
    INPUT           reduce using rule 64 (relation -> EQ .)
    WHILE           reduce using rule 64 (relation -> EQ .)
    DO              reduce using rule 64 (relation -> EQ .)
    BY              reduce using rule 64 (relation -> EQ .)
    TO              reduce using rule 64 (relation -> EQ .)
    FROM            reduce using rule 64 (relation -> EQ .)
    VOID            reduce using rule 64 (relation -> EQ .)
    RETURN          reduce using rule 64 (relation -> EQ .)
    FUNC            reduce using rule 64 (relation -> EQ .)
    MAIN            reduce using rule 64 (relation -> EQ .)
    VARS            reduce using rule 64 (relation -> EQ .)
    PROGRAM         reduce using rule 64 (relation -> EQ .)


state 182

    (65) relation -> LTE .
    LPAREN          reduce using rule 65 (relation -> LTE .)
    CTEBOOL         reduce using rule 65 (relation -> LTE .)
    CTEFLOAT        reduce using rule 65 (relation -> LTE .)
    CTEINT          reduce using rule 65 (relation -> LTE .)
    ID              reduce using rule 65 (relation -> LTE .)
    BOOL            reduce using rule 65 (relation -> LTE .)
    FLOAT           reduce using rule 65 (relation -> LTE .)
    INT             reduce using rule 65 (relation -> LTE .)
    ELSE            reduce using rule 65 (relation -> LTE .)
    IF              reduce using rule 65 (relation -> LTE .)
    PRINT           reduce using rule 65 (relation -> LTE .)
    INPUT           reduce using rule 65 (relation -> LTE .)
    WHILE           reduce using rule 65 (relation -> LTE .)
    DO              reduce using rule 65 (relation -> LTE .)
    BY              reduce using rule 65 (relation -> LTE .)
    TO              reduce using rule 65 (relation -> LTE .)
    FROM            reduce using rule 65 (relation -> LTE .)
    VOID            reduce using rule 65 (relation -> LTE .)
    RETURN          reduce using rule 65 (relation -> LTE .)
    FUNC            reduce using rule 65 (relation -> LTE .)
    MAIN            reduce using rule 65 (relation -> LTE .)
    VARS            reduce using rule 65 (relation -> LTE .)
    PROGRAM         reduce using rule 65 (relation -> LTE .)


state 183

    (66) relation -> GTE .
    LPAREN          reduce using rule 66 (relation -> GTE .)
    CTEBOOL         reduce using rule 66 (relation -> GTE .)
    CTEFLOAT        reduce using rule 66 (relation -> GTE .)
    CTEINT          reduce using rule 66 (relation -> GTE .)
    ID              reduce using rule 66 (relation -> GTE .)
    BOOL            reduce using rule 66 (relation -> GTE .)
    FLOAT           reduce using rule 66 (relation -> GTE .)
    INT             reduce using rule 66 (relation -> GTE .)
    ELSE            reduce using rule 66 (relation -> GTE .)
    IF              reduce using rule 66 (relation -> GTE .)
    PRINT           reduce using rule 66 (relation -> GTE .)
    INPUT           reduce using rule 66 (relation -> GTE .)
    WHILE           reduce using rule 66 (relation -> GTE .)
    DO              reduce using rule 66 (relation -> GTE .)
    BY              reduce using rule 66 (relation -> GTE .)
    TO              reduce using rule 66 (relation -> GTE .)
    FROM            reduce using rule 66 (relation -> GTE .)
    VOID            reduce using rule 66 (relation -> GTE .)
    RETURN          reduce using rule 66 (relation -> GTE .)
    FUNC            reduce using rule 66 (relation -> GTE .)
    MAIN            reduce using rule 66 (relation -> GTE .)
    VARS            reduce using rule 66 (relation -> GTE .)
    PROGRAM         reduce using rule 66 (relation -> GTE .)


state 184

    (67) relation -> LT .
    LPAREN          reduce using rule 67 (relation -> LT .)
    CTEBOOL         reduce using rule 67 (relation -> LT .)
    CTEFLOAT        reduce using rule 67 (relation -> LT .)
    CTEINT          reduce using rule 67 (relation -> LT .)
    ID              reduce using rule 67 (relation -> LT .)
    BOOL            reduce using rule 67 (relation -> LT .)
    FLOAT           reduce using rule 67 (relation -> LT .)
    INT             reduce using rule 67 (relation -> LT .)
    ELSE            reduce using rule 67 (relation -> LT .)
    IF              reduce using rule 67 (relation -> LT .)
    PRINT           reduce using rule 67 (relation -> LT .)
    INPUT           reduce using rule 67 (relation -> LT .)
    WHILE           reduce using rule 67 (relation -> LT .)
    DO              reduce using rule 67 (relation -> LT .)
    BY              reduce using rule 67 (relation -> LT .)
    TO              reduce using rule 67 (relation -> LT .)
    FROM            reduce using rule 67 (relation -> LT .)
    VOID            reduce using rule 67 (relation -> LT .)
    RETURN          reduce using rule 67 (relation -> LT .)
    FUNC            reduce using rule 67 (relation -> LT .)
    MAIN            reduce using rule 67 (relation -> LT .)
    VARS            reduce using rule 67 (relation -> LT .)
    PROGRAM         reduce using rule 67 (relation -> LT .)


state 185

    (68) relation -> GT .
    LPAREN          reduce using rule 68 (relation -> GT .)
    CTEBOOL         reduce using rule 68 (relation -> GT .)
    CTEFLOAT        reduce using rule 68 (relation -> GT .)
    CTEINT          reduce using rule 68 (relation -> GT .)
    ID              reduce using rule 68 (relation -> GT .)
    BOOL            reduce using rule 68 (relation -> GT .)
    FLOAT           reduce using rule 68 (relation -> GT .)
    INT             reduce using rule 68 (relation -> GT .)
    ELSE            reduce using rule 68 (relation -> GT .)
    IF              reduce using rule 68 (relation -> GT .)
    PRINT           reduce using rule 68 (relation -> GT .)
    INPUT           reduce using rule 68 (relation -> GT .)
    WHILE           reduce using rule 68 (relation -> GT .)
    DO              reduce using rule 68 (relation -> GT .)
    BY              reduce using rule 68 (relation -> GT .)
    TO              reduce using rule 68 (relation -> GT .)
    FROM            reduce using rule 68 (relation -> GT .)
    VOID            reduce using rule 68 (relation -> GT .)
    RETURN          reduce using rule 68 (relation -> GT .)
    FUNC            reduce using rule 68 (relation -> GT .)
    MAIN            reduce using rule 68 (relation -> GT .)
    VARS            reduce using rule 68 (relation -> GT .)
    PROGRAM         reduce using rule 68 (relation -> GT .)


state 186

    (72) exp -> term exp_quadgen exp_aux .
    NEQ             reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    EQ              reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    LTE             reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    GTE             reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    LT              reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    GT              reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    OR              reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    AND             reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    COMMA           reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    RPAREN          reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    SEMICOLON       reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    TO              reduce using rule 72 (exp -> term exp_quadgen exp_aux .)
    DO              reduce using rule 72 (exp -> term exp_quadgen exp_aux .)


state 187

    (70) exp_aux -> exp_sign . exp
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    exp                            shift and go to state 207
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 188

    (71) exp_aux -> empty .
    NEQ             reduce using rule 71 (exp_aux -> empty .)
    EQ              reduce using rule 71 (exp_aux -> empty .)
    LTE             reduce using rule 71 (exp_aux -> empty .)
    GTE             reduce using rule 71 (exp_aux -> empty .)
    LT              reduce using rule 71 (exp_aux -> empty .)
    GT              reduce using rule 71 (exp_aux -> empty .)
    OR              reduce using rule 71 (exp_aux -> empty .)
    AND             reduce using rule 71 (exp_aux -> empty .)
    COMMA           reduce using rule 71 (exp_aux -> empty .)
    RPAREN          reduce using rule 71 (exp_aux -> empty .)
    SEMICOLON       reduce using rule 71 (exp_aux -> empty .)
    TO              reduce using rule 71 (exp_aux -> empty .)
    DO              reduce using rule 71 (exp_aux -> empty .)


state 189

    (73) exp_sign -> MINUS .
    LPAREN          reduce using rule 73 (exp_sign -> MINUS .)
    CTEBOOL         reduce using rule 73 (exp_sign -> MINUS .)
    CTEFLOAT        reduce using rule 73 (exp_sign -> MINUS .)
    CTEINT          reduce using rule 73 (exp_sign -> MINUS .)
    ID              reduce using rule 73 (exp_sign -> MINUS .)
    BOOL            reduce using rule 73 (exp_sign -> MINUS .)
    FLOAT           reduce using rule 73 (exp_sign -> MINUS .)
    INT             reduce using rule 73 (exp_sign -> MINUS .)
    ELSE            reduce using rule 73 (exp_sign -> MINUS .)
    IF              reduce using rule 73 (exp_sign -> MINUS .)
    PRINT           reduce using rule 73 (exp_sign -> MINUS .)
    INPUT           reduce using rule 73 (exp_sign -> MINUS .)
    WHILE           reduce using rule 73 (exp_sign -> MINUS .)
    DO              reduce using rule 73 (exp_sign -> MINUS .)
    BY              reduce using rule 73 (exp_sign -> MINUS .)
    TO              reduce using rule 73 (exp_sign -> MINUS .)
    FROM            reduce using rule 73 (exp_sign -> MINUS .)
    VOID            reduce using rule 73 (exp_sign -> MINUS .)
    RETURN          reduce using rule 73 (exp_sign -> MINUS .)
    FUNC            reduce using rule 73 (exp_sign -> MINUS .)
    MAIN            reduce using rule 73 (exp_sign -> MINUS .)
    VARS            reduce using rule 73 (exp_sign -> MINUS .)
    PROGRAM         reduce using rule 73 (exp_sign -> MINUS .)


state 190

    (74) exp_sign -> PLUS .
    LPAREN          reduce using rule 74 (exp_sign -> PLUS .)
    CTEBOOL         reduce using rule 74 (exp_sign -> PLUS .)
    CTEFLOAT        reduce using rule 74 (exp_sign -> PLUS .)
    CTEINT          reduce using rule 74 (exp_sign -> PLUS .)
    ID              reduce using rule 74 (exp_sign -> PLUS .)
    BOOL            reduce using rule 74 (exp_sign -> PLUS .)
    FLOAT           reduce using rule 74 (exp_sign -> PLUS .)
    INT             reduce using rule 74 (exp_sign -> PLUS .)
    ELSE            reduce using rule 74 (exp_sign -> PLUS .)
    IF              reduce using rule 74 (exp_sign -> PLUS .)
    PRINT           reduce using rule 74 (exp_sign -> PLUS .)
    INPUT           reduce using rule 74 (exp_sign -> PLUS .)
    WHILE           reduce using rule 74 (exp_sign -> PLUS .)
    DO              reduce using rule 74 (exp_sign -> PLUS .)
    BY              reduce using rule 74 (exp_sign -> PLUS .)
    TO              reduce using rule 74 (exp_sign -> PLUS .)
    FROM            reduce using rule 74 (exp_sign -> PLUS .)
    VOID            reduce using rule 74 (exp_sign -> PLUS .)
    RETURN          reduce using rule 74 (exp_sign -> PLUS .)
    FUNC            reduce using rule 74 (exp_sign -> PLUS .)
    MAIN            reduce using rule 74 (exp_sign -> PLUS .)
    VARS            reduce using rule 74 (exp_sign -> PLUS .)
    PROGRAM         reduce using rule 74 (exp_sign -> PLUS .)


state 191

    (78) term -> factor term_quadgen term_aux .
    MINUS           reduce using rule 78 (term -> factor term_quadgen term_aux .)
    PLUS            reduce using rule 78 (term -> factor term_quadgen term_aux .)
    NEQ             reduce using rule 78 (term -> factor term_quadgen term_aux .)
    EQ              reduce using rule 78 (term -> factor term_quadgen term_aux .)
    LTE             reduce using rule 78 (term -> factor term_quadgen term_aux .)
    GTE             reduce using rule 78 (term -> factor term_quadgen term_aux .)
    LT              reduce using rule 78 (term -> factor term_quadgen term_aux .)
    GT              reduce using rule 78 (term -> factor term_quadgen term_aux .)
    OR              reduce using rule 78 (term -> factor term_quadgen term_aux .)
    AND             reduce using rule 78 (term -> factor term_quadgen term_aux .)
    COMMA           reduce using rule 78 (term -> factor term_quadgen term_aux .)
    RPAREN          reduce using rule 78 (term -> factor term_quadgen term_aux .)
    SEMICOLON       reduce using rule 78 (term -> factor term_quadgen term_aux .)
    TO              reduce using rule 78 (term -> factor term_quadgen term_aux .)
    DO              reduce using rule 78 (term -> factor term_quadgen term_aux .)


state 192

    (76) term_aux -> term_sign . term
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    term                           shift and go to state 208
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 193

    (77) term_aux -> empty .
    MINUS           reduce using rule 77 (term_aux -> empty .)
    PLUS            reduce using rule 77 (term_aux -> empty .)
    NEQ             reduce using rule 77 (term_aux -> empty .)
    EQ              reduce using rule 77 (term_aux -> empty .)
    LTE             reduce using rule 77 (term_aux -> empty .)
    GTE             reduce using rule 77 (term_aux -> empty .)
    LT              reduce using rule 77 (term_aux -> empty .)
    GT              reduce using rule 77 (term_aux -> empty .)
    OR              reduce using rule 77 (term_aux -> empty .)
    AND             reduce using rule 77 (term_aux -> empty .)
    COMMA           reduce using rule 77 (term_aux -> empty .)
    RPAREN          reduce using rule 77 (term_aux -> empty .)
    SEMICOLON       reduce using rule 77 (term_aux -> empty .)
    TO              reduce using rule 77 (term_aux -> empty .)
    DO              reduce using rule 77 (term_aux -> empty .)


state 194

    (79) term_sign -> DIVIDE .
    LPAREN          reduce using rule 79 (term_sign -> DIVIDE .)
    CTEBOOL         reduce using rule 79 (term_sign -> DIVIDE .)
    CTEFLOAT        reduce using rule 79 (term_sign -> DIVIDE .)
    CTEINT          reduce using rule 79 (term_sign -> DIVIDE .)
    ID              reduce using rule 79 (term_sign -> DIVIDE .)
    BOOL            reduce using rule 79 (term_sign -> DIVIDE .)
    FLOAT           reduce using rule 79 (term_sign -> DIVIDE .)
    INT             reduce using rule 79 (term_sign -> DIVIDE .)
    ELSE            reduce using rule 79 (term_sign -> DIVIDE .)
    IF              reduce using rule 79 (term_sign -> DIVIDE .)
    PRINT           reduce using rule 79 (term_sign -> DIVIDE .)
    INPUT           reduce using rule 79 (term_sign -> DIVIDE .)
    WHILE           reduce using rule 79 (term_sign -> DIVIDE .)
    DO              reduce using rule 79 (term_sign -> DIVIDE .)
    BY              reduce using rule 79 (term_sign -> DIVIDE .)
    TO              reduce using rule 79 (term_sign -> DIVIDE .)
    FROM            reduce using rule 79 (term_sign -> DIVIDE .)
    VOID            reduce using rule 79 (term_sign -> DIVIDE .)
    RETURN          reduce using rule 79 (term_sign -> DIVIDE .)
    FUNC            reduce using rule 79 (term_sign -> DIVIDE .)
    MAIN            reduce using rule 79 (term_sign -> DIVIDE .)
    VARS            reduce using rule 79 (term_sign -> DIVIDE .)
    PROGRAM         reduce using rule 79 (term_sign -> DIVIDE .)


state 195

    (80) term_sign -> TIMES .
    LPAREN          reduce using rule 80 (term_sign -> TIMES .)
    CTEBOOL         reduce using rule 80 (term_sign -> TIMES .)
    CTEFLOAT        reduce using rule 80 (term_sign -> TIMES .)
    CTEINT          reduce using rule 80 (term_sign -> TIMES .)
    ID              reduce using rule 80 (term_sign -> TIMES .)
    BOOL            reduce using rule 80 (term_sign -> TIMES .)
    FLOAT           reduce using rule 80 (term_sign -> TIMES .)
    INT             reduce using rule 80 (term_sign -> TIMES .)
    ELSE            reduce using rule 80 (term_sign -> TIMES .)
    IF              reduce using rule 80 (term_sign -> TIMES .)
    PRINT           reduce using rule 80 (term_sign -> TIMES .)
    INPUT           reduce using rule 80 (term_sign -> TIMES .)
    WHILE           reduce using rule 80 (term_sign -> TIMES .)
    DO              reduce using rule 80 (term_sign -> TIMES .)
    BY              reduce using rule 80 (term_sign -> TIMES .)
    TO              reduce using rule 80 (term_sign -> TIMES .)
    FROM            reduce using rule 80 (term_sign -> TIMES .)
    VOID            reduce using rule 80 (term_sign -> TIMES .)
    RETURN          reduce using rule 80 (term_sign -> TIMES .)
    FUNC            reduce using rule 80 (term_sign -> TIMES .)
    MAIN            reduce using rule 80 (term_sign -> TIMES .)
    VARS            reduce using rule 80 (term_sign -> TIMES .)
    PROGRAM         reduce using rule 80 (term_sign -> TIMES .)


state 196

    (106) condition -> IF LPAREN super_exp RPAREN openjumpslot . block filljumps
    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot . block ELSE filljumps openjumpslot block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 119

    block                          shift and go to state 209

state 197

    (6) returnblock -> LCURLY decvars blockcontent RETURN exp . SEMICOLON RCURLY
    SEMICOLON       shift and go to state 210


state 198

    (52) callvalues -> exp generate_param callvalues_aux .
    RPAREN          reduce using rule 52 (callvalues -> exp generate_param callvalues_aux .)


state 199

    (50) callvalues_aux -> COMMA . callvalues
    (52) callvalues -> . exp generate_param callvalues_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    callvalues                     shift and go to state 211
    exp                            shift and go to state 144
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 200

    (51) callvalues_aux -> empty .
    RPAREN          reduce using rule 51 (callvalues_aux -> empty .)


state 201

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO . createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (90) createfinaltempvar -> .
    LPAREN          reduce using rule 90 (createfinaltempvar -> .)
    CTEBOOL         reduce using rule 90 (createfinaltempvar -> .)
    CTEFLOAT        reduce using rule 90 (createfinaltempvar -> .)
    CTEINT          reduce using rule 90 (createfinaltempvar -> .)
    ID              reduce using rule 90 (createfinaltempvar -> .)
    BOOL            reduce using rule 90 (createfinaltempvar -> .)
    FLOAT           reduce using rule 90 (createfinaltempvar -> .)
    INT             reduce using rule 90 (createfinaltempvar -> .)
    ELSE            reduce using rule 90 (createfinaltempvar -> .)
    IF              reduce using rule 90 (createfinaltempvar -> .)
    PRINT           reduce using rule 90 (createfinaltempvar -> .)
    INPUT           reduce using rule 90 (createfinaltempvar -> .)
    WHILE           reduce using rule 90 (createfinaltempvar -> .)
    DO              reduce using rule 90 (createfinaltempvar -> .)
    BY              reduce using rule 90 (createfinaltempvar -> .)
    TO              reduce using rule 90 (createfinaltempvar -> .)
    FROM            reduce using rule 90 (createfinaltempvar -> .)
    VOID            reduce using rule 90 (createfinaltempvar -> .)
    RETURN          reduce using rule 90 (createfinaltempvar -> .)
    FUNC            reduce using rule 90 (createfinaltempvar -> .)
    MAIN            reduce using rule 90 (createfinaltempvar -> .)
    VARS            reduce using rule 90 (createfinaltempvar -> .)
    PROGRAM         reduce using rule 90 (createfinaltempvar -> .)

    createfinaltempvar             shift and go to state 212

state 202

    (93) dowhileloop -> DO saveposition block WHILE LPAREN expression . RPAREN openjumpslot
    RPAREN          shift and go to state 213


state 203

    (92) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 119

    block                          shift and go to state 214

state 204

    (82) factor -> LPAREN fakefloor super_exp RPAREN .
    DIVIDE          reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TIMES           reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    MINUS           reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PLUS            reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    NEQ             reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    EQ              reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LTE             reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GTE             reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LT              reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GT              reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    OR              reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    AND             reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    COMMA           reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RPAREN          reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    SEMICOLON       reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TO              reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)
    DO              reduce using rule 82 (factor -> LPAREN fakefloor super_exp RPAREN .)


state 205

    (54) super_exp_aux -> logic super_exp .
    COMMA           reduce using rule 54 (super_exp_aux -> logic super_exp .)
    RPAREN          reduce using rule 54 (super_exp_aux -> logic super_exp .)


state 206

    (60) expression_aux -> relation expression .
    OR              reduce using rule 60 (expression_aux -> relation expression .)
    AND             reduce using rule 60 (expression_aux -> relation expression .)
    COMMA           reduce using rule 60 (expression_aux -> relation expression .)
    RPAREN          reduce using rule 60 (expression_aux -> relation expression .)
    SEMICOLON       reduce using rule 60 (expression_aux -> relation expression .)
    TO              reduce using rule 60 (expression_aux -> relation expression .)
    DO              reduce using rule 60 (expression_aux -> relation expression .)


state 207

    (70) exp_aux -> exp_sign exp .
    NEQ             reduce using rule 70 (exp_aux -> exp_sign exp .)
    EQ              reduce using rule 70 (exp_aux -> exp_sign exp .)
    LTE             reduce using rule 70 (exp_aux -> exp_sign exp .)
    GTE             reduce using rule 70 (exp_aux -> exp_sign exp .)
    LT              reduce using rule 70 (exp_aux -> exp_sign exp .)
    GT              reduce using rule 70 (exp_aux -> exp_sign exp .)
    OR              reduce using rule 70 (exp_aux -> exp_sign exp .)
    AND             reduce using rule 70 (exp_aux -> exp_sign exp .)
    COMMA           reduce using rule 70 (exp_aux -> exp_sign exp .)
    RPAREN          reduce using rule 70 (exp_aux -> exp_sign exp .)
    SEMICOLON       reduce using rule 70 (exp_aux -> exp_sign exp .)
    TO              reduce using rule 70 (exp_aux -> exp_sign exp .)
    DO              reduce using rule 70 (exp_aux -> exp_sign exp .)


state 208

    (76) term_aux -> term_sign term .
    MINUS           reduce using rule 76 (term_aux -> term_sign term .)
    PLUS            reduce using rule 76 (term_aux -> term_sign term .)
    NEQ             reduce using rule 76 (term_aux -> term_sign term .)
    EQ              reduce using rule 76 (term_aux -> term_sign term .)
    LTE             reduce using rule 76 (term_aux -> term_sign term .)
    GTE             reduce using rule 76 (term_aux -> term_sign term .)
    LT              reduce using rule 76 (term_aux -> term_sign term .)
    GT              reduce using rule 76 (term_aux -> term_sign term .)
    OR              reduce using rule 76 (term_aux -> term_sign term .)
    AND             reduce using rule 76 (term_aux -> term_sign term .)
    COMMA           reduce using rule 76 (term_aux -> term_sign term .)
    RPAREN          reduce using rule 76 (term_aux -> term_sign term .)
    SEMICOLON       reduce using rule 76 (term_aux -> term_sign term .)
    TO              reduce using rule 76 (term_aux -> term_sign term .)
    DO              reduce using rule 76 (term_aux -> term_sign term .)


state 209

    (106) condition -> IF LPAREN super_exp RPAREN openjumpslot block . filljumps
    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot block . ELSE filljumps openjumpslot block filljumps
    (110) filljumps -> .
    ELSE            shift and go to state 216
    ID              reduce using rule 110 (filljumps -> .)
    FROM            reduce using rule 110 (filljumps -> .)
    DO              reduce using rule 110 (filljumps -> .)
    WHILE           reduce using rule 110 (filljumps -> .)
    INPUT           reduce using rule 110 (filljumps -> .)
    PRINT           reduce using rule 110 (filljumps -> .)
    IF              reduce using rule 110 (filljumps -> .)
    RCURLY          reduce using rule 110 (filljumps -> .)
    RETURN          reduce using rule 110 (filljumps -> .)

    filljumps                      shift and go to state 215

state 210

    (6) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON . RCURLY
    RCURLY          shift and go to state 217


state 211

    (50) callvalues_aux -> COMMA callvalues .
    RPAREN          reduce using rule 50 (callvalues_aux -> COMMA callvalues .)


state 212

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar . expression validateloopend DO openjumpslot block filljumps
    (62) expression -> . exp expression_quadgen expression_aux
    (72) exp -> . term exp_quadgen exp_aux
    (78) term -> . factor term_quadgen term_aux
    (82) factor -> . LPAREN fakefloor super_exp RPAREN
    (83) factor -> . varcte
    (84) factor -> . call
    (85) factor -> . var
    (111) varcte -> . CTEBOOL
    (112) varcte -> . CTEFLOAT
    (113) varcte -> . CTEINT
    (48) call -> . ID generate_era LPAREN callvalues RPAREN
    (16) var -> . BOOL
    (17) var -> . FLOAT
    (18) var -> . INT
    (19) var -> . ELSE
    (20) var -> . IF
    (21) var -> . PRINT
    (22) var -> . INPUT
    (23) var -> . WHILE
    (24) var -> . DO
    (25) var -> . BY
    (26) var -> . TO
    (27) var -> . FROM
    (28) var -> . VOID
    (29) var -> . RETURN
    (30) var -> . FUNC
    (31) var -> . MAIN
    (32) var -> . VARS
    (33) var -> . PROGRAM
    (34) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (35) var -> . ID LBRACKET CTEINT RBRACKET
    (36) var -> . ID
    LPAREN          shift and go to state 124
    CTEBOOL         shift and go to state 136
    CTEFLOAT        shift and go to state 137
    CTEINT          shift and go to state 138
    ID              shift and go to state 139
    BOOL            shift and go to state 28
    FLOAT           shift and go to state 29
    INT             shift and go to state 30
    ELSE            shift and go to state 31
    IF              shift and go to state 32
    PRINT           shift and go to state 33
    INPUT           shift and go to state 34
    WHILE           shift and go to state 35
    DO              shift and go to state 36
    BY              shift and go to state 37
    TO              shift and go to state 38
    FROM            shift and go to state 39
    VOID            shift and go to state 40
    RETURN          shift and go to state 41
    FUNC            shift and go to state 42
    MAIN            shift and go to state 43
    VARS            shift and go to state 44
    PROGRAM         shift and go to state 45

    expression                     shift and go to state 218
    exp                            shift and go to state 130
    term                           shift and go to state 131
    factor                         shift and go to state 132
    varcte                         shift and go to state 133
    call                           shift and go to state 134
    var                            shift and go to state 135

state 213

    (93) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN . openjumpslot
    (108) openjumpslot -> .
    ID              reduce using rule 108 (openjumpslot -> .)
    FROM            reduce using rule 108 (openjumpslot -> .)
    DO              reduce using rule 108 (openjumpslot -> .)
    WHILE           reduce using rule 108 (openjumpslot -> .)
    INPUT           reduce using rule 108 (openjumpslot -> .)
    PRINT           reduce using rule 108 (openjumpslot -> .)
    IF              reduce using rule 108 (openjumpslot -> .)
    RCURLY          reduce using rule 108 (openjumpslot -> .)
    RETURN          reduce using rule 108 (openjumpslot -> .)

    openjumpslot                   shift and go to state 219

state 214

    (92) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block . filljumps
    (110) filljumps -> .
    ID              reduce using rule 110 (filljumps -> .)
    FROM            reduce using rule 110 (filljumps -> .)
    DO              reduce using rule 110 (filljumps -> .)
    WHILE           reduce using rule 110 (filljumps -> .)
    INPUT           reduce using rule 110 (filljumps -> .)
    PRINT           reduce using rule 110 (filljumps -> .)
    IF              reduce using rule 110 (filljumps -> .)
    RCURLY          reduce using rule 110 (filljumps -> .)
    RETURN          reduce using rule 110 (filljumps -> .)

    filljumps                      shift and go to state 220

state 215

    (106) condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .
    ID              reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    RETURN          reduce using rule 106 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)


state 216

    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE . filljumps openjumpslot block filljumps
    (110) filljumps -> .
    LCURLY          reduce using rule 110 (filljumps -> .)

    filljumps                      shift and go to state 221

state 217

    (6) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .
    FUNC            reduce using rule 6 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)
    MAIN            reduce using rule 6 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)


state 218

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression . validateloopend DO openjumpslot block filljumps
    (91) validateloopend -> .
    DO              reduce using rule 91 (validateloopend -> .)

    validateloopend                shift and go to state 222

state 219

    (93) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .
    ID              reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    FROM            reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    DO              reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    WHILE           reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    INPUT           reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    PRINT           reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    IF              reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    RCURLY          reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    RETURN          reduce using rule 93 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)


state 220

    (92) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .
    ID              reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    RETURN          reduce using rule 92 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)


state 221

    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps . openjumpslot block filljumps
    (108) openjumpslot -> .
    LCURLY          reduce using rule 108 (openjumpslot -> .)

    openjumpslot                   shift and go to state 223

state 222

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend . DO openjumpslot block filljumps
    DO              shift and go to state 224


state 223

    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 119

    block                          shift and go to state 225

state 224

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO . openjumpslot block filljumps
    (108) openjumpslot -> .
    LCURLY          reduce using rule 108 (openjumpslot -> .)

    openjumpslot                   shift and go to state 226

state 225

    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block . filljumps
    (110) filljumps -> .
    ID              reduce using rule 110 (filljumps -> .)
    FROM            reduce using rule 110 (filljumps -> .)
    DO              reduce using rule 110 (filljumps -> .)
    WHILE           reduce using rule 110 (filljumps -> .)
    INPUT           reduce using rule 110 (filljumps -> .)
    PRINT           reduce using rule 110 (filljumps -> .)
    IF              reduce using rule 110 (filljumps -> .)
    RCURLY          reduce using rule 110 (filljumps -> .)
    RETURN          reduce using rule 110 (filljumps -> .)

    filljumps                      shift and go to state 227

state 226

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 119

    block                          shift and go to state 228

state 227

    (107) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .
    ID              reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    FROM            reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    DO              reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    WHILE           reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    INPUT           reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    PRINT           reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    IF              reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    RCURLY          reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    RETURN          reduce using rule 107 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)


state 228

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block . filljumps
    (110) filljumps -> .
    ID              reduce using rule 110 (filljumps -> .)
    FROM            reduce using rule 110 (filljumps -> .)
    DO              reduce using rule 110 (filljumps -> .)
    WHILE           reduce using rule 110 (filljumps -> .)
    INPUT           reduce using rule 110 (filljumps -> .)
    PRINT           reduce using rule 110 (filljumps -> .)
    IF              reduce using rule 110 (filljumps -> .)
    RCURLY          reduce using rule 110 (filljumps -> .)
    RETURN          reduce using rule 110 (filljumps -> .)

    filljumps                      shift and go to state 229

state 229

    (87) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .
    ID              reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    FROM            reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    DO              reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    WHILE           reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    INPUT           reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    PRINT           reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    IF              reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    RCURLY          reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    RETURN          reduce using rule 87 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
