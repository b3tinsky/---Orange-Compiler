Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     declare -> decvars decfuncs main_block
Rule 3     main_block -> MAIN changecontext LPAREN RPAREN declareblock
Rule 4     block -> LCURLY blockcontent RCURLY
Rule 5     declareblock -> LCURLY decvars blockcontent RCURLY
Rule 6     returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
Rule 7     blockcontent -> empty
Rule 8     blockcontent -> statute blockcontent
Rule 9     decvars -> empty
Rule 10    decvars -> VARS decvar_line
Rule 11    decvar_line -> type decvar SEMICOLON decvar_line
Rule 12    decvar_line -> type decvar SEMICOLON
Rule 13    decvar -> var COMMA decvar
Rule 14    decvar -> var
Rule 15    var -> BOOL
Rule 16    var -> FLOAT
Rule 17    var -> INT
Rule 18    var -> ELSE
Rule 19    var -> IF
Rule 20    var -> PRINT
Rule 21    var -> INPUT
Rule 22    var -> WHILE
Rule 23    var -> DO
Rule 24    var -> BY
Rule 25    var -> TO
Rule 26    var -> FROM
Rule 27    var -> VOID
Rule 28    var -> RETURN
Rule 29    var -> FUNC
Rule 30    var -> MAIN
Rule 31    var -> VARS
Rule 32    var -> PROGRAM
Rule 33    var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
Rule 34    var -> ID LBRACKET CTEINT RBRACKET
Rule 35    var -> ID
Rule 36    decfuncs -> empty
Rule 37    decfuncs -> func decfuncs
Rule 38    func -> FUNC typefunc
Rule 39    func -> FUNC voidfunc
Rule 40    voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock
Rule 41    typefunc -> type ID changecontext LPAREN params RPAREN returnblock
Rule 42    params -> empty
Rule 43    params -> type ID COMMA params
Rule 44    params -> type ID
Rule 45    call -> ID LPAREN callvalues RPAREN
Rule 46    callvalues -> empty
Rule 47    callvalues -> exp COMMA callvalues
Rule 48    callvalues -> exp
Rule 49    super_exp_aux -> logic super_exp
Rule 50    super_exp_aux -> empty
Rule 51    super_exp -> expression super_exp_quadgen super_exp_aux
Rule 52    logic -> OR
Rule 53    logic -> AND
Rule 54    super_exp_quadgen -> <empty>
Rule 55    expression_aux -> relation expression
Rule 56    expression_aux -> empty
Rule 57    expression -> exp expression_quadgen expression_aux
Rule 58    relation -> NEQ
Rule 59    relation -> EQ
Rule 60    relation -> LTE
Rule 61    relation -> GTE
Rule 62    relation -> LT
Rule 63    relation -> GT
Rule 64    expression_quadgen -> <empty>
Rule 65    exp_aux -> exp_sign exp
Rule 66    exp_aux -> empty
Rule 67    exp -> term exp_quadgen exp_aux
Rule 68    exp_sign -> MINUS
Rule 69    exp_sign -> PLUS
Rule 70    exp_quadgen -> <empty>
Rule 71    term_aux -> term_sign term
Rule 72    term_aux -> empty
Rule 73    term -> factor term_quadgen term_aux
Rule 74    term_sign -> DIVIDE
Rule 75    term_sign -> TIMES
Rule 76    term_quadgen -> <empty>
Rule 77    factor -> LPAREN fakefloor super_exp RPAREN
Rule 78    factor -> varcte
Rule 79    factor -> call
Rule 80    factor -> var
Rule 81    fakefloor -> <empty>
Rule 82    forloop -> FROM var ASSIGN expression TO expression BY expression DO block
Rule 83    forloop -> FROM var ASSIGN expression TO expression DO block
Rule 84    whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
Rule 85    dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
Rule 86    assignment -> assignment_var assignment_sign expression SEMICOLON
Rule 87    assignment_sign -> ASSIGN
Rule 88    assignment_var -> ID
Rule 89    read -> INPUT LPAREN readaux RPAREN SEMICOLON
Rule 90    readaux -> readvalue COMMA readaux
Rule 91    readaux -> readvalue
Rule 92    readvalue -> var
Rule 93    write -> PRINT LPAREN writeaux RPAREN SEMICOLON
Rule 94    writeaux -> writevalues
Rule 95    writeaux -> writevalues COMMA writeaux
Rule 96    writevalues -> CTESTRING
Rule 97    writevalues -> super_exp
Rule 98    condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps
Rule 99    condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
Rule 100   openjumpslot -> <empty>
Rule 101   saveposition -> <empty>
Rule 102   filljumps -> <empty>
Rule 103   varcte -> CTEBOOL
Rule 104   varcte -> CTEFLOAT
Rule 105   varcte -> CTEINT
Rule 106   type -> BOOL
Rule 107   type -> FLOAT
Rule 108   type -> INT
Rule 109   statute -> call
Rule 110   statute -> forloop
Rule 111   statute -> dowhileloop
Rule 112   statute -> whileloop
Rule 113   statute -> read
Rule 114   statute -> write
Rule 115   statute -> condition
Rule 116   statute -> assignment
Rule 117   changecontext -> <empty>
Rule 118   saveprogramname -> <empty>
Rule 119   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 53
ASSIGN               : 82 83 87
BOOL                 : 15 106
BY                   : 24 82
COMMA                : 13 43 47 90 95
CTEBOOL              : 103
CTEFLOAT             : 104
CTEINT               : 33 33 34 105
CTESTRING            : 96
DIVIDE               : 74
DO                   : 23 82 83 85
ELSE                 : 18 99
EQ                   : 59
FLOAT                : 16 107
FROM                 : 26 82 83
FUNC                 : 29 38 39
GT                   : 63
GTE                  : 61
ID                   : 1 33 34 35 40 41 43 44 45 88
IF                   : 19 98 99
INPUT                : 21 89
INT                  : 17 108
LBRACKET             : 33 33 34
LCURLY               : 4 5 6
LPAREN               : 3 40 41 45 77 84 85 89 93 98 99
LT                   : 62
LTE                  : 60
MAIN                 : 3 30
MINUS                : 68
NEQ                  : 58
OR                   : 52
PLUS                 : 69
PRINT                : 20 93
PROGRAM              : 1 32
RBRACKET             : 33 33 34
RCURLY               : 4 5 6
RETURN               : 6 28
RPAREN               : 3 40 41 45 77 84 85 89 93 98 99
SEMICOLON            : 6 11 12 86 89 93
TIMES                : 75
TO                   : 25 82 83
VARS                 : 10 31
VOID                 : 27 40
WHILE                : 22 84 85
error                : 

Nonterminals, with rules where they appear:

assignment           : 116
assignment_sign      : 86
assignment_var       : 86
block                : 82 83 84 85 98 99 99
blockcontent         : 4 5 6 8
call                 : 79 109
callvalues           : 45 47
changecontext        : 3 40 41
condition            : 115
decfuncs             : 2 37
declare              : 1
declareblock         : 3 40
decvar               : 11 12 13
decvar_line          : 10 11
decvars              : 2 5 6
dowhileloop          : 111
empty                : 7 9 36 42 46 50 56 66 72
exp                  : 6 47 48 57 65
exp_aux              : 67
exp_quadgen          : 67
exp_sign             : 65
expression           : 51 55 82 82 82 83 83 84 85 86
expression_aux       : 57
expression_quadgen   : 57
factor               : 73
fakefloor            : 77
filljumps            : 84 98 99 99
forloop              : 110
func                 : 37
logic                : 49
main_block           : 2
openjumpslot         : 84 85 98 99 99
params               : 40 41 43
program              : 0
read                 : 113
readaux              : 89 90
readvalue            : 90 91
relation             : 55
returnblock          : 41
saveposition         : 84 85
saveprogramname      : 1
statute              : 8
super_exp            : 49 77 97 98 99
super_exp_aux        : 51
super_exp_quadgen    : 51
term                 : 67 71
term_aux             : 73
term_quadgen         : 73
term_sign            : 71
type                 : 11 12 41 43 44
typefunc             : 38
var                  : 13 14 80 82 83 92
varcte               : 78
voidfunc             : 39
whileloop            : 112
write                : 114
writeaux             : 93 95
writevalues          : 94 95


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (118) saveprogramname -> .
    VARS            reduce using rule 118 (saveprogramname -> .)
    FUNC            reduce using rule 118 (saveprogramname -> .)
    MAIN            reduce using rule 118 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (2) declare -> . decvars decfuncs main_block
    (9) decvars -> . empty
    (10) decvars -> . VARS decvar_line
    (119) empty -> .
    VARS            shift and go to state 8
    FUNC            reduce using rule 119 (empty -> .)
    MAIN            reduce using rule 119 (empty -> .)

    declare                        shift and go to state 5
    decvars                        shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (2) declare -> decvars . decfuncs main_block
    (36) decfuncs -> . empty
    (37) decfuncs -> . func decfuncs
    (119) empty -> .
    (38) func -> . FUNC typefunc
    (39) func -> . FUNC voidfunc
    MAIN            reduce using rule 119 (empty -> .)
    FUNC            shift and go to state 12

    decfuncs                       shift and go to state 9
    empty                          shift and go to state 10
    func                           shift and go to state 11

state 7

    (9) decvars -> empty .
    FUNC            reduce using rule 9 (decvars -> empty .)
    MAIN            reduce using rule 9 (decvars -> empty .)
    ID              reduce using rule 9 (decvars -> empty .)
    FROM            reduce using rule 9 (decvars -> empty .)
    DO              reduce using rule 9 (decvars -> empty .)
    WHILE           reduce using rule 9 (decvars -> empty .)
    INPUT           reduce using rule 9 (decvars -> empty .)
    PRINT           reduce using rule 9 (decvars -> empty .)
    IF              reduce using rule 9 (decvars -> empty .)
    RCURLY          reduce using rule 9 (decvars -> empty .)
    RETURN          reduce using rule 9 (decvars -> empty .)


state 8

    (10) decvars -> VARS . decvar_line
    (11) decvar_line -> . type decvar SEMICOLON decvar_line
    (12) decvar_line -> . type decvar SEMICOLON
    (106) type -> . BOOL
    (107) type -> . FLOAT
    (108) type -> . INT
    BOOL            shift and go to state 15
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    decvar_line                    shift and go to state 13
    type                           shift and go to state 14

state 9

    (2) declare -> decvars decfuncs . main_block
    (3) main_block -> . MAIN changecontext LPAREN RPAREN declareblock
    MAIN            shift and go to state 19

    main_block                     shift and go to state 18

state 10

    (36) decfuncs -> empty .
    MAIN            reduce using rule 36 (decfuncs -> empty .)


state 11

    (37) decfuncs -> func . decfuncs
    (36) decfuncs -> . empty
    (37) decfuncs -> . func decfuncs
    (119) empty -> .
    (38) func -> . FUNC typefunc
    (39) func -> . FUNC voidfunc
    MAIN            reduce using rule 119 (empty -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 11
    decfuncs                       shift and go to state 20
    empty                          shift and go to state 10

state 12

    (38) func -> FUNC . typefunc
    (39) func -> FUNC . voidfunc
    (41) typefunc -> . type ID changecontext LPAREN params RPAREN returnblock
    (40) voidfunc -> . VOID ID changecontext LPAREN params RPAREN declareblock
    (106) type -> . BOOL
    (107) type -> . FLOAT
    (108) type -> . INT
    VOID            shift and go to state 24
    BOOL            shift and go to state 15
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    typefunc                       shift and go to state 21
    voidfunc                       shift and go to state 22
    type                           shift and go to state 23

state 13

    (10) decvars -> VARS decvar_line .
    FUNC            reduce using rule 10 (decvars -> VARS decvar_line .)
    MAIN            reduce using rule 10 (decvars -> VARS decvar_line .)
    ID              reduce using rule 10 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 10 (decvars -> VARS decvar_line .)
    DO              reduce using rule 10 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 10 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 10 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 10 (decvars -> VARS decvar_line .)
    IF              reduce using rule 10 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 10 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 10 (decvars -> VARS decvar_line .)


state 14

    (11) decvar_line -> type . decvar SEMICOLON decvar_line
    (12) decvar_line -> type . decvar SEMICOLON
    (13) decvar -> . var COMMA decvar
    (14) decvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    decvar                         shift and go to state 25
    var                            shift and go to state 26

state 15

    (106) type -> BOOL .
    BOOL            reduce using rule 106 (type -> BOOL .)
    FLOAT           reduce using rule 106 (type -> BOOL .)
    INT             reduce using rule 106 (type -> BOOL .)
    ELSE            reduce using rule 106 (type -> BOOL .)
    IF              reduce using rule 106 (type -> BOOL .)
    PRINT           reduce using rule 106 (type -> BOOL .)
    INPUT           reduce using rule 106 (type -> BOOL .)
    WHILE           reduce using rule 106 (type -> BOOL .)
    DO              reduce using rule 106 (type -> BOOL .)
    BY              reduce using rule 106 (type -> BOOL .)
    TO              reduce using rule 106 (type -> BOOL .)
    FROM            reduce using rule 106 (type -> BOOL .)
    VOID            reduce using rule 106 (type -> BOOL .)
    RETURN          reduce using rule 106 (type -> BOOL .)
    FUNC            reduce using rule 106 (type -> BOOL .)
    MAIN            reduce using rule 106 (type -> BOOL .)
    VARS            reduce using rule 106 (type -> BOOL .)
    PROGRAM         reduce using rule 106 (type -> BOOL .)
    ID              reduce using rule 106 (type -> BOOL .)


state 16

    (107) type -> FLOAT .
    BOOL            reduce using rule 107 (type -> FLOAT .)
    FLOAT           reduce using rule 107 (type -> FLOAT .)
    INT             reduce using rule 107 (type -> FLOAT .)
    ELSE            reduce using rule 107 (type -> FLOAT .)
    IF              reduce using rule 107 (type -> FLOAT .)
    PRINT           reduce using rule 107 (type -> FLOAT .)
    INPUT           reduce using rule 107 (type -> FLOAT .)
    WHILE           reduce using rule 107 (type -> FLOAT .)
    DO              reduce using rule 107 (type -> FLOAT .)
    BY              reduce using rule 107 (type -> FLOAT .)
    TO              reduce using rule 107 (type -> FLOAT .)
    FROM            reduce using rule 107 (type -> FLOAT .)
    VOID            reduce using rule 107 (type -> FLOAT .)
    RETURN          reduce using rule 107 (type -> FLOAT .)
    FUNC            reduce using rule 107 (type -> FLOAT .)
    MAIN            reduce using rule 107 (type -> FLOAT .)
    VARS            reduce using rule 107 (type -> FLOAT .)
    PROGRAM         reduce using rule 107 (type -> FLOAT .)
    ID              reduce using rule 107 (type -> FLOAT .)


state 17

    (108) type -> INT .
    BOOL            reduce using rule 108 (type -> INT .)
    FLOAT           reduce using rule 108 (type -> INT .)
    INT             reduce using rule 108 (type -> INT .)
    ELSE            reduce using rule 108 (type -> INT .)
    IF              reduce using rule 108 (type -> INT .)
    PRINT           reduce using rule 108 (type -> INT .)
    INPUT           reduce using rule 108 (type -> INT .)
    WHILE           reduce using rule 108 (type -> INT .)
    DO              reduce using rule 108 (type -> INT .)
    BY              reduce using rule 108 (type -> INT .)
    TO              reduce using rule 108 (type -> INT .)
    FROM            reduce using rule 108 (type -> INT .)
    VOID            reduce using rule 108 (type -> INT .)
    RETURN          reduce using rule 108 (type -> INT .)
    FUNC            reduce using rule 108 (type -> INT .)
    MAIN            reduce using rule 108 (type -> INT .)
    VARS            reduce using rule 108 (type -> INT .)
    PROGRAM         reduce using rule 108 (type -> INT .)
    ID              reduce using rule 108 (type -> INT .)


state 18

    (2) declare -> decvars decfuncs main_block .
    $end            reduce using rule 2 (declare -> decvars decfuncs main_block .)


state 19

    (3) main_block -> MAIN . changecontext LPAREN RPAREN declareblock
    (117) changecontext -> .
    LPAREN          reduce using rule 117 (changecontext -> .)

    changecontext                  shift and go to state 46

state 20

    (37) decfuncs -> func decfuncs .
    MAIN            reduce using rule 37 (decfuncs -> func decfuncs .)


state 21

    (38) func -> FUNC typefunc .
    FUNC            reduce using rule 38 (func -> FUNC typefunc .)
    MAIN            reduce using rule 38 (func -> FUNC typefunc .)


state 22

    (39) func -> FUNC voidfunc .
    FUNC            reduce using rule 39 (func -> FUNC voidfunc .)
    MAIN            reduce using rule 39 (func -> FUNC voidfunc .)


state 23

    (41) typefunc -> type . ID changecontext LPAREN params RPAREN returnblock
    ID              shift and go to state 47


state 24

    (40) voidfunc -> VOID . ID changecontext LPAREN params RPAREN declareblock
    ID              shift and go to state 48


state 25

    (11) decvar_line -> type decvar . SEMICOLON decvar_line
    (12) decvar_line -> type decvar . SEMICOLON
    SEMICOLON       shift and go to state 49


state 26

    (13) decvar -> var . COMMA decvar
    (14) decvar -> var .
    COMMA           shift and go to state 50
    SEMICOLON       reduce using rule 14 (decvar -> var .)


state 27

    (15) var -> BOOL .
    COMMA           reduce using rule 15 (var -> BOOL .)
    SEMICOLON       reduce using rule 15 (var -> BOOL .)
    ASSIGN          reduce using rule 15 (var -> BOOL .)
    DIVIDE          reduce using rule 15 (var -> BOOL .)
    TIMES           reduce using rule 15 (var -> BOOL .)
    MINUS           reduce using rule 15 (var -> BOOL .)
    PLUS            reduce using rule 15 (var -> BOOL .)
    RPAREN          reduce using rule 15 (var -> BOOL .)
    NEQ             reduce using rule 15 (var -> BOOL .)
    EQ              reduce using rule 15 (var -> BOOL .)
    LTE             reduce using rule 15 (var -> BOOL .)
    GTE             reduce using rule 15 (var -> BOOL .)
    LT              reduce using rule 15 (var -> BOOL .)
    GT              reduce using rule 15 (var -> BOOL .)
    OR              reduce using rule 15 (var -> BOOL .)
    AND             reduce using rule 15 (var -> BOOL .)
    TO              reduce using rule 15 (var -> BOOL .)
    BY              reduce using rule 15 (var -> BOOL .)
    DO              reduce using rule 15 (var -> BOOL .)


state 28

    (16) var -> FLOAT .
    COMMA           reduce using rule 16 (var -> FLOAT .)
    SEMICOLON       reduce using rule 16 (var -> FLOAT .)
    ASSIGN          reduce using rule 16 (var -> FLOAT .)
    DIVIDE          reduce using rule 16 (var -> FLOAT .)
    TIMES           reduce using rule 16 (var -> FLOAT .)
    MINUS           reduce using rule 16 (var -> FLOAT .)
    PLUS            reduce using rule 16 (var -> FLOAT .)
    RPAREN          reduce using rule 16 (var -> FLOAT .)
    NEQ             reduce using rule 16 (var -> FLOAT .)
    EQ              reduce using rule 16 (var -> FLOAT .)
    LTE             reduce using rule 16 (var -> FLOAT .)
    GTE             reduce using rule 16 (var -> FLOAT .)
    LT              reduce using rule 16 (var -> FLOAT .)
    GT              reduce using rule 16 (var -> FLOAT .)
    OR              reduce using rule 16 (var -> FLOAT .)
    AND             reduce using rule 16 (var -> FLOAT .)
    TO              reduce using rule 16 (var -> FLOAT .)
    BY              reduce using rule 16 (var -> FLOAT .)
    DO              reduce using rule 16 (var -> FLOAT .)


state 29

    (17) var -> INT .
    COMMA           reduce using rule 17 (var -> INT .)
    SEMICOLON       reduce using rule 17 (var -> INT .)
    ASSIGN          reduce using rule 17 (var -> INT .)
    DIVIDE          reduce using rule 17 (var -> INT .)
    TIMES           reduce using rule 17 (var -> INT .)
    MINUS           reduce using rule 17 (var -> INT .)
    PLUS            reduce using rule 17 (var -> INT .)
    RPAREN          reduce using rule 17 (var -> INT .)
    NEQ             reduce using rule 17 (var -> INT .)
    EQ              reduce using rule 17 (var -> INT .)
    LTE             reduce using rule 17 (var -> INT .)
    GTE             reduce using rule 17 (var -> INT .)
    LT              reduce using rule 17 (var -> INT .)
    GT              reduce using rule 17 (var -> INT .)
    OR              reduce using rule 17 (var -> INT .)
    AND             reduce using rule 17 (var -> INT .)
    TO              reduce using rule 17 (var -> INT .)
    BY              reduce using rule 17 (var -> INT .)
    DO              reduce using rule 17 (var -> INT .)


state 30

    (18) var -> ELSE .
    COMMA           reduce using rule 18 (var -> ELSE .)
    SEMICOLON       reduce using rule 18 (var -> ELSE .)
    ASSIGN          reduce using rule 18 (var -> ELSE .)
    DIVIDE          reduce using rule 18 (var -> ELSE .)
    TIMES           reduce using rule 18 (var -> ELSE .)
    MINUS           reduce using rule 18 (var -> ELSE .)
    PLUS            reduce using rule 18 (var -> ELSE .)
    RPAREN          reduce using rule 18 (var -> ELSE .)
    NEQ             reduce using rule 18 (var -> ELSE .)
    EQ              reduce using rule 18 (var -> ELSE .)
    LTE             reduce using rule 18 (var -> ELSE .)
    GTE             reduce using rule 18 (var -> ELSE .)
    LT              reduce using rule 18 (var -> ELSE .)
    GT              reduce using rule 18 (var -> ELSE .)
    OR              reduce using rule 18 (var -> ELSE .)
    AND             reduce using rule 18 (var -> ELSE .)
    TO              reduce using rule 18 (var -> ELSE .)
    BY              reduce using rule 18 (var -> ELSE .)
    DO              reduce using rule 18 (var -> ELSE .)


state 31

    (19) var -> IF .
    COMMA           reduce using rule 19 (var -> IF .)
    SEMICOLON       reduce using rule 19 (var -> IF .)
    ASSIGN          reduce using rule 19 (var -> IF .)
    DIVIDE          reduce using rule 19 (var -> IF .)
    TIMES           reduce using rule 19 (var -> IF .)
    MINUS           reduce using rule 19 (var -> IF .)
    PLUS            reduce using rule 19 (var -> IF .)
    RPAREN          reduce using rule 19 (var -> IF .)
    NEQ             reduce using rule 19 (var -> IF .)
    EQ              reduce using rule 19 (var -> IF .)
    LTE             reduce using rule 19 (var -> IF .)
    GTE             reduce using rule 19 (var -> IF .)
    LT              reduce using rule 19 (var -> IF .)
    GT              reduce using rule 19 (var -> IF .)
    OR              reduce using rule 19 (var -> IF .)
    AND             reduce using rule 19 (var -> IF .)
    TO              reduce using rule 19 (var -> IF .)
    BY              reduce using rule 19 (var -> IF .)
    DO              reduce using rule 19 (var -> IF .)


state 32

    (20) var -> PRINT .
    COMMA           reduce using rule 20 (var -> PRINT .)
    SEMICOLON       reduce using rule 20 (var -> PRINT .)
    ASSIGN          reduce using rule 20 (var -> PRINT .)
    DIVIDE          reduce using rule 20 (var -> PRINT .)
    TIMES           reduce using rule 20 (var -> PRINT .)
    MINUS           reduce using rule 20 (var -> PRINT .)
    PLUS            reduce using rule 20 (var -> PRINT .)
    RPAREN          reduce using rule 20 (var -> PRINT .)
    NEQ             reduce using rule 20 (var -> PRINT .)
    EQ              reduce using rule 20 (var -> PRINT .)
    LTE             reduce using rule 20 (var -> PRINT .)
    GTE             reduce using rule 20 (var -> PRINT .)
    LT              reduce using rule 20 (var -> PRINT .)
    GT              reduce using rule 20 (var -> PRINT .)
    OR              reduce using rule 20 (var -> PRINT .)
    AND             reduce using rule 20 (var -> PRINT .)
    TO              reduce using rule 20 (var -> PRINT .)
    BY              reduce using rule 20 (var -> PRINT .)
    DO              reduce using rule 20 (var -> PRINT .)


state 33

    (21) var -> INPUT .
    COMMA           reduce using rule 21 (var -> INPUT .)
    SEMICOLON       reduce using rule 21 (var -> INPUT .)
    ASSIGN          reduce using rule 21 (var -> INPUT .)
    DIVIDE          reduce using rule 21 (var -> INPUT .)
    TIMES           reduce using rule 21 (var -> INPUT .)
    MINUS           reduce using rule 21 (var -> INPUT .)
    PLUS            reduce using rule 21 (var -> INPUT .)
    RPAREN          reduce using rule 21 (var -> INPUT .)
    NEQ             reduce using rule 21 (var -> INPUT .)
    EQ              reduce using rule 21 (var -> INPUT .)
    LTE             reduce using rule 21 (var -> INPUT .)
    GTE             reduce using rule 21 (var -> INPUT .)
    LT              reduce using rule 21 (var -> INPUT .)
    GT              reduce using rule 21 (var -> INPUT .)
    OR              reduce using rule 21 (var -> INPUT .)
    AND             reduce using rule 21 (var -> INPUT .)
    TO              reduce using rule 21 (var -> INPUT .)
    BY              reduce using rule 21 (var -> INPUT .)
    DO              reduce using rule 21 (var -> INPUT .)


state 34

    (22) var -> WHILE .
    COMMA           reduce using rule 22 (var -> WHILE .)
    SEMICOLON       reduce using rule 22 (var -> WHILE .)
    ASSIGN          reduce using rule 22 (var -> WHILE .)
    DIVIDE          reduce using rule 22 (var -> WHILE .)
    TIMES           reduce using rule 22 (var -> WHILE .)
    MINUS           reduce using rule 22 (var -> WHILE .)
    PLUS            reduce using rule 22 (var -> WHILE .)
    RPAREN          reduce using rule 22 (var -> WHILE .)
    NEQ             reduce using rule 22 (var -> WHILE .)
    EQ              reduce using rule 22 (var -> WHILE .)
    LTE             reduce using rule 22 (var -> WHILE .)
    GTE             reduce using rule 22 (var -> WHILE .)
    LT              reduce using rule 22 (var -> WHILE .)
    GT              reduce using rule 22 (var -> WHILE .)
    OR              reduce using rule 22 (var -> WHILE .)
    AND             reduce using rule 22 (var -> WHILE .)
    TO              reduce using rule 22 (var -> WHILE .)
    BY              reduce using rule 22 (var -> WHILE .)
    DO              reduce using rule 22 (var -> WHILE .)


state 35

    (23) var -> DO .
    COMMA           reduce using rule 23 (var -> DO .)
    SEMICOLON       reduce using rule 23 (var -> DO .)
    ASSIGN          reduce using rule 23 (var -> DO .)
    DIVIDE          reduce using rule 23 (var -> DO .)
    TIMES           reduce using rule 23 (var -> DO .)
    MINUS           reduce using rule 23 (var -> DO .)
    PLUS            reduce using rule 23 (var -> DO .)
    RPAREN          reduce using rule 23 (var -> DO .)
    NEQ             reduce using rule 23 (var -> DO .)
    EQ              reduce using rule 23 (var -> DO .)
    LTE             reduce using rule 23 (var -> DO .)
    GTE             reduce using rule 23 (var -> DO .)
    LT              reduce using rule 23 (var -> DO .)
    GT              reduce using rule 23 (var -> DO .)
    OR              reduce using rule 23 (var -> DO .)
    AND             reduce using rule 23 (var -> DO .)
    TO              reduce using rule 23 (var -> DO .)
    BY              reduce using rule 23 (var -> DO .)
    DO              reduce using rule 23 (var -> DO .)


state 36

    (24) var -> BY .
    COMMA           reduce using rule 24 (var -> BY .)
    SEMICOLON       reduce using rule 24 (var -> BY .)
    ASSIGN          reduce using rule 24 (var -> BY .)
    DIVIDE          reduce using rule 24 (var -> BY .)
    TIMES           reduce using rule 24 (var -> BY .)
    MINUS           reduce using rule 24 (var -> BY .)
    PLUS            reduce using rule 24 (var -> BY .)
    RPAREN          reduce using rule 24 (var -> BY .)
    NEQ             reduce using rule 24 (var -> BY .)
    EQ              reduce using rule 24 (var -> BY .)
    LTE             reduce using rule 24 (var -> BY .)
    GTE             reduce using rule 24 (var -> BY .)
    LT              reduce using rule 24 (var -> BY .)
    GT              reduce using rule 24 (var -> BY .)
    OR              reduce using rule 24 (var -> BY .)
    AND             reduce using rule 24 (var -> BY .)
    TO              reduce using rule 24 (var -> BY .)
    BY              reduce using rule 24 (var -> BY .)
    DO              reduce using rule 24 (var -> BY .)


state 37

    (25) var -> TO .
    COMMA           reduce using rule 25 (var -> TO .)
    SEMICOLON       reduce using rule 25 (var -> TO .)
    ASSIGN          reduce using rule 25 (var -> TO .)
    DIVIDE          reduce using rule 25 (var -> TO .)
    TIMES           reduce using rule 25 (var -> TO .)
    MINUS           reduce using rule 25 (var -> TO .)
    PLUS            reduce using rule 25 (var -> TO .)
    RPAREN          reduce using rule 25 (var -> TO .)
    NEQ             reduce using rule 25 (var -> TO .)
    EQ              reduce using rule 25 (var -> TO .)
    LTE             reduce using rule 25 (var -> TO .)
    GTE             reduce using rule 25 (var -> TO .)
    LT              reduce using rule 25 (var -> TO .)
    GT              reduce using rule 25 (var -> TO .)
    OR              reduce using rule 25 (var -> TO .)
    AND             reduce using rule 25 (var -> TO .)
    TO              reduce using rule 25 (var -> TO .)
    BY              reduce using rule 25 (var -> TO .)
    DO              reduce using rule 25 (var -> TO .)


state 38

    (26) var -> FROM .
    COMMA           reduce using rule 26 (var -> FROM .)
    SEMICOLON       reduce using rule 26 (var -> FROM .)
    ASSIGN          reduce using rule 26 (var -> FROM .)
    DIVIDE          reduce using rule 26 (var -> FROM .)
    TIMES           reduce using rule 26 (var -> FROM .)
    MINUS           reduce using rule 26 (var -> FROM .)
    PLUS            reduce using rule 26 (var -> FROM .)
    RPAREN          reduce using rule 26 (var -> FROM .)
    NEQ             reduce using rule 26 (var -> FROM .)
    EQ              reduce using rule 26 (var -> FROM .)
    LTE             reduce using rule 26 (var -> FROM .)
    GTE             reduce using rule 26 (var -> FROM .)
    LT              reduce using rule 26 (var -> FROM .)
    GT              reduce using rule 26 (var -> FROM .)
    OR              reduce using rule 26 (var -> FROM .)
    AND             reduce using rule 26 (var -> FROM .)
    TO              reduce using rule 26 (var -> FROM .)
    BY              reduce using rule 26 (var -> FROM .)
    DO              reduce using rule 26 (var -> FROM .)


state 39

    (27) var -> VOID .
    COMMA           reduce using rule 27 (var -> VOID .)
    SEMICOLON       reduce using rule 27 (var -> VOID .)
    ASSIGN          reduce using rule 27 (var -> VOID .)
    DIVIDE          reduce using rule 27 (var -> VOID .)
    TIMES           reduce using rule 27 (var -> VOID .)
    MINUS           reduce using rule 27 (var -> VOID .)
    PLUS            reduce using rule 27 (var -> VOID .)
    RPAREN          reduce using rule 27 (var -> VOID .)
    NEQ             reduce using rule 27 (var -> VOID .)
    EQ              reduce using rule 27 (var -> VOID .)
    LTE             reduce using rule 27 (var -> VOID .)
    GTE             reduce using rule 27 (var -> VOID .)
    LT              reduce using rule 27 (var -> VOID .)
    GT              reduce using rule 27 (var -> VOID .)
    OR              reduce using rule 27 (var -> VOID .)
    AND             reduce using rule 27 (var -> VOID .)
    TO              reduce using rule 27 (var -> VOID .)
    BY              reduce using rule 27 (var -> VOID .)
    DO              reduce using rule 27 (var -> VOID .)


state 40

    (28) var -> RETURN .
    COMMA           reduce using rule 28 (var -> RETURN .)
    SEMICOLON       reduce using rule 28 (var -> RETURN .)
    ASSIGN          reduce using rule 28 (var -> RETURN .)
    DIVIDE          reduce using rule 28 (var -> RETURN .)
    TIMES           reduce using rule 28 (var -> RETURN .)
    MINUS           reduce using rule 28 (var -> RETURN .)
    PLUS            reduce using rule 28 (var -> RETURN .)
    RPAREN          reduce using rule 28 (var -> RETURN .)
    NEQ             reduce using rule 28 (var -> RETURN .)
    EQ              reduce using rule 28 (var -> RETURN .)
    LTE             reduce using rule 28 (var -> RETURN .)
    GTE             reduce using rule 28 (var -> RETURN .)
    LT              reduce using rule 28 (var -> RETURN .)
    GT              reduce using rule 28 (var -> RETURN .)
    OR              reduce using rule 28 (var -> RETURN .)
    AND             reduce using rule 28 (var -> RETURN .)
    TO              reduce using rule 28 (var -> RETURN .)
    BY              reduce using rule 28 (var -> RETURN .)
    DO              reduce using rule 28 (var -> RETURN .)


state 41

    (29) var -> FUNC .
    COMMA           reduce using rule 29 (var -> FUNC .)
    SEMICOLON       reduce using rule 29 (var -> FUNC .)
    ASSIGN          reduce using rule 29 (var -> FUNC .)
    DIVIDE          reduce using rule 29 (var -> FUNC .)
    TIMES           reduce using rule 29 (var -> FUNC .)
    MINUS           reduce using rule 29 (var -> FUNC .)
    PLUS            reduce using rule 29 (var -> FUNC .)
    RPAREN          reduce using rule 29 (var -> FUNC .)
    NEQ             reduce using rule 29 (var -> FUNC .)
    EQ              reduce using rule 29 (var -> FUNC .)
    LTE             reduce using rule 29 (var -> FUNC .)
    GTE             reduce using rule 29 (var -> FUNC .)
    LT              reduce using rule 29 (var -> FUNC .)
    GT              reduce using rule 29 (var -> FUNC .)
    OR              reduce using rule 29 (var -> FUNC .)
    AND             reduce using rule 29 (var -> FUNC .)
    TO              reduce using rule 29 (var -> FUNC .)
    BY              reduce using rule 29 (var -> FUNC .)
    DO              reduce using rule 29 (var -> FUNC .)


state 42

    (30) var -> MAIN .
    COMMA           reduce using rule 30 (var -> MAIN .)
    SEMICOLON       reduce using rule 30 (var -> MAIN .)
    ASSIGN          reduce using rule 30 (var -> MAIN .)
    DIVIDE          reduce using rule 30 (var -> MAIN .)
    TIMES           reduce using rule 30 (var -> MAIN .)
    MINUS           reduce using rule 30 (var -> MAIN .)
    PLUS            reduce using rule 30 (var -> MAIN .)
    RPAREN          reduce using rule 30 (var -> MAIN .)
    NEQ             reduce using rule 30 (var -> MAIN .)
    EQ              reduce using rule 30 (var -> MAIN .)
    LTE             reduce using rule 30 (var -> MAIN .)
    GTE             reduce using rule 30 (var -> MAIN .)
    LT              reduce using rule 30 (var -> MAIN .)
    GT              reduce using rule 30 (var -> MAIN .)
    OR              reduce using rule 30 (var -> MAIN .)
    AND             reduce using rule 30 (var -> MAIN .)
    TO              reduce using rule 30 (var -> MAIN .)
    BY              reduce using rule 30 (var -> MAIN .)
    DO              reduce using rule 30 (var -> MAIN .)


state 43

    (31) var -> VARS .
    COMMA           reduce using rule 31 (var -> VARS .)
    SEMICOLON       reduce using rule 31 (var -> VARS .)
    ASSIGN          reduce using rule 31 (var -> VARS .)
    DIVIDE          reduce using rule 31 (var -> VARS .)
    TIMES           reduce using rule 31 (var -> VARS .)
    MINUS           reduce using rule 31 (var -> VARS .)
    PLUS            reduce using rule 31 (var -> VARS .)
    RPAREN          reduce using rule 31 (var -> VARS .)
    NEQ             reduce using rule 31 (var -> VARS .)
    EQ              reduce using rule 31 (var -> VARS .)
    LTE             reduce using rule 31 (var -> VARS .)
    GTE             reduce using rule 31 (var -> VARS .)
    LT              reduce using rule 31 (var -> VARS .)
    GT              reduce using rule 31 (var -> VARS .)
    OR              reduce using rule 31 (var -> VARS .)
    AND             reduce using rule 31 (var -> VARS .)
    TO              reduce using rule 31 (var -> VARS .)
    BY              reduce using rule 31 (var -> VARS .)
    DO              reduce using rule 31 (var -> VARS .)


state 44

    (32) var -> PROGRAM .
    COMMA           reduce using rule 32 (var -> PROGRAM .)
    SEMICOLON       reduce using rule 32 (var -> PROGRAM .)
    ASSIGN          reduce using rule 32 (var -> PROGRAM .)
    DIVIDE          reduce using rule 32 (var -> PROGRAM .)
    TIMES           reduce using rule 32 (var -> PROGRAM .)
    MINUS           reduce using rule 32 (var -> PROGRAM .)
    PLUS            reduce using rule 32 (var -> PROGRAM .)
    RPAREN          reduce using rule 32 (var -> PROGRAM .)
    NEQ             reduce using rule 32 (var -> PROGRAM .)
    EQ              reduce using rule 32 (var -> PROGRAM .)
    LTE             reduce using rule 32 (var -> PROGRAM .)
    GTE             reduce using rule 32 (var -> PROGRAM .)
    LT              reduce using rule 32 (var -> PROGRAM .)
    GT              reduce using rule 32 (var -> PROGRAM .)
    OR              reduce using rule 32 (var -> PROGRAM .)
    AND             reduce using rule 32 (var -> PROGRAM .)
    TO              reduce using rule 32 (var -> PROGRAM .)
    BY              reduce using rule 32 (var -> PROGRAM .)
    DO              reduce using rule 32 (var -> PROGRAM .)


state 45

    (33) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID . LBRACKET CTEINT RBRACKET
    (35) var -> ID .
    LBRACKET        shift and go to state 51
    COMMA           reduce using rule 35 (var -> ID .)
    SEMICOLON       reduce using rule 35 (var -> ID .)
    ASSIGN          reduce using rule 35 (var -> ID .)
    RPAREN          reduce using rule 35 (var -> ID .)


state 46

    (3) main_block -> MAIN changecontext . LPAREN RPAREN declareblock
    LPAREN          shift and go to state 52


state 47

    (41) typefunc -> type ID . changecontext LPAREN params RPAREN returnblock
    (117) changecontext -> .
    LPAREN          reduce using rule 117 (changecontext -> .)

    changecontext                  shift and go to state 53

state 48

    (40) voidfunc -> VOID ID . changecontext LPAREN params RPAREN declareblock
    (117) changecontext -> .
    LPAREN          reduce using rule 117 (changecontext -> .)

    changecontext                  shift and go to state 54

state 49

    (11) decvar_line -> type decvar SEMICOLON . decvar_line
    (12) decvar_line -> type decvar SEMICOLON .
    (11) decvar_line -> . type decvar SEMICOLON decvar_line
    (12) decvar_line -> . type decvar SEMICOLON
    (106) type -> . BOOL
    (107) type -> . FLOAT
    (108) type -> . INT
    FUNC            reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    MAIN            reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    ID              reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    FROM            reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    DO              reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    WHILE           reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    INPUT           reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    PRINT           reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    IF              reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    RCURLY          reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    RETURN          reduce using rule 12 (decvar_line -> type decvar SEMICOLON .)
    BOOL            shift and go to state 15
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    type                           shift and go to state 14
    decvar_line                    shift and go to state 55

state 50

    (13) decvar -> var COMMA . decvar
    (13) decvar -> . var COMMA decvar
    (14) decvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 26
    decvar                         shift and go to state 56

state 51

    (33) var -> ID LBRACKET . CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 57


state 52

    (3) main_block -> MAIN changecontext LPAREN . RPAREN declareblock
    RPAREN          shift and go to state 58


state 53

    (41) typefunc -> type ID changecontext . LPAREN params RPAREN returnblock
    LPAREN          shift and go to state 59


state 54

    (40) voidfunc -> VOID ID changecontext . LPAREN params RPAREN declareblock
    LPAREN          shift and go to state 60


state 55

    (11) decvar_line -> type decvar SEMICOLON decvar_line .
    FUNC            reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    MAIN            reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    DO              reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 11 (decvar_line -> type decvar SEMICOLON decvar_line .)


state 56

    (13) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 13 (decvar -> var COMMA decvar .)


state 57

    (33) var -> ID LBRACKET CTEINT . RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 61


state 58

    (3) main_block -> MAIN changecontext LPAREN RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 63

    declareblock                   shift and go to state 62

state 59

    (41) typefunc -> type ID changecontext LPAREN . params RPAREN returnblock
    (42) params -> . empty
    (43) params -> . type ID COMMA params
    (44) params -> . type ID
    (119) empty -> .
    (106) type -> . BOOL
    (107) type -> . FLOAT
    (108) type -> . INT
    RPAREN          reduce using rule 119 (empty -> .)
    BOOL            shift and go to state 15
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    type                           shift and go to state 64
    params                         shift and go to state 65
    empty                          shift and go to state 66

state 60

    (40) voidfunc -> VOID ID changecontext LPAREN . params RPAREN declareblock
    (42) params -> . empty
    (43) params -> . type ID COMMA params
    (44) params -> . type ID
    (119) empty -> .
    (106) type -> . BOOL
    (107) type -> . FLOAT
    (108) type -> . INT
    RPAREN          reduce using rule 119 (empty -> .)
    BOOL            shift and go to state 15
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    params                         shift and go to state 67
    empty                          shift and go to state 66
    type                           shift and go to state 64

state 61

    (33) var -> ID LBRACKET CTEINT RBRACKET . LBRACKET CTEINT RBRACKET
    (34) var -> ID LBRACKET CTEINT RBRACKET .
    LBRACKET        shift and go to state 68
    COMMA           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    BY              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)


state 62

    (3) main_block -> MAIN changecontext LPAREN RPAREN declareblock .
    $end            reduce using rule 3 (main_block -> MAIN changecontext LPAREN RPAREN declareblock .)


state 63

    (5) declareblock -> LCURLY . decvars blockcontent RCURLY
    (9) decvars -> . empty
    (10) decvars -> . VARS decvar_line
    (119) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 119 (empty -> .)
    FROM            reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    RCURLY          reduce using rule 119 (empty -> .)

    decvars                        shift and go to state 69
    empty                          shift and go to state 7

state 64

    (43) params -> type . ID COMMA params
    (44) params -> type . ID
    ID              shift and go to state 70


state 65

    (41) typefunc -> type ID changecontext LPAREN params . RPAREN returnblock
    RPAREN          shift and go to state 71


state 66

    (42) params -> empty .
    RPAREN          reduce using rule 42 (params -> empty .)


state 67

    (40) voidfunc -> VOID ID changecontext LPAREN params . RPAREN declareblock
    RPAREN          shift and go to state 72


state 68

    (33) var -> ID LBRACKET CTEINT RBRACKET LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 73


state 69

    (5) declareblock -> LCURLY decvars . blockcontent RCURLY
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (119) empty -> .
    (109) statute -> . call
    (110) statute -> . forloop
    (111) statute -> . dowhileloop
    (112) statute -> . whileloop
    (113) statute -> . read
    (114) statute -> . write
    (115) statute -> . condition
    (116) statute -> . assignment
    (45) call -> . ID LPAREN callvalues RPAREN
    (82) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (83) forloop -> . FROM var ASSIGN expression TO expression DO block
    (85) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (84) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (89) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (93) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (98) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (99) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (86) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (88) assignment_var -> . ID
    RCURLY          reduce using rule 119 (empty -> .)
    ID              shift and go to state 85
    FROM            shift and go to state 86
    DO              shift and go to state 87
    WHILE           shift and go to state 88
    INPUT           shift and go to state 89
    PRINT           shift and go to state 90
    IF              shift and go to state 91

    blockcontent                   shift and go to state 74
    empty                          shift and go to state 75
    statute                        shift and go to state 76
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 92

state 70

    (43) params -> type ID . COMMA params
    (44) params -> type ID .
    COMMA           shift and go to state 93
    RPAREN          reduce using rule 44 (params -> type ID .)


state 71

    (41) typefunc -> type ID changecontext LPAREN params RPAREN . returnblock
    (6) returnblock -> . LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY
    LCURLY          shift and go to state 95

    returnblock                    shift and go to state 94

state 72

    (40) voidfunc -> VOID ID changecontext LPAREN params RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 63

    declareblock                   shift and go to state 96

state 73

    (33) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 97


state 74

    (5) declareblock -> LCURLY decvars blockcontent . RCURLY
    RCURLY          shift and go to state 98


state 75

    (7) blockcontent -> empty .
    RCURLY          reduce using rule 7 (blockcontent -> empty .)
    RETURN          reduce using rule 7 (blockcontent -> empty .)


state 76

    (8) blockcontent -> statute . blockcontent
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (119) empty -> .
    (109) statute -> . call
    (110) statute -> . forloop
    (111) statute -> . dowhileloop
    (112) statute -> . whileloop
    (113) statute -> . read
    (114) statute -> . write
    (115) statute -> . condition
    (116) statute -> . assignment
    (45) call -> . ID LPAREN callvalues RPAREN
    (82) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (83) forloop -> . FROM var ASSIGN expression TO expression DO block
    (85) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (84) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (89) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (93) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (98) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (99) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (86) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (88) assignment_var -> . ID
    RCURLY          reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)
    ID              shift and go to state 85
    FROM            shift and go to state 86
    DO              shift and go to state 87
    WHILE           shift and go to state 88
    INPUT           shift and go to state 89
    PRINT           shift and go to state 90
    IF              shift and go to state 91

    statute                        shift and go to state 76
    blockcontent                   shift and go to state 99
    empty                          shift and go to state 75
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 92

state 77

    (109) statute -> call .
    ID              reduce using rule 109 (statute -> call .)
    FROM            reduce using rule 109 (statute -> call .)
    DO              reduce using rule 109 (statute -> call .)
    WHILE           reduce using rule 109 (statute -> call .)
    INPUT           reduce using rule 109 (statute -> call .)
    PRINT           reduce using rule 109 (statute -> call .)
    IF              reduce using rule 109 (statute -> call .)
    RCURLY          reduce using rule 109 (statute -> call .)
    RETURN          reduce using rule 109 (statute -> call .)


state 78

    (110) statute -> forloop .
    ID              reduce using rule 110 (statute -> forloop .)
    FROM            reduce using rule 110 (statute -> forloop .)
    DO              reduce using rule 110 (statute -> forloop .)
    WHILE           reduce using rule 110 (statute -> forloop .)
    INPUT           reduce using rule 110 (statute -> forloop .)
    PRINT           reduce using rule 110 (statute -> forloop .)
    IF              reduce using rule 110 (statute -> forloop .)
    RCURLY          reduce using rule 110 (statute -> forloop .)
    RETURN          reduce using rule 110 (statute -> forloop .)


state 79

    (111) statute -> dowhileloop .
    ID              reduce using rule 111 (statute -> dowhileloop .)
    FROM            reduce using rule 111 (statute -> dowhileloop .)
    DO              reduce using rule 111 (statute -> dowhileloop .)
    WHILE           reduce using rule 111 (statute -> dowhileloop .)
    INPUT           reduce using rule 111 (statute -> dowhileloop .)
    PRINT           reduce using rule 111 (statute -> dowhileloop .)
    IF              reduce using rule 111 (statute -> dowhileloop .)
    RCURLY          reduce using rule 111 (statute -> dowhileloop .)
    RETURN          reduce using rule 111 (statute -> dowhileloop .)


state 80

    (112) statute -> whileloop .
    ID              reduce using rule 112 (statute -> whileloop .)
    FROM            reduce using rule 112 (statute -> whileloop .)
    DO              reduce using rule 112 (statute -> whileloop .)
    WHILE           reduce using rule 112 (statute -> whileloop .)
    INPUT           reduce using rule 112 (statute -> whileloop .)
    PRINT           reduce using rule 112 (statute -> whileloop .)
    IF              reduce using rule 112 (statute -> whileloop .)
    RCURLY          reduce using rule 112 (statute -> whileloop .)
    RETURN          reduce using rule 112 (statute -> whileloop .)


state 81

    (113) statute -> read .
    ID              reduce using rule 113 (statute -> read .)
    FROM            reduce using rule 113 (statute -> read .)
    DO              reduce using rule 113 (statute -> read .)
    WHILE           reduce using rule 113 (statute -> read .)
    INPUT           reduce using rule 113 (statute -> read .)
    PRINT           reduce using rule 113 (statute -> read .)
    IF              reduce using rule 113 (statute -> read .)
    RCURLY          reduce using rule 113 (statute -> read .)
    RETURN          reduce using rule 113 (statute -> read .)


state 82

    (114) statute -> write .
    ID              reduce using rule 114 (statute -> write .)
    FROM            reduce using rule 114 (statute -> write .)
    DO              reduce using rule 114 (statute -> write .)
    WHILE           reduce using rule 114 (statute -> write .)
    INPUT           reduce using rule 114 (statute -> write .)
    PRINT           reduce using rule 114 (statute -> write .)
    IF              reduce using rule 114 (statute -> write .)
    RCURLY          reduce using rule 114 (statute -> write .)
    RETURN          reduce using rule 114 (statute -> write .)


state 83

    (115) statute -> condition .
    ID              reduce using rule 115 (statute -> condition .)
    FROM            reduce using rule 115 (statute -> condition .)
    DO              reduce using rule 115 (statute -> condition .)
    WHILE           reduce using rule 115 (statute -> condition .)
    INPUT           reduce using rule 115 (statute -> condition .)
    PRINT           reduce using rule 115 (statute -> condition .)
    IF              reduce using rule 115 (statute -> condition .)
    RCURLY          reduce using rule 115 (statute -> condition .)
    RETURN          reduce using rule 115 (statute -> condition .)


state 84

    (116) statute -> assignment .
    ID              reduce using rule 116 (statute -> assignment .)
    FROM            reduce using rule 116 (statute -> assignment .)
    DO              reduce using rule 116 (statute -> assignment .)
    WHILE           reduce using rule 116 (statute -> assignment .)
    INPUT           reduce using rule 116 (statute -> assignment .)
    PRINT           reduce using rule 116 (statute -> assignment .)
    IF              reduce using rule 116 (statute -> assignment .)
    RCURLY          reduce using rule 116 (statute -> assignment .)
    RETURN          reduce using rule 116 (statute -> assignment .)


state 85

    (45) call -> ID . LPAREN callvalues RPAREN
    (88) assignment_var -> ID .
    LPAREN          shift and go to state 100
    ASSIGN          reduce using rule 88 (assignment_var -> ID .)


state 86

    (82) forloop -> FROM . var ASSIGN expression TO expression BY expression DO block
    (83) forloop -> FROM . var ASSIGN expression TO expression DO block
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 101

state 87

    (85) dowhileloop -> DO . saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (101) saveposition -> .
    LCURLY          reduce using rule 101 (saveposition -> .)

    saveposition                   shift and go to state 102

state 88

    (84) whileloop -> WHILE . saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (101) saveposition -> .
    LPAREN          reduce using rule 101 (saveposition -> .)

    saveposition                   shift and go to state 103

state 89

    (89) read -> INPUT . LPAREN readaux RPAREN SEMICOLON
    LPAREN          shift and go to state 104


state 90

    (93) write -> PRINT . LPAREN writeaux RPAREN SEMICOLON
    LPAREN          shift and go to state 105


state 91

    (98) condition -> IF . LPAREN super_exp RPAREN openjumpslot block filljumps
    (99) condition -> IF . LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    LPAREN          shift and go to state 106


state 92

    (86) assignment -> assignment_var . assignment_sign expression SEMICOLON
    (87) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 108

    assignment_sign                shift and go to state 107

state 93

    (43) params -> type ID COMMA . params
    (42) params -> . empty
    (43) params -> . type ID COMMA params
    (44) params -> . type ID
    (119) empty -> .
    (106) type -> . BOOL
    (107) type -> . FLOAT
    (108) type -> . INT
    RPAREN          reduce using rule 119 (empty -> .)
    BOOL            shift and go to state 15
    FLOAT           shift and go to state 16
    INT             shift and go to state 17

    type                           shift and go to state 64
    params                         shift and go to state 109
    empty                          shift and go to state 66

state 94

    (41) typefunc -> type ID changecontext LPAREN params RPAREN returnblock .
    FUNC            reduce using rule 41 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)
    MAIN            reduce using rule 41 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)


state 95

    (6) returnblock -> LCURLY . decvars blockcontent RETURN exp SEMICOLON RCURLY
    (9) decvars -> . empty
    (10) decvars -> . VARS decvar_line
    (119) empty -> .
    VARS            shift and go to state 8
    ID              reduce using rule 119 (empty -> .)
    FROM            reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)
    WHILE           reduce using rule 119 (empty -> .)
    INPUT           reduce using rule 119 (empty -> .)
    PRINT           reduce using rule 119 (empty -> .)
    IF              reduce using rule 119 (empty -> .)
    RETURN          reduce using rule 119 (empty -> .)

    decvars                        shift and go to state 110
    empty                          shift and go to state 7

state 96

    (40) voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock .
    FUNC            reduce using rule 40 (voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock .)
    MAIN            reduce using rule 40 (voidfunc -> VOID ID changecontext LPAREN params RPAREN declareblock .)


state 97

    (33) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .
    COMMA           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    BY              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)


state 98

    (5) declareblock -> LCURLY decvars blockcontent RCURLY .
    $end            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    FUNC            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    MAIN            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)


state 99

    (8) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 8 (blockcontent -> statute blockcontent .)
    RETURN          reduce using rule 8 (blockcontent -> statute blockcontent .)


state 100

    (45) call -> ID LPAREN . callvalues RPAREN
    (46) callvalues -> . empty
    (47) callvalues -> . exp COMMA callvalues
    (48) callvalues -> . exp
    (119) empty -> .
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    RPAREN          reduce using rule 119 (empty -> .)
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    callvalues                     shift and go to state 113
    empty                          shift and go to state 114
    exp                            shift and go to state 115
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 101

    (82) forloop -> FROM var . ASSIGN expression TO expression BY expression DO block
    (83) forloop -> FROM var . ASSIGN expression TO expression DO block
    ASSIGN          shift and go to state 124


state 102

    (85) dowhileloop -> DO saveposition . block WHILE LPAREN expression RPAREN openjumpslot
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 126

    block                          shift and go to state 125

state 103

    (84) whileloop -> WHILE saveposition . LPAREN expression RPAREN openjumpslot block filljumps
    LPAREN          shift and go to state 127


state 104

    (89) read -> INPUT LPAREN . readaux RPAREN SEMICOLON
    (90) readaux -> . readvalue COMMA readaux
    (91) readaux -> . readvalue
    (92) readvalue -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    readaux                        shift and go to state 128
    readvalue                      shift and go to state 129
    var                            shift and go to state 130

state 105

    (93) write -> PRINT LPAREN . writeaux RPAREN SEMICOLON
    (94) writeaux -> . writevalues
    (95) writeaux -> . writevalues COMMA writeaux
    (96) writevalues -> . CTESTRING
    (97) writevalues -> . super_exp
    (51) super_exp -> . expression super_exp_quadgen super_exp_aux
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    CTESTRING       shift and go to state 133
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    writeaux                       shift and go to state 131
    writevalues                    shift and go to state 132
    super_exp                      shift and go to state 134
    expression                     shift and go to state 135
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 106

    (98) condition -> IF LPAREN . super_exp RPAREN openjumpslot block filljumps
    (99) condition -> IF LPAREN . super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (51) super_exp -> . expression super_exp_quadgen super_exp_aux
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 137
    expression                     shift and go to state 135
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 107

    (86) assignment -> assignment_var assignment_sign . expression SEMICOLON
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 138
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 108

    (87) assignment_sign -> ASSIGN .
    LPAREN          reduce using rule 87 (assignment_sign -> ASSIGN .)
    CTEBOOL         reduce using rule 87 (assignment_sign -> ASSIGN .)
    CTEFLOAT        reduce using rule 87 (assignment_sign -> ASSIGN .)
    CTEINT          reduce using rule 87 (assignment_sign -> ASSIGN .)
    ID              reduce using rule 87 (assignment_sign -> ASSIGN .)
    BOOL            reduce using rule 87 (assignment_sign -> ASSIGN .)
    FLOAT           reduce using rule 87 (assignment_sign -> ASSIGN .)
    INT             reduce using rule 87 (assignment_sign -> ASSIGN .)
    ELSE            reduce using rule 87 (assignment_sign -> ASSIGN .)
    IF              reduce using rule 87 (assignment_sign -> ASSIGN .)
    PRINT           reduce using rule 87 (assignment_sign -> ASSIGN .)
    INPUT           reduce using rule 87 (assignment_sign -> ASSIGN .)
    WHILE           reduce using rule 87 (assignment_sign -> ASSIGN .)
    DO              reduce using rule 87 (assignment_sign -> ASSIGN .)
    BY              reduce using rule 87 (assignment_sign -> ASSIGN .)
    TO              reduce using rule 87 (assignment_sign -> ASSIGN .)
    FROM            reduce using rule 87 (assignment_sign -> ASSIGN .)
    VOID            reduce using rule 87 (assignment_sign -> ASSIGN .)
    RETURN          reduce using rule 87 (assignment_sign -> ASSIGN .)
    FUNC            reduce using rule 87 (assignment_sign -> ASSIGN .)
    MAIN            reduce using rule 87 (assignment_sign -> ASSIGN .)
    VARS            reduce using rule 87 (assignment_sign -> ASSIGN .)
    PROGRAM         reduce using rule 87 (assignment_sign -> ASSIGN .)


state 109

    (43) params -> type ID COMMA params .
    RPAREN          reduce using rule 43 (params -> type ID COMMA params .)


state 110

    (6) returnblock -> LCURLY decvars . blockcontent RETURN exp SEMICOLON RCURLY
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (119) empty -> .
    (109) statute -> . call
    (110) statute -> . forloop
    (111) statute -> . dowhileloop
    (112) statute -> . whileloop
    (113) statute -> . read
    (114) statute -> . write
    (115) statute -> . condition
    (116) statute -> . assignment
    (45) call -> . ID LPAREN callvalues RPAREN
    (82) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (83) forloop -> . FROM var ASSIGN expression TO expression DO block
    (85) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (84) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (89) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (93) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (98) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (99) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (86) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (88) assignment_var -> . ID
    RETURN          reduce using rule 119 (empty -> .)
    ID              shift and go to state 85
    FROM            shift and go to state 86
    DO              shift and go to state 87
    WHILE           shift and go to state 88
    INPUT           shift and go to state 89
    PRINT           shift and go to state 90
    IF              shift and go to state 91

    blockcontent                   shift and go to state 139
    empty                          shift and go to state 75
    statute                        shift and go to state 76
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 92

state 111

    (45) call -> ID . LPAREN callvalues RPAREN
    (33) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID . LBRACKET CTEINT RBRACKET
    (35) var -> ID .
    LPAREN          shift and go to state 100
    LBRACKET        shift and go to state 51
    DIVIDE          reduce using rule 35 (var -> ID .)
    TIMES           reduce using rule 35 (var -> ID .)
    MINUS           reduce using rule 35 (var -> ID .)
    PLUS            reduce using rule 35 (var -> ID .)
    COMMA           reduce using rule 35 (var -> ID .)
    RPAREN          reduce using rule 35 (var -> ID .)
    NEQ             reduce using rule 35 (var -> ID .)
    EQ              reduce using rule 35 (var -> ID .)
    LTE             reduce using rule 35 (var -> ID .)
    GTE             reduce using rule 35 (var -> ID .)
    LT              reduce using rule 35 (var -> ID .)
    GT              reduce using rule 35 (var -> ID .)
    OR              reduce using rule 35 (var -> ID .)
    AND             reduce using rule 35 (var -> ID .)
    SEMICOLON       reduce using rule 35 (var -> ID .)
    TO              reduce using rule 35 (var -> ID .)
    BY              reduce using rule 35 (var -> ID .)
    DO              reduce using rule 35 (var -> ID .)


state 112

    (77) factor -> LPAREN . fakefloor super_exp RPAREN
    (81) fakefloor -> .
    LPAREN          reduce using rule 81 (fakefloor -> .)
    CTEBOOL         reduce using rule 81 (fakefloor -> .)
    CTEFLOAT        reduce using rule 81 (fakefloor -> .)
    CTEINT          reduce using rule 81 (fakefloor -> .)
    ID              reduce using rule 81 (fakefloor -> .)
    BOOL            reduce using rule 81 (fakefloor -> .)
    FLOAT           reduce using rule 81 (fakefloor -> .)
    INT             reduce using rule 81 (fakefloor -> .)
    ELSE            reduce using rule 81 (fakefloor -> .)
    IF              reduce using rule 81 (fakefloor -> .)
    PRINT           reduce using rule 81 (fakefloor -> .)
    INPUT           reduce using rule 81 (fakefloor -> .)
    WHILE           reduce using rule 81 (fakefloor -> .)
    DO              reduce using rule 81 (fakefloor -> .)
    BY              reduce using rule 81 (fakefloor -> .)
    TO              reduce using rule 81 (fakefloor -> .)
    FROM            reduce using rule 81 (fakefloor -> .)
    VOID            reduce using rule 81 (fakefloor -> .)
    RETURN          reduce using rule 81 (fakefloor -> .)
    FUNC            reduce using rule 81 (fakefloor -> .)
    MAIN            reduce using rule 81 (fakefloor -> .)
    VARS            reduce using rule 81 (fakefloor -> .)
    PROGRAM         reduce using rule 81 (fakefloor -> .)

    fakefloor                      shift and go to state 140

state 113

    (45) call -> ID LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 141


state 114

    (46) callvalues -> empty .
    RPAREN          reduce using rule 46 (callvalues -> empty .)


state 115

    (47) callvalues -> exp . COMMA callvalues
    (48) callvalues -> exp .
    COMMA           shift and go to state 142
    RPAREN          reduce using rule 48 (callvalues -> exp .)


state 116

    (67) exp -> term . exp_quadgen exp_aux
    (70) exp_quadgen -> .
    MINUS           reduce using rule 70 (exp_quadgen -> .)
    PLUS            reduce using rule 70 (exp_quadgen -> .)
    COMMA           reduce using rule 70 (exp_quadgen -> .)
    RPAREN          reduce using rule 70 (exp_quadgen -> .)
    NEQ             reduce using rule 70 (exp_quadgen -> .)
    EQ              reduce using rule 70 (exp_quadgen -> .)
    LTE             reduce using rule 70 (exp_quadgen -> .)
    GTE             reduce using rule 70 (exp_quadgen -> .)
    LT              reduce using rule 70 (exp_quadgen -> .)
    GT              reduce using rule 70 (exp_quadgen -> .)
    OR              reduce using rule 70 (exp_quadgen -> .)
    AND             reduce using rule 70 (exp_quadgen -> .)
    SEMICOLON       reduce using rule 70 (exp_quadgen -> .)
    TO              reduce using rule 70 (exp_quadgen -> .)
    BY              reduce using rule 70 (exp_quadgen -> .)
    DO              reduce using rule 70 (exp_quadgen -> .)

    exp_quadgen                    shift and go to state 143

state 117

    (73) term -> factor . term_quadgen term_aux
    (76) term_quadgen -> .
    DIVIDE          reduce using rule 76 (term_quadgen -> .)
    TIMES           reduce using rule 76 (term_quadgen -> .)
    MINUS           reduce using rule 76 (term_quadgen -> .)
    PLUS            reduce using rule 76 (term_quadgen -> .)
    COMMA           reduce using rule 76 (term_quadgen -> .)
    RPAREN          reduce using rule 76 (term_quadgen -> .)
    NEQ             reduce using rule 76 (term_quadgen -> .)
    EQ              reduce using rule 76 (term_quadgen -> .)
    LTE             reduce using rule 76 (term_quadgen -> .)
    GTE             reduce using rule 76 (term_quadgen -> .)
    LT              reduce using rule 76 (term_quadgen -> .)
    GT              reduce using rule 76 (term_quadgen -> .)
    OR              reduce using rule 76 (term_quadgen -> .)
    AND             reduce using rule 76 (term_quadgen -> .)
    SEMICOLON       reduce using rule 76 (term_quadgen -> .)
    TO              reduce using rule 76 (term_quadgen -> .)
    BY              reduce using rule 76 (term_quadgen -> .)
    DO              reduce using rule 76 (term_quadgen -> .)

    term_quadgen                   shift and go to state 144

state 118

    (78) factor -> varcte .
    DIVIDE          reduce using rule 78 (factor -> varcte .)
    TIMES           reduce using rule 78 (factor -> varcte .)
    MINUS           reduce using rule 78 (factor -> varcte .)
    PLUS            reduce using rule 78 (factor -> varcte .)
    COMMA           reduce using rule 78 (factor -> varcte .)
    RPAREN          reduce using rule 78 (factor -> varcte .)
    NEQ             reduce using rule 78 (factor -> varcte .)
    EQ              reduce using rule 78 (factor -> varcte .)
    LTE             reduce using rule 78 (factor -> varcte .)
    GTE             reduce using rule 78 (factor -> varcte .)
    LT              reduce using rule 78 (factor -> varcte .)
    GT              reduce using rule 78 (factor -> varcte .)
    OR              reduce using rule 78 (factor -> varcte .)
    AND             reduce using rule 78 (factor -> varcte .)
    SEMICOLON       reduce using rule 78 (factor -> varcte .)
    TO              reduce using rule 78 (factor -> varcte .)
    BY              reduce using rule 78 (factor -> varcte .)
    DO              reduce using rule 78 (factor -> varcte .)


state 119

    (79) factor -> call .
    DIVIDE          reduce using rule 79 (factor -> call .)
    TIMES           reduce using rule 79 (factor -> call .)
    MINUS           reduce using rule 79 (factor -> call .)
    PLUS            reduce using rule 79 (factor -> call .)
    COMMA           reduce using rule 79 (factor -> call .)
    RPAREN          reduce using rule 79 (factor -> call .)
    NEQ             reduce using rule 79 (factor -> call .)
    EQ              reduce using rule 79 (factor -> call .)
    LTE             reduce using rule 79 (factor -> call .)
    GTE             reduce using rule 79 (factor -> call .)
    LT              reduce using rule 79 (factor -> call .)
    GT              reduce using rule 79 (factor -> call .)
    OR              reduce using rule 79 (factor -> call .)
    AND             reduce using rule 79 (factor -> call .)
    SEMICOLON       reduce using rule 79 (factor -> call .)
    TO              reduce using rule 79 (factor -> call .)
    BY              reduce using rule 79 (factor -> call .)
    DO              reduce using rule 79 (factor -> call .)


state 120

    (80) factor -> var .
    DIVIDE          reduce using rule 80 (factor -> var .)
    TIMES           reduce using rule 80 (factor -> var .)
    MINUS           reduce using rule 80 (factor -> var .)
    PLUS            reduce using rule 80 (factor -> var .)
    COMMA           reduce using rule 80 (factor -> var .)
    RPAREN          reduce using rule 80 (factor -> var .)
    NEQ             reduce using rule 80 (factor -> var .)
    EQ              reduce using rule 80 (factor -> var .)
    LTE             reduce using rule 80 (factor -> var .)
    GTE             reduce using rule 80 (factor -> var .)
    LT              reduce using rule 80 (factor -> var .)
    GT              reduce using rule 80 (factor -> var .)
    OR              reduce using rule 80 (factor -> var .)
    AND             reduce using rule 80 (factor -> var .)
    SEMICOLON       reduce using rule 80 (factor -> var .)
    TO              reduce using rule 80 (factor -> var .)
    BY              reduce using rule 80 (factor -> var .)
    DO              reduce using rule 80 (factor -> var .)


state 121

    (103) varcte -> CTEBOOL .
    DIVIDE          reduce using rule 103 (varcte -> CTEBOOL .)
    TIMES           reduce using rule 103 (varcte -> CTEBOOL .)
    MINUS           reduce using rule 103 (varcte -> CTEBOOL .)
    PLUS            reduce using rule 103 (varcte -> CTEBOOL .)
    COMMA           reduce using rule 103 (varcte -> CTEBOOL .)
    RPAREN          reduce using rule 103 (varcte -> CTEBOOL .)
    NEQ             reduce using rule 103 (varcte -> CTEBOOL .)
    EQ              reduce using rule 103 (varcte -> CTEBOOL .)
    LTE             reduce using rule 103 (varcte -> CTEBOOL .)
    GTE             reduce using rule 103 (varcte -> CTEBOOL .)
    LT              reduce using rule 103 (varcte -> CTEBOOL .)
    GT              reduce using rule 103 (varcte -> CTEBOOL .)
    OR              reduce using rule 103 (varcte -> CTEBOOL .)
    AND             reduce using rule 103 (varcte -> CTEBOOL .)
    SEMICOLON       reduce using rule 103 (varcte -> CTEBOOL .)
    TO              reduce using rule 103 (varcte -> CTEBOOL .)
    BY              reduce using rule 103 (varcte -> CTEBOOL .)
    DO              reduce using rule 103 (varcte -> CTEBOOL .)


state 122

    (104) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 104 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 104 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 104 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 104 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 104 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 104 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 104 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 104 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 104 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 104 (varcte -> CTEFLOAT .)
    LT              reduce using rule 104 (varcte -> CTEFLOAT .)
    GT              reduce using rule 104 (varcte -> CTEFLOAT .)
    OR              reduce using rule 104 (varcte -> CTEFLOAT .)
    AND             reduce using rule 104 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 104 (varcte -> CTEFLOAT .)
    TO              reduce using rule 104 (varcte -> CTEFLOAT .)
    BY              reduce using rule 104 (varcte -> CTEFLOAT .)
    DO              reduce using rule 104 (varcte -> CTEFLOAT .)


state 123

    (105) varcte -> CTEINT .
    DIVIDE          reduce using rule 105 (varcte -> CTEINT .)
    TIMES           reduce using rule 105 (varcte -> CTEINT .)
    MINUS           reduce using rule 105 (varcte -> CTEINT .)
    PLUS            reduce using rule 105 (varcte -> CTEINT .)
    COMMA           reduce using rule 105 (varcte -> CTEINT .)
    RPAREN          reduce using rule 105 (varcte -> CTEINT .)
    NEQ             reduce using rule 105 (varcte -> CTEINT .)
    EQ              reduce using rule 105 (varcte -> CTEINT .)
    LTE             reduce using rule 105 (varcte -> CTEINT .)
    GTE             reduce using rule 105 (varcte -> CTEINT .)
    LT              reduce using rule 105 (varcte -> CTEINT .)
    GT              reduce using rule 105 (varcte -> CTEINT .)
    OR              reduce using rule 105 (varcte -> CTEINT .)
    AND             reduce using rule 105 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 105 (varcte -> CTEINT .)
    TO              reduce using rule 105 (varcte -> CTEINT .)
    BY              reduce using rule 105 (varcte -> CTEINT .)
    DO              reduce using rule 105 (varcte -> CTEINT .)


state 124

    (82) forloop -> FROM var ASSIGN . expression TO expression BY expression DO block
    (83) forloop -> FROM var ASSIGN . expression TO expression DO block
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    var                            shift and go to state 120
    expression                     shift and go to state 145
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119

state 125

    (85) dowhileloop -> DO saveposition block . WHILE LPAREN expression RPAREN openjumpslot
    WHILE           shift and go to state 146


state 126

    (4) block -> LCURLY . blockcontent RCURLY
    (7) blockcontent -> . empty
    (8) blockcontent -> . statute blockcontent
    (119) empty -> .
    (109) statute -> . call
    (110) statute -> . forloop
    (111) statute -> . dowhileloop
    (112) statute -> . whileloop
    (113) statute -> . read
    (114) statute -> . write
    (115) statute -> . condition
    (116) statute -> . assignment
    (45) call -> . ID LPAREN callvalues RPAREN
    (82) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (83) forloop -> . FROM var ASSIGN expression TO expression DO block
    (85) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (84) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (89) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (93) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (98) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (99) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (86) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (88) assignment_var -> . ID
    RCURLY          reduce using rule 119 (empty -> .)
    ID              shift and go to state 85
    FROM            shift and go to state 86
    DO              shift and go to state 87
    WHILE           shift and go to state 88
    INPUT           shift and go to state 89
    PRINT           shift and go to state 90
    IF              shift and go to state 91

    blockcontent                   shift and go to state 147
    empty                          shift and go to state 75
    statute                        shift and go to state 76
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 92

state 127

    (84) whileloop -> WHILE saveposition LPAREN . expression RPAREN openjumpslot block filljumps
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 148
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 128

    (89) read -> INPUT LPAREN readaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 149


state 129

    (90) readaux -> readvalue . COMMA readaux
    (91) readaux -> readvalue .
    COMMA           shift and go to state 150
    RPAREN          reduce using rule 91 (readaux -> readvalue .)


state 130

    (92) readvalue -> var .
    COMMA           reduce using rule 92 (readvalue -> var .)
    RPAREN          reduce using rule 92 (readvalue -> var .)


state 131

    (93) write -> PRINT LPAREN writeaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 151


state 132

    (94) writeaux -> writevalues .
    (95) writeaux -> writevalues . COMMA writeaux
    RPAREN          reduce using rule 94 (writeaux -> writevalues .)
    COMMA           shift and go to state 152


state 133

    (96) writevalues -> CTESTRING .
    COMMA           reduce using rule 96 (writevalues -> CTESTRING .)
    RPAREN          reduce using rule 96 (writevalues -> CTESTRING .)


state 134

    (97) writevalues -> super_exp .
    COMMA           reduce using rule 97 (writevalues -> super_exp .)
    RPAREN          reduce using rule 97 (writevalues -> super_exp .)


state 135

    (51) super_exp -> expression . super_exp_quadgen super_exp_aux
    (54) super_exp_quadgen -> .
    OR              reduce using rule 54 (super_exp_quadgen -> .)
    AND             reduce using rule 54 (super_exp_quadgen -> .)
    COMMA           reduce using rule 54 (super_exp_quadgen -> .)
    RPAREN          reduce using rule 54 (super_exp_quadgen -> .)

    super_exp_quadgen              shift and go to state 153

state 136

    (57) expression -> exp . expression_quadgen expression_aux
    (64) expression_quadgen -> .
    NEQ             reduce using rule 64 (expression_quadgen -> .)
    EQ              reduce using rule 64 (expression_quadgen -> .)
    LTE             reduce using rule 64 (expression_quadgen -> .)
    GTE             reduce using rule 64 (expression_quadgen -> .)
    LT              reduce using rule 64 (expression_quadgen -> .)
    GT              reduce using rule 64 (expression_quadgen -> .)
    OR              reduce using rule 64 (expression_quadgen -> .)
    AND             reduce using rule 64 (expression_quadgen -> .)
    COMMA           reduce using rule 64 (expression_quadgen -> .)
    RPAREN          reduce using rule 64 (expression_quadgen -> .)
    SEMICOLON       reduce using rule 64 (expression_quadgen -> .)
    TO              reduce using rule 64 (expression_quadgen -> .)
    BY              reduce using rule 64 (expression_quadgen -> .)
    DO              reduce using rule 64 (expression_quadgen -> .)

    expression_quadgen             shift and go to state 154

state 137

    (98) condition -> IF LPAREN super_exp . RPAREN openjumpslot block filljumps
    (99) condition -> IF LPAREN super_exp . RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    RPAREN          shift and go to state 155


state 138

    (86) assignment -> assignment_var assignment_sign expression . SEMICOLON
    SEMICOLON       shift and go to state 156


state 139

    (6) returnblock -> LCURLY decvars blockcontent . RETURN exp SEMICOLON RCURLY
    RETURN          shift and go to state 157


state 140

    (77) factor -> LPAREN fakefloor . super_exp RPAREN
    (51) super_exp -> . expression super_exp_quadgen super_exp_aux
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 158
    expression                     shift and go to state 135
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 141

    (45) call -> ID LPAREN callvalues RPAREN .
    ID              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    FROM            reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    DO              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    IF              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    RETURN          reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    DIVIDE          reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    EQ              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    LTE             reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    GTE             reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    LT              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    GT              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    OR              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    AND             reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    TO              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)
    BY              reduce using rule 45 (call -> ID LPAREN callvalues RPAREN .)


state 142

    (47) callvalues -> exp COMMA . callvalues
    (46) callvalues -> . empty
    (47) callvalues -> . exp COMMA callvalues
    (48) callvalues -> . exp
    (119) empty -> .
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    RPAREN          reduce using rule 119 (empty -> .)
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    exp                            shift and go to state 115
    callvalues                     shift and go to state 159
    empty                          shift and go to state 114
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 143

    (67) exp -> term exp_quadgen . exp_aux
    (65) exp_aux -> . exp_sign exp
    (66) exp_aux -> . empty
    (68) exp_sign -> . MINUS
    (69) exp_sign -> . PLUS
    (119) empty -> .
    MINUS           shift and go to state 163
    PLUS            shift and go to state 164
    COMMA           reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    NEQ             reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    LTE             reduce using rule 119 (empty -> .)
    GTE             reduce using rule 119 (empty -> .)
    LT              reduce using rule 119 (empty -> .)
    GT              reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    TO              reduce using rule 119 (empty -> .)
    BY              reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)

    exp_aux                        shift and go to state 160
    exp_sign                       shift and go to state 161
    empty                          shift and go to state 162

state 144

    (73) term -> factor term_quadgen . term_aux
    (71) term_aux -> . term_sign term
    (72) term_aux -> . empty
    (74) term_sign -> . DIVIDE
    (75) term_sign -> . TIMES
    (119) empty -> .
    DIVIDE          shift and go to state 168
    TIMES           shift and go to state 169
    MINUS           reduce using rule 119 (empty -> .)
    PLUS            reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    NEQ             reduce using rule 119 (empty -> .)
    EQ              reduce using rule 119 (empty -> .)
    LTE             reduce using rule 119 (empty -> .)
    GTE             reduce using rule 119 (empty -> .)
    LT              reduce using rule 119 (empty -> .)
    GT              reduce using rule 119 (empty -> .)
    OR              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    TO              reduce using rule 119 (empty -> .)
    BY              reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)

    term_aux                       shift and go to state 165
    term_sign                      shift and go to state 166
    empty                          shift and go to state 167

state 145

    (82) forloop -> FROM var ASSIGN expression . TO expression BY expression DO block
    (83) forloop -> FROM var ASSIGN expression . TO expression DO block
    TO              shift and go to state 170


state 146

    (85) dowhileloop -> DO saveposition block WHILE . LPAREN expression RPAREN openjumpslot
    LPAREN          shift and go to state 171


state 147

    (4) block -> LCURLY blockcontent . RCURLY
    RCURLY          shift and go to state 172


state 148

    (84) whileloop -> WHILE saveposition LPAREN expression . RPAREN openjumpslot block filljumps
    RPAREN          shift and go to state 173


state 149

    (89) read -> INPUT LPAREN readaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 174


state 150

    (90) readaux -> readvalue COMMA . readaux
    (90) readaux -> . readvalue COMMA readaux
    (91) readaux -> . readvalue
    (92) readvalue -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    readvalue                      shift and go to state 129
    readaux                        shift and go to state 175
    var                            shift and go to state 130

state 151

    (93) write -> PRINT LPAREN writeaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 176


state 152

    (95) writeaux -> writevalues COMMA . writeaux
    (94) writeaux -> . writevalues
    (95) writeaux -> . writevalues COMMA writeaux
    (96) writevalues -> . CTESTRING
    (97) writevalues -> . super_exp
    (51) super_exp -> . expression super_exp_quadgen super_exp_aux
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    CTESTRING       shift and go to state 133
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    writevalues                    shift and go to state 132
    writeaux                       shift and go to state 177
    super_exp                      shift and go to state 134
    expression                     shift and go to state 135
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 153

    (51) super_exp -> expression super_exp_quadgen . super_exp_aux
    (49) super_exp_aux -> . logic super_exp
    (50) super_exp_aux -> . empty
    (52) logic -> . OR
    (53) logic -> . AND
    (119) empty -> .
    OR              shift and go to state 181
    AND             shift and go to state 182
    COMMA           reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)

    super_exp_aux                  shift and go to state 178
    logic                          shift and go to state 179
    empty                          shift and go to state 180

state 154

    (57) expression -> exp expression_quadgen . expression_aux
    (55) expression_aux -> . relation expression
    (56) expression_aux -> . empty
    (58) relation -> . NEQ
    (59) relation -> . EQ
    (60) relation -> . LTE
    (61) relation -> . GTE
    (62) relation -> . LT
    (63) relation -> . GT
    (119) empty -> .
    NEQ             shift and go to state 186
    EQ              shift and go to state 187
    LTE             shift and go to state 188
    GTE             shift and go to state 189
    LT              shift and go to state 190
    GT              shift and go to state 191
    OR              reduce using rule 119 (empty -> .)
    AND             reduce using rule 119 (empty -> .)
    COMMA           reduce using rule 119 (empty -> .)
    RPAREN          reduce using rule 119 (empty -> .)
    SEMICOLON       reduce using rule 119 (empty -> .)
    TO              reduce using rule 119 (empty -> .)
    BY              reduce using rule 119 (empty -> .)
    DO              reduce using rule 119 (empty -> .)

    expression_aux                 shift and go to state 183
    relation                       shift and go to state 184
    empty                          shift and go to state 185

state 155

    (98) condition -> IF LPAREN super_exp RPAREN . openjumpslot block filljumps
    (99) condition -> IF LPAREN super_exp RPAREN . openjumpslot block ELSE filljumps openjumpslot block filljumps
    (100) openjumpslot -> .
    LCURLY          reduce using rule 100 (openjumpslot -> .)

    openjumpslot                   shift and go to state 192

state 156

    (86) assignment -> assignment_var assignment_sign expression SEMICOLON .
    ID              reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    FROM            reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    DO              reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    WHILE           reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    INPUT           reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    PRINT           reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    IF              reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    RCURLY          reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    RETURN          reduce using rule 86 (assignment -> assignment_var assignment_sign expression SEMICOLON .)


state 157

    (6) returnblock -> LCURLY decvars blockcontent RETURN . exp SEMICOLON RCURLY
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    exp                            shift and go to state 193
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 158

    (77) factor -> LPAREN fakefloor super_exp . RPAREN
    RPAREN          shift and go to state 194


state 159

    (47) callvalues -> exp COMMA callvalues .
    RPAREN          reduce using rule 47 (callvalues -> exp COMMA callvalues .)


state 160

    (67) exp -> term exp_quadgen exp_aux .
    COMMA           reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    RPAREN          reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    NEQ             reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    EQ              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    LTE             reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    GTE             reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    LT              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    GT              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    OR              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    AND             reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    SEMICOLON       reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    TO              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    BY              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)
    DO              reduce using rule 67 (exp -> term exp_quadgen exp_aux .)


state 161

    (65) exp_aux -> exp_sign . exp
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    exp                            shift and go to state 195
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 162

    (66) exp_aux -> empty .
    COMMA           reduce using rule 66 (exp_aux -> empty .)
    RPAREN          reduce using rule 66 (exp_aux -> empty .)
    NEQ             reduce using rule 66 (exp_aux -> empty .)
    EQ              reduce using rule 66 (exp_aux -> empty .)
    LTE             reduce using rule 66 (exp_aux -> empty .)
    GTE             reduce using rule 66 (exp_aux -> empty .)
    LT              reduce using rule 66 (exp_aux -> empty .)
    GT              reduce using rule 66 (exp_aux -> empty .)
    OR              reduce using rule 66 (exp_aux -> empty .)
    AND             reduce using rule 66 (exp_aux -> empty .)
    SEMICOLON       reduce using rule 66 (exp_aux -> empty .)
    TO              reduce using rule 66 (exp_aux -> empty .)
    BY              reduce using rule 66 (exp_aux -> empty .)
    DO              reduce using rule 66 (exp_aux -> empty .)


state 163

    (68) exp_sign -> MINUS .
    LPAREN          reduce using rule 68 (exp_sign -> MINUS .)
    CTEBOOL         reduce using rule 68 (exp_sign -> MINUS .)
    CTEFLOAT        reduce using rule 68 (exp_sign -> MINUS .)
    CTEINT          reduce using rule 68 (exp_sign -> MINUS .)
    ID              reduce using rule 68 (exp_sign -> MINUS .)
    BOOL            reduce using rule 68 (exp_sign -> MINUS .)
    FLOAT           reduce using rule 68 (exp_sign -> MINUS .)
    INT             reduce using rule 68 (exp_sign -> MINUS .)
    ELSE            reduce using rule 68 (exp_sign -> MINUS .)
    IF              reduce using rule 68 (exp_sign -> MINUS .)
    PRINT           reduce using rule 68 (exp_sign -> MINUS .)
    INPUT           reduce using rule 68 (exp_sign -> MINUS .)
    WHILE           reduce using rule 68 (exp_sign -> MINUS .)
    DO              reduce using rule 68 (exp_sign -> MINUS .)
    BY              reduce using rule 68 (exp_sign -> MINUS .)
    TO              reduce using rule 68 (exp_sign -> MINUS .)
    FROM            reduce using rule 68 (exp_sign -> MINUS .)
    VOID            reduce using rule 68 (exp_sign -> MINUS .)
    RETURN          reduce using rule 68 (exp_sign -> MINUS .)
    FUNC            reduce using rule 68 (exp_sign -> MINUS .)
    MAIN            reduce using rule 68 (exp_sign -> MINUS .)
    VARS            reduce using rule 68 (exp_sign -> MINUS .)
    PROGRAM         reduce using rule 68 (exp_sign -> MINUS .)


state 164

    (69) exp_sign -> PLUS .
    LPAREN          reduce using rule 69 (exp_sign -> PLUS .)
    CTEBOOL         reduce using rule 69 (exp_sign -> PLUS .)
    CTEFLOAT        reduce using rule 69 (exp_sign -> PLUS .)
    CTEINT          reduce using rule 69 (exp_sign -> PLUS .)
    ID              reduce using rule 69 (exp_sign -> PLUS .)
    BOOL            reduce using rule 69 (exp_sign -> PLUS .)
    FLOAT           reduce using rule 69 (exp_sign -> PLUS .)
    INT             reduce using rule 69 (exp_sign -> PLUS .)
    ELSE            reduce using rule 69 (exp_sign -> PLUS .)
    IF              reduce using rule 69 (exp_sign -> PLUS .)
    PRINT           reduce using rule 69 (exp_sign -> PLUS .)
    INPUT           reduce using rule 69 (exp_sign -> PLUS .)
    WHILE           reduce using rule 69 (exp_sign -> PLUS .)
    DO              reduce using rule 69 (exp_sign -> PLUS .)
    BY              reduce using rule 69 (exp_sign -> PLUS .)
    TO              reduce using rule 69 (exp_sign -> PLUS .)
    FROM            reduce using rule 69 (exp_sign -> PLUS .)
    VOID            reduce using rule 69 (exp_sign -> PLUS .)
    RETURN          reduce using rule 69 (exp_sign -> PLUS .)
    FUNC            reduce using rule 69 (exp_sign -> PLUS .)
    MAIN            reduce using rule 69 (exp_sign -> PLUS .)
    VARS            reduce using rule 69 (exp_sign -> PLUS .)
    PROGRAM         reduce using rule 69 (exp_sign -> PLUS .)


state 165

    (73) term -> factor term_quadgen term_aux .
    MINUS           reduce using rule 73 (term -> factor term_quadgen term_aux .)
    PLUS            reduce using rule 73 (term -> factor term_quadgen term_aux .)
    COMMA           reduce using rule 73 (term -> factor term_quadgen term_aux .)
    RPAREN          reduce using rule 73 (term -> factor term_quadgen term_aux .)
    NEQ             reduce using rule 73 (term -> factor term_quadgen term_aux .)
    EQ              reduce using rule 73 (term -> factor term_quadgen term_aux .)
    LTE             reduce using rule 73 (term -> factor term_quadgen term_aux .)
    GTE             reduce using rule 73 (term -> factor term_quadgen term_aux .)
    LT              reduce using rule 73 (term -> factor term_quadgen term_aux .)
    GT              reduce using rule 73 (term -> factor term_quadgen term_aux .)
    OR              reduce using rule 73 (term -> factor term_quadgen term_aux .)
    AND             reduce using rule 73 (term -> factor term_quadgen term_aux .)
    SEMICOLON       reduce using rule 73 (term -> factor term_quadgen term_aux .)
    TO              reduce using rule 73 (term -> factor term_quadgen term_aux .)
    BY              reduce using rule 73 (term -> factor term_quadgen term_aux .)
    DO              reduce using rule 73 (term -> factor term_quadgen term_aux .)


state 166

    (71) term_aux -> term_sign . term
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    term                           shift and go to state 196
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 167

    (72) term_aux -> empty .
    MINUS           reduce using rule 72 (term_aux -> empty .)
    PLUS            reduce using rule 72 (term_aux -> empty .)
    COMMA           reduce using rule 72 (term_aux -> empty .)
    RPAREN          reduce using rule 72 (term_aux -> empty .)
    NEQ             reduce using rule 72 (term_aux -> empty .)
    EQ              reduce using rule 72 (term_aux -> empty .)
    LTE             reduce using rule 72 (term_aux -> empty .)
    GTE             reduce using rule 72 (term_aux -> empty .)
    LT              reduce using rule 72 (term_aux -> empty .)
    GT              reduce using rule 72 (term_aux -> empty .)
    OR              reduce using rule 72 (term_aux -> empty .)
    AND             reduce using rule 72 (term_aux -> empty .)
    SEMICOLON       reduce using rule 72 (term_aux -> empty .)
    TO              reduce using rule 72 (term_aux -> empty .)
    BY              reduce using rule 72 (term_aux -> empty .)
    DO              reduce using rule 72 (term_aux -> empty .)


state 168

    (74) term_sign -> DIVIDE .
    LPAREN          reduce using rule 74 (term_sign -> DIVIDE .)
    CTEBOOL         reduce using rule 74 (term_sign -> DIVIDE .)
    CTEFLOAT        reduce using rule 74 (term_sign -> DIVIDE .)
    CTEINT          reduce using rule 74 (term_sign -> DIVIDE .)
    ID              reduce using rule 74 (term_sign -> DIVIDE .)
    BOOL            reduce using rule 74 (term_sign -> DIVIDE .)
    FLOAT           reduce using rule 74 (term_sign -> DIVIDE .)
    INT             reduce using rule 74 (term_sign -> DIVIDE .)
    ELSE            reduce using rule 74 (term_sign -> DIVIDE .)
    IF              reduce using rule 74 (term_sign -> DIVIDE .)
    PRINT           reduce using rule 74 (term_sign -> DIVIDE .)
    INPUT           reduce using rule 74 (term_sign -> DIVIDE .)
    WHILE           reduce using rule 74 (term_sign -> DIVIDE .)
    DO              reduce using rule 74 (term_sign -> DIVIDE .)
    BY              reduce using rule 74 (term_sign -> DIVIDE .)
    TO              reduce using rule 74 (term_sign -> DIVIDE .)
    FROM            reduce using rule 74 (term_sign -> DIVIDE .)
    VOID            reduce using rule 74 (term_sign -> DIVIDE .)
    RETURN          reduce using rule 74 (term_sign -> DIVIDE .)
    FUNC            reduce using rule 74 (term_sign -> DIVIDE .)
    MAIN            reduce using rule 74 (term_sign -> DIVIDE .)
    VARS            reduce using rule 74 (term_sign -> DIVIDE .)
    PROGRAM         reduce using rule 74 (term_sign -> DIVIDE .)


state 169

    (75) term_sign -> TIMES .
    LPAREN          reduce using rule 75 (term_sign -> TIMES .)
    CTEBOOL         reduce using rule 75 (term_sign -> TIMES .)
    CTEFLOAT        reduce using rule 75 (term_sign -> TIMES .)
    CTEINT          reduce using rule 75 (term_sign -> TIMES .)
    ID              reduce using rule 75 (term_sign -> TIMES .)
    BOOL            reduce using rule 75 (term_sign -> TIMES .)
    FLOAT           reduce using rule 75 (term_sign -> TIMES .)
    INT             reduce using rule 75 (term_sign -> TIMES .)
    ELSE            reduce using rule 75 (term_sign -> TIMES .)
    IF              reduce using rule 75 (term_sign -> TIMES .)
    PRINT           reduce using rule 75 (term_sign -> TIMES .)
    INPUT           reduce using rule 75 (term_sign -> TIMES .)
    WHILE           reduce using rule 75 (term_sign -> TIMES .)
    DO              reduce using rule 75 (term_sign -> TIMES .)
    BY              reduce using rule 75 (term_sign -> TIMES .)
    TO              reduce using rule 75 (term_sign -> TIMES .)
    FROM            reduce using rule 75 (term_sign -> TIMES .)
    VOID            reduce using rule 75 (term_sign -> TIMES .)
    RETURN          reduce using rule 75 (term_sign -> TIMES .)
    FUNC            reduce using rule 75 (term_sign -> TIMES .)
    MAIN            reduce using rule 75 (term_sign -> TIMES .)
    VARS            reduce using rule 75 (term_sign -> TIMES .)
    PROGRAM         reduce using rule 75 (term_sign -> TIMES .)


state 170

    (82) forloop -> FROM var ASSIGN expression TO . expression BY expression DO block
    (83) forloop -> FROM var ASSIGN expression TO . expression DO block
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    var                            shift and go to state 120
    expression                     shift and go to state 197
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119

state 171

    (85) dowhileloop -> DO saveposition block WHILE LPAREN . expression RPAREN openjumpslot
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 198
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 172

    (4) block -> LCURLY blockcontent RCURLY .
    WHILE           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ELSE            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ID              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    FROM            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    DO              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    INPUT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    PRINT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    IF              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RCURLY          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RETURN          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)


state 173

    (84) whileloop -> WHILE saveposition LPAREN expression RPAREN . openjumpslot block filljumps
    (100) openjumpslot -> .
    LCURLY          reduce using rule 100 (openjumpslot -> .)

    openjumpslot                   shift and go to state 199

state 174

    (89) read -> INPUT LPAREN readaux RPAREN SEMICOLON .
    ID              reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    FROM            reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    DO              reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    IF              reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    RETURN          reduce using rule 89 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)


state 175

    (90) readaux -> readvalue COMMA readaux .
    RPAREN          reduce using rule 90 (readaux -> readvalue COMMA readaux .)


state 176

    (93) write -> PRINT LPAREN writeaux RPAREN SEMICOLON .
    ID              reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    FROM            reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    DO              reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    IF              reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    RETURN          reduce using rule 93 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)


state 177

    (95) writeaux -> writevalues COMMA writeaux .
    RPAREN          reduce using rule 95 (writeaux -> writevalues COMMA writeaux .)


state 178

    (51) super_exp -> expression super_exp_quadgen super_exp_aux .
    COMMA           reduce using rule 51 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RPAREN          reduce using rule 51 (super_exp -> expression super_exp_quadgen super_exp_aux .)


state 179

    (49) super_exp_aux -> logic . super_exp
    (51) super_exp -> . expression super_exp_quadgen super_exp_aux
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 200
    expression                     shift and go to state 135
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 180

    (50) super_exp_aux -> empty .
    COMMA           reduce using rule 50 (super_exp_aux -> empty .)
    RPAREN          reduce using rule 50 (super_exp_aux -> empty .)


state 181

    (52) logic -> OR .
    LPAREN          reduce using rule 52 (logic -> OR .)
    CTEBOOL         reduce using rule 52 (logic -> OR .)
    CTEFLOAT        reduce using rule 52 (logic -> OR .)
    CTEINT          reduce using rule 52 (logic -> OR .)
    ID              reduce using rule 52 (logic -> OR .)
    BOOL            reduce using rule 52 (logic -> OR .)
    FLOAT           reduce using rule 52 (logic -> OR .)
    INT             reduce using rule 52 (logic -> OR .)
    ELSE            reduce using rule 52 (logic -> OR .)
    IF              reduce using rule 52 (logic -> OR .)
    PRINT           reduce using rule 52 (logic -> OR .)
    INPUT           reduce using rule 52 (logic -> OR .)
    WHILE           reduce using rule 52 (logic -> OR .)
    DO              reduce using rule 52 (logic -> OR .)
    BY              reduce using rule 52 (logic -> OR .)
    TO              reduce using rule 52 (logic -> OR .)
    FROM            reduce using rule 52 (logic -> OR .)
    VOID            reduce using rule 52 (logic -> OR .)
    RETURN          reduce using rule 52 (logic -> OR .)
    FUNC            reduce using rule 52 (logic -> OR .)
    MAIN            reduce using rule 52 (logic -> OR .)
    VARS            reduce using rule 52 (logic -> OR .)
    PROGRAM         reduce using rule 52 (logic -> OR .)


state 182

    (53) logic -> AND .
    LPAREN          reduce using rule 53 (logic -> AND .)
    CTEBOOL         reduce using rule 53 (logic -> AND .)
    CTEFLOAT        reduce using rule 53 (logic -> AND .)
    CTEINT          reduce using rule 53 (logic -> AND .)
    ID              reduce using rule 53 (logic -> AND .)
    BOOL            reduce using rule 53 (logic -> AND .)
    FLOAT           reduce using rule 53 (logic -> AND .)
    INT             reduce using rule 53 (logic -> AND .)
    ELSE            reduce using rule 53 (logic -> AND .)
    IF              reduce using rule 53 (logic -> AND .)
    PRINT           reduce using rule 53 (logic -> AND .)
    INPUT           reduce using rule 53 (logic -> AND .)
    WHILE           reduce using rule 53 (logic -> AND .)
    DO              reduce using rule 53 (logic -> AND .)
    BY              reduce using rule 53 (logic -> AND .)
    TO              reduce using rule 53 (logic -> AND .)
    FROM            reduce using rule 53 (logic -> AND .)
    VOID            reduce using rule 53 (logic -> AND .)
    RETURN          reduce using rule 53 (logic -> AND .)
    FUNC            reduce using rule 53 (logic -> AND .)
    MAIN            reduce using rule 53 (logic -> AND .)
    VARS            reduce using rule 53 (logic -> AND .)
    PROGRAM         reduce using rule 53 (logic -> AND .)


state 183

    (57) expression -> exp expression_quadgen expression_aux .
    OR              reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    AND             reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    COMMA           reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    RPAREN          reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    SEMICOLON       reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    TO              reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    BY              reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)
    DO              reduce using rule 57 (expression -> exp expression_quadgen expression_aux .)


state 184

    (55) expression_aux -> relation . expression
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 201
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119
    var                            shift and go to state 120

state 185

    (56) expression_aux -> empty .
    OR              reduce using rule 56 (expression_aux -> empty .)
    AND             reduce using rule 56 (expression_aux -> empty .)
    COMMA           reduce using rule 56 (expression_aux -> empty .)
    RPAREN          reduce using rule 56 (expression_aux -> empty .)
    SEMICOLON       reduce using rule 56 (expression_aux -> empty .)
    TO              reduce using rule 56 (expression_aux -> empty .)
    BY              reduce using rule 56 (expression_aux -> empty .)
    DO              reduce using rule 56 (expression_aux -> empty .)


state 186

    (58) relation -> NEQ .
    LPAREN          reduce using rule 58 (relation -> NEQ .)
    CTEBOOL         reduce using rule 58 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 58 (relation -> NEQ .)
    CTEINT          reduce using rule 58 (relation -> NEQ .)
    ID              reduce using rule 58 (relation -> NEQ .)
    BOOL            reduce using rule 58 (relation -> NEQ .)
    FLOAT           reduce using rule 58 (relation -> NEQ .)
    INT             reduce using rule 58 (relation -> NEQ .)
    ELSE            reduce using rule 58 (relation -> NEQ .)
    IF              reduce using rule 58 (relation -> NEQ .)
    PRINT           reduce using rule 58 (relation -> NEQ .)
    INPUT           reduce using rule 58 (relation -> NEQ .)
    WHILE           reduce using rule 58 (relation -> NEQ .)
    DO              reduce using rule 58 (relation -> NEQ .)
    BY              reduce using rule 58 (relation -> NEQ .)
    TO              reduce using rule 58 (relation -> NEQ .)
    FROM            reduce using rule 58 (relation -> NEQ .)
    VOID            reduce using rule 58 (relation -> NEQ .)
    RETURN          reduce using rule 58 (relation -> NEQ .)
    FUNC            reduce using rule 58 (relation -> NEQ .)
    MAIN            reduce using rule 58 (relation -> NEQ .)
    VARS            reduce using rule 58 (relation -> NEQ .)
    PROGRAM         reduce using rule 58 (relation -> NEQ .)


state 187

    (59) relation -> EQ .
    LPAREN          reduce using rule 59 (relation -> EQ .)
    CTEBOOL         reduce using rule 59 (relation -> EQ .)
    CTEFLOAT        reduce using rule 59 (relation -> EQ .)
    CTEINT          reduce using rule 59 (relation -> EQ .)
    ID              reduce using rule 59 (relation -> EQ .)
    BOOL            reduce using rule 59 (relation -> EQ .)
    FLOAT           reduce using rule 59 (relation -> EQ .)
    INT             reduce using rule 59 (relation -> EQ .)
    ELSE            reduce using rule 59 (relation -> EQ .)
    IF              reduce using rule 59 (relation -> EQ .)
    PRINT           reduce using rule 59 (relation -> EQ .)
    INPUT           reduce using rule 59 (relation -> EQ .)
    WHILE           reduce using rule 59 (relation -> EQ .)
    DO              reduce using rule 59 (relation -> EQ .)
    BY              reduce using rule 59 (relation -> EQ .)
    TO              reduce using rule 59 (relation -> EQ .)
    FROM            reduce using rule 59 (relation -> EQ .)
    VOID            reduce using rule 59 (relation -> EQ .)
    RETURN          reduce using rule 59 (relation -> EQ .)
    FUNC            reduce using rule 59 (relation -> EQ .)
    MAIN            reduce using rule 59 (relation -> EQ .)
    VARS            reduce using rule 59 (relation -> EQ .)
    PROGRAM         reduce using rule 59 (relation -> EQ .)


state 188

    (60) relation -> LTE .
    LPAREN          reduce using rule 60 (relation -> LTE .)
    CTEBOOL         reduce using rule 60 (relation -> LTE .)
    CTEFLOAT        reduce using rule 60 (relation -> LTE .)
    CTEINT          reduce using rule 60 (relation -> LTE .)
    ID              reduce using rule 60 (relation -> LTE .)
    BOOL            reduce using rule 60 (relation -> LTE .)
    FLOAT           reduce using rule 60 (relation -> LTE .)
    INT             reduce using rule 60 (relation -> LTE .)
    ELSE            reduce using rule 60 (relation -> LTE .)
    IF              reduce using rule 60 (relation -> LTE .)
    PRINT           reduce using rule 60 (relation -> LTE .)
    INPUT           reduce using rule 60 (relation -> LTE .)
    WHILE           reduce using rule 60 (relation -> LTE .)
    DO              reduce using rule 60 (relation -> LTE .)
    BY              reduce using rule 60 (relation -> LTE .)
    TO              reduce using rule 60 (relation -> LTE .)
    FROM            reduce using rule 60 (relation -> LTE .)
    VOID            reduce using rule 60 (relation -> LTE .)
    RETURN          reduce using rule 60 (relation -> LTE .)
    FUNC            reduce using rule 60 (relation -> LTE .)
    MAIN            reduce using rule 60 (relation -> LTE .)
    VARS            reduce using rule 60 (relation -> LTE .)
    PROGRAM         reduce using rule 60 (relation -> LTE .)


state 189

    (61) relation -> GTE .
    LPAREN          reduce using rule 61 (relation -> GTE .)
    CTEBOOL         reduce using rule 61 (relation -> GTE .)
    CTEFLOAT        reduce using rule 61 (relation -> GTE .)
    CTEINT          reduce using rule 61 (relation -> GTE .)
    ID              reduce using rule 61 (relation -> GTE .)
    BOOL            reduce using rule 61 (relation -> GTE .)
    FLOAT           reduce using rule 61 (relation -> GTE .)
    INT             reduce using rule 61 (relation -> GTE .)
    ELSE            reduce using rule 61 (relation -> GTE .)
    IF              reduce using rule 61 (relation -> GTE .)
    PRINT           reduce using rule 61 (relation -> GTE .)
    INPUT           reduce using rule 61 (relation -> GTE .)
    WHILE           reduce using rule 61 (relation -> GTE .)
    DO              reduce using rule 61 (relation -> GTE .)
    BY              reduce using rule 61 (relation -> GTE .)
    TO              reduce using rule 61 (relation -> GTE .)
    FROM            reduce using rule 61 (relation -> GTE .)
    VOID            reduce using rule 61 (relation -> GTE .)
    RETURN          reduce using rule 61 (relation -> GTE .)
    FUNC            reduce using rule 61 (relation -> GTE .)
    MAIN            reduce using rule 61 (relation -> GTE .)
    VARS            reduce using rule 61 (relation -> GTE .)
    PROGRAM         reduce using rule 61 (relation -> GTE .)


state 190

    (62) relation -> LT .
    LPAREN          reduce using rule 62 (relation -> LT .)
    CTEBOOL         reduce using rule 62 (relation -> LT .)
    CTEFLOAT        reduce using rule 62 (relation -> LT .)
    CTEINT          reduce using rule 62 (relation -> LT .)
    ID              reduce using rule 62 (relation -> LT .)
    BOOL            reduce using rule 62 (relation -> LT .)
    FLOAT           reduce using rule 62 (relation -> LT .)
    INT             reduce using rule 62 (relation -> LT .)
    ELSE            reduce using rule 62 (relation -> LT .)
    IF              reduce using rule 62 (relation -> LT .)
    PRINT           reduce using rule 62 (relation -> LT .)
    INPUT           reduce using rule 62 (relation -> LT .)
    WHILE           reduce using rule 62 (relation -> LT .)
    DO              reduce using rule 62 (relation -> LT .)
    BY              reduce using rule 62 (relation -> LT .)
    TO              reduce using rule 62 (relation -> LT .)
    FROM            reduce using rule 62 (relation -> LT .)
    VOID            reduce using rule 62 (relation -> LT .)
    RETURN          reduce using rule 62 (relation -> LT .)
    FUNC            reduce using rule 62 (relation -> LT .)
    MAIN            reduce using rule 62 (relation -> LT .)
    VARS            reduce using rule 62 (relation -> LT .)
    PROGRAM         reduce using rule 62 (relation -> LT .)


state 191

    (63) relation -> GT .
    LPAREN          reduce using rule 63 (relation -> GT .)
    CTEBOOL         reduce using rule 63 (relation -> GT .)
    CTEFLOAT        reduce using rule 63 (relation -> GT .)
    CTEINT          reduce using rule 63 (relation -> GT .)
    ID              reduce using rule 63 (relation -> GT .)
    BOOL            reduce using rule 63 (relation -> GT .)
    FLOAT           reduce using rule 63 (relation -> GT .)
    INT             reduce using rule 63 (relation -> GT .)
    ELSE            reduce using rule 63 (relation -> GT .)
    IF              reduce using rule 63 (relation -> GT .)
    PRINT           reduce using rule 63 (relation -> GT .)
    INPUT           reduce using rule 63 (relation -> GT .)
    WHILE           reduce using rule 63 (relation -> GT .)
    DO              reduce using rule 63 (relation -> GT .)
    BY              reduce using rule 63 (relation -> GT .)
    TO              reduce using rule 63 (relation -> GT .)
    FROM            reduce using rule 63 (relation -> GT .)
    VOID            reduce using rule 63 (relation -> GT .)
    RETURN          reduce using rule 63 (relation -> GT .)
    FUNC            reduce using rule 63 (relation -> GT .)
    MAIN            reduce using rule 63 (relation -> GT .)
    VARS            reduce using rule 63 (relation -> GT .)
    PROGRAM         reduce using rule 63 (relation -> GT .)


state 192

    (98) condition -> IF LPAREN super_exp RPAREN openjumpslot . block filljumps
    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot . block ELSE filljumps openjumpslot block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 126

    block                          shift and go to state 202

state 193

    (6) returnblock -> LCURLY decvars blockcontent RETURN exp . SEMICOLON RCURLY
    SEMICOLON       shift and go to state 203


state 194

    (77) factor -> LPAREN fakefloor super_exp RPAREN .
    DIVIDE          reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TIMES           reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    MINUS           reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PLUS            reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    COMMA           reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RPAREN          reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    NEQ             reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    EQ              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LTE             reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GTE             reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LT              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GT              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    OR              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    AND             reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    SEMICOLON       reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TO              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    BY              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)
    DO              reduce using rule 77 (factor -> LPAREN fakefloor super_exp RPAREN .)


state 195

    (65) exp_aux -> exp_sign exp .
    COMMA           reduce using rule 65 (exp_aux -> exp_sign exp .)
    RPAREN          reduce using rule 65 (exp_aux -> exp_sign exp .)
    NEQ             reduce using rule 65 (exp_aux -> exp_sign exp .)
    EQ              reduce using rule 65 (exp_aux -> exp_sign exp .)
    LTE             reduce using rule 65 (exp_aux -> exp_sign exp .)
    GTE             reduce using rule 65 (exp_aux -> exp_sign exp .)
    LT              reduce using rule 65 (exp_aux -> exp_sign exp .)
    GT              reduce using rule 65 (exp_aux -> exp_sign exp .)
    OR              reduce using rule 65 (exp_aux -> exp_sign exp .)
    AND             reduce using rule 65 (exp_aux -> exp_sign exp .)
    SEMICOLON       reduce using rule 65 (exp_aux -> exp_sign exp .)
    TO              reduce using rule 65 (exp_aux -> exp_sign exp .)
    BY              reduce using rule 65 (exp_aux -> exp_sign exp .)
    DO              reduce using rule 65 (exp_aux -> exp_sign exp .)


state 196

    (71) term_aux -> term_sign term .
    MINUS           reduce using rule 71 (term_aux -> term_sign term .)
    PLUS            reduce using rule 71 (term_aux -> term_sign term .)
    COMMA           reduce using rule 71 (term_aux -> term_sign term .)
    RPAREN          reduce using rule 71 (term_aux -> term_sign term .)
    NEQ             reduce using rule 71 (term_aux -> term_sign term .)
    EQ              reduce using rule 71 (term_aux -> term_sign term .)
    LTE             reduce using rule 71 (term_aux -> term_sign term .)
    GTE             reduce using rule 71 (term_aux -> term_sign term .)
    LT              reduce using rule 71 (term_aux -> term_sign term .)
    GT              reduce using rule 71 (term_aux -> term_sign term .)
    OR              reduce using rule 71 (term_aux -> term_sign term .)
    AND             reduce using rule 71 (term_aux -> term_sign term .)
    SEMICOLON       reduce using rule 71 (term_aux -> term_sign term .)
    TO              reduce using rule 71 (term_aux -> term_sign term .)
    BY              reduce using rule 71 (term_aux -> term_sign term .)
    DO              reduce using rule 71 (term_aux -> term_sign term .)


state 197

    (82) forloop -> FROM var ASSIGN expression TO expression . BY expression DO block
    (83) forloop -> FROM var ASSIGN expression TO expression . DO block
    BY              shift and go to state 204
    DO              shift and go to state 205


state 198

    (85) dowhileloop -> DO saveposition block WHILE LPAREN expression . RPAREN openjumpslot
    RPAREN          shift and go to state 206


state 199

    (84) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 126

    block                          shift and go to state 207

state 200

    (49) super_exp_aux -> logic super_exp .
    COMMA           reduce using rule 49 (super_exp_aux -> logic super_exp .)
    RPAREN          reduce using rule 49 (super_exp_aux -> logic super_exp .)


state 201

    (55) expression_aux -> relation expression .
    OR              reduce using rule 55 (expression_aux -> relation expression .)
    AND             reduce using rule 55 (expression_aux -> relation expression .)
    COMMA           reduce using rule 55 (expression_aux -> relation expression .)
    RPAREN          reduce using rule 55 (expression_aux -> relation expression .)
    SEMICOLON       reduce using rule 55 (expression_aux -> relation expression .)
    TO              reduce using rule 55 (expression_aux -> relation expression .)
    BY              reduce using rule 55 (expression_aux -> relation expression .)
    DO              reduce using rule 55 (expression_aux -> relation expression .)


state 202

    (98) condition -> IF LPAREN super_exp RPAREN openjumpslot block . filljumps
    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot block . ELSE filljumps openjumpslot block filljumps
    (102) filljumps -> .
    ELSE            shift and go to state 209
    ID              reduce using rule 102 (filljumps -> .)
    FROM            reduce using rule 102 (filljumps -> .)
    DO              reduce using rule 102 (filljumps -> .)
    WHILE           reduce using rule 102 (filljumps -> .)
    INPUT           reduce using rule 102 (filljumps -> .)
    PRINT           reduce using rule 102 (filljumps -> .)
    IF              reduce using rule 102 (filljumps -> .)
    RCURLY          reduce using rule 102 (filljumps -> .)
    RETURN          reduce using rule 102 (filljumps -> .)

    filljumps                      shift and go to state 208

state 203

    (6) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON . RCURLY
    RCURLY          shift and go to state 210


state 204

    (82) forloop -> FROM var ASSIGN expression TO expression BY . expression DO block
    (57) expression -> . exp expression_quadgen expression_aux
    (67) exp -> . term exp_quadgen exp_aux
    (73) term -> . factor term_quadgen term_aux
    (77) factor -> . LPAREN fakefloor super_exp RPAREN
    (78) factor -> . varcte
    (79) factor -> . call
    (80) factor -> . var
    (103) varcte -> . CTEBOOL
    (104) varcte -> . CTEFLOAT
    (105) varcte -> . CTEINT
    (45) call -> . ID LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 112
    CTEBOOL         shift and go to state 121
    CTEFLOAT        shift and go to state 122
    CTEINT          shift and go to state 123
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    var                            shift and go to state 120
    expression                     shift and go to state 211
    exp                            shift and go to state 136
    term                           shift and go to state 116
    factor                         shift and go to state 117
    varcte                         shift and go to state 118
    call                           shift and go to state 119

state 205

    (83) forloop -> FROM var ASSIGN expression TO expression DO . block
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 126

    block                          shift and go to state 212

state 206

    (85) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN . openjumpslot
    (100) openjumpslot -> .
    ID              reduce using rule 100 (openjumpslot -> .)
    FROM            reduce using rule 100 (openjumpslot -> .)
    DO              reduce using rule 100 (openjumpslot -> .)
    WHILE           reduce using rule 100 (openjumpslot -> .)
    INPUT           reduce using rule 100 (openjumpslot -> .)
    PRINT           reduce using rule 100 (openjumpslot -> .)
    IF              reduce using rule 100 (openjumpslot -> .)
    RCURLY          reduce using rule 100 (openjumpslot -> .)
    RETURN          reduce using rule 100 (openjumpslot -> .)

    openjumpslot                   shift and go to state 213

state 207

    (84) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block . filljumps
    (102) filljumps -> .
    ID              reduce using rule 102 (filljumps -> .)
    FROM            reduce using rule 102 (filljumps -> .)
    DO              reduce using rule 102 (filljumps -> .)
    WHILE           reduce using rule 102 (filljumps -> .)
    INPUT           reduce using rule 102 (filljumps -> .)
    PRINT           reduce using rule 102 (filljumps -> .)
    IF              reduce using rule 102 (filljumps -> .)
    RCURLY          reduce using rule 102 (filljumps -> .)
    RETURN          reduce using rule 102 (filljumps -> .)

    filljumps                      shift and go to state 214

state 208

    (98) condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .
    ID              reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    RETURN          reduce using rule 98 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)


state 209

    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE . filljumps openjumpslot block filljumps
    (102) filljumps -> .
    LCURLY          reduce using rule 102 (filljumps -> .)

    filljumps                      shift and go to state 215

state 210

    (6) returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .
    FUNC            reduce using rule 6 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)
    MAIN            reduce using rule 6 (returnblock -> LCURLY decvars blockcontent RETURN exp SEMICOLON RCURLY .)


state 211

    (82) forloop -> FROM var ASSIGN expression TO expression BY expression . DO block
    DO              shift and go to state 216


state 212

    (83) forloop -> FROM var ASSIGN expression TO expression DO block .
    ID              reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    FROM            reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    DO              reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    WHILE           reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    INPUT           reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    PRINT           reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    IF              reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RCURLY          reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RETURN          reduce using rule 83 (forloop -> FROM var ASSIGN expression TO expression DO block .)


state 213

    (85) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .
    ID              reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    FROM            reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    DO              reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    WHILE           reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    INPUT           reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    PRINT           reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    IF              reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    RCURLY          reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    RETURN          reduce using rule 85 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)


state 214

    (84) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .
    ID              reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    RETURN          reduce using rule 84 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)


state 215

    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps . openjumpslot block filljumps
    (100) openjumpslot -> .
    LCURLY          reduce using rule 100 (openjumpslot -> .)

    openjumpslot                   shift and go to state 217

state 216

    (82) forloop -> FROM var ASSIGN expression TO expression BY expression DO . block
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 126

    block                          shift and go to state 218

state 217

    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 126

    block                          shift and go to state 219

state 218

    (82) forloop -> FROM var ASSIGN expression TO expression BY expression DO block .
    ID              reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    FROM            reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    DO              reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    WHILE           reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    INPUT           reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    PRINT           reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    IF              reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RCURLY          reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RETURN          reduce using rule 82 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)


state 219

    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block . filljumps
    (102) filljumps -> .
    ID              reduce using rule 102 (filljumps -> .)
    FROM            reduce using rule 102 (filljumps -> .)
    DO              reduce using rule 102 (filljumps -> .)
    WHILE           reduce using rule 102 (filljumps -> .)
    INPUT           reduce using rule 102 (filljumps -> .)
    PRINT           reduce using rule 102 (filljumps -> .)
    IF              reduce using rule 102 (filljumps -> .)
    RCURLY          reduce using rule 102 (filljumps -> .)
    RETURN          reduce using rule 102 (filljumps -> .)

    filljumps                      shift and go to state 220

state 220

    (99) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .
    ID              reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    FROM            reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    DO              reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    WHILE           reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    INPUT           reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    PRINT           reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    IF              reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    RCURLY          reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    RETURN          reduce using rule 99 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
