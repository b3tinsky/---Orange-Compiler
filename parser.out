Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     declare -> decvars decfuncs main_block
Rule 3     main_block -> MAIN changecontext LPAREN RPAREN declareblock
Rule 4     block -> LCURLY blockcontent RCURLY
Rule 5     declareblock -> LCURLY decvars blockcontent RCURLY
Rule 6     blockcontent -> empty
Rule 7     blockcontent -> statute blockcontent
Rule 8     decvars -> empty
Rule 9     decvars -> VARS decvar_line
Rule 10    decvar_line -> decvar_type decvar SEMICOLON decvar_line
Rule 11    decvar_line -> decvar_type decvar SEMICOLON
Rule 12    decvar_type -> type
Rule 13    decvar -> var COMMA decvar
Rule 14    decvar -> var
Rule 15    var -> BOOL
Rule 16    var -> FLOAT
Rule 17    var -> INT
Rule 18    var -> ELSE
Rule 19    var -> IF
Rule 20    var -> PRINT
Rule 21    var -> INPUT
Rule 22    var -> WHILE
Rule 23    var -> DO
Rule 24    var -> BY
Rule 25    var -> TO
Rule 26    var -> FROM
Rule 27    var -> VOID
Rule 28    var -> RETURN
Rule 29    var -> FUNC
Rule 30    var -> MAIN
Rule 31    var -> VARS
Rule 32    var -> PROGRAM
Rule 33    var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
Rule 34    var -> ID LBRACKET CTEINT RBRACKET
Rule 35    var -> ID
Rule 36    decfuncs -> empty
Rule 37    decfuncs -> func decfuncs
Rule 38    func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock
Rule 39    functype -> type
Rule 40    functype -> VOID
Rule 41    params -> empty
Rule 42    params -> param params_aux
Rule 43    param -> type ID
Rule 44    params_aux -> empty
Rule 45    params_aux -> COMMA params
Rule 46    call -> ID generate_era LPAREN callvalues RPAREN
Rule 47    generate_era -> <empty>
Rule 48    callvalues_aux -> COMMA callvalues
Rule 49    callvalues_aux -> empty
Rule 50    callvalues -> exp generate_param callvalues_aux
Rule 51    generate_param -> <empty>
Rule 52    super_exp_aux -> logic super_exp
Rule 53    super_exp_aux -> empty
Rule 54    super_exp -> expression super_exp_quadgen super_exp_aux
Rule 55    logic -> OR
Rule 56    logic -> AND
Rule 57    super_exp_quadgen -> <empty>
Rule 58    expression_aux -> relation expression
Rule 59    expression_aux -> empty
Rule 60    expression -> exp expression_quadgen expression_aux
Rule 61    relation -> NEQ
Rule 62    relation -> EQ
Rule 63    relation -> LTE
Rule 64    relation -> GTE
Rule 65    relation -> LT
Rule 66    relation -> GT
Rule 67    expression_quadgen -> <empty>
Rule 68    exp_aux -> exp_sign exp
Rule 69    exp_aux -> empty
Rule 70    exp -> term exp_quadgen exp_aux
Rule 71    exp_sign -> MINUS
Rule 72    exp_sign -> PLUS
Rule 73    exp_quadgen -> <empty>
Rule 74    term_aux -> term_sign term
Rule 75    term_aux -> empty
Rule 76    term -> factor term_quadgen term_aux
Rule 77    term_sign -> DIVIDE
Rule 78    term_sign -> TIMES
Rule 79    term_quadgen -> <empty>
Rule 80    factor -> LPAREN fakefloor super_exp RPAREN
Rule 81    factor -> varcte
Rule 82    factor -> call
Rule 83    factor -> var
Rule 84    fakefloor -> <empty>
Rule 85    forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
Rule 86    forloopcontrolvar -> var
Rule 87    validatecontrolvar -> <empty>
Rule 88    createfinaltempvar -> <empty>
Rule 89    validateloopend -> <empty>
Rule 90    whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
Rule 91    dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
Rule 92    assignment -> assignment_var assignment_sign expression SEMICOLON
Rule 93    assignment_sign -> ASSIGN
Rule 94    assignment_var -> ID
Rule 95    read -> INPUT LPAREN readaux RPAREN SEMICOLON
Rule 96    readaux -> readvalue COMMA readaux
Rule 97    readaux -> readvalue
Rule 98    readvalue -> var
Rule 99    write -> PRINT LPAREN writeaux RPAREN SEMICOLON
Rule 100   writeaux -> writevalues
Rule 101   writeaux -> writevalues COMMA writeaux
Rule 102   writevalues -> CTESTRING
Rule 103   writevalues -> super_exp
Rule 104   condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps
Rule 105   condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
Rule 106   openjumpslot -> <empty>
Rule 107   saveposition -> <empty>
Rule 108   filljumps -> <empty>
Rule 109   varcte -> CTEBOOL
Rule 110   varcte -> CTEFLOAT
Rule 111   varcte -> CTEINT
Rule 112   type -> BOOL
Rule 113   type -> FLOAT
Rule 114   type -> INT
Rule 115   returnstmt -> RETURN super_exp
Rule 116   statute -> returnstmt
Rule 117   statute -> call
Rule 118   statute -> forloop
Rule 119   statute -> dowhileloop
Rule 120   statute -> whileloop
Rule 121   statute -> read
Rule 122   statute -> write
Rule 123   statute -> condition
Rule 124   statute -> assignment
Rule 125   changecontext -> <empty>
Rule 126   saveprogramname -> <empty>
Rule 127   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 56
ASSIGN               : 93
BOOL                 : 15 112
BY                   : 24
COMMA                : 13 45 48 96 101
CTEBOOL              : 109
CTEFLOAT             : 110
CTEINT               : 33 33 34 111
CTESTRING            : 102
DIVIDE               : 77
DO                   : 23 85 91
ELSE                 : 18 105
EQ                   : 62
FLOAT                : 16 113
FROM                 : 26 85
FUNC                 : 29 38
GT                   : 66
GTE                  : 64
ID                   : 1 33 34 35 38 43 46 94
IF                   : 19 104 105
INPUT                : 21 95
INT                  : 17 114
LBRACKET             : 33 33 34
LCURLY               : 4 5
LPAREN               : 3 38 46 80 90 91 95 99 104 105
LT                   : 65
LTE                  : 63
MAIN                 : 3 30
MINUS                : 71
NEQ                  : 61
OR                   : 55
PLUS                 : 72
PRINT                : 20 99
PROGRAM              : 1 32
RBRACKET             : 33 33 34
RCURLY               : 4 5
RETURN               : 28 115
RPAREN               : 3 38 46 80 90 91 95 99 104 105
SEMICOLON            : 10 11 92 95 99
TIMES                : 78
TO                   : 25 85
VARS                 : 9 31
VOID                 : 27 40
WHILE                : 22 90 91
error                : 

Nonterminals, with rules where they appear:

assignment           : 124
assignment_sign      : 85 92
assignment_var       : 92
block                : 85 90 91 104 105 105
blockcontent         : 4 5 7
call                 : 82 117
callvalues           : 46 48
callvalues_aux       : 50
changecontext        : 3 38
condition            : 123
createfinaltempvar   : 85
decfuncs             : 2 37
declare              : 1
declareblock         : 3 38
decvar               : 10 11 13
decvar_line          : 9 10
decvar_type          : 10 11
decvars              : 2 5
dowhileloop          : 119
empty                : 6 8 36 41 44 49 53 59 69 75
exp                  : 50 60 68
exp_aux              : 70
exp_quadgen          : 70
exp_sign             : 68
expression           : 54 58 85 85 90 91 92
expression_aux       : 60
expression_quadgen   : 60
factor               : 76
fakefloor            : 80
filljumps            : 85 90 104 105 105
forloop              : 118
forloopcontrolvar    : 85
func                 : 37
functype             : 38
generate_era         : 46
generate_param       : 50
logic                : 52
main_block           : 2
openjumpslot         : 85 90 91 104 105 105
param                : 42
params               : 38 45
params_aux           : 42
program              : 0
read                 : 121
readaux              : 95 96
readvalue            : 96 97
relation             : 58
returnstmt           : 116
saveposition         : 90 91
saveprogramname      : 1
statute              : 7
super_exp            : 52 80 103 104 105 115
super_exp_aux        : 54
super_exp_quadgen    : 54
term                 : 70 74
term_aux             : 76
term_quadgen         : 76
term_sign            : 74
type                 : 12 39 43
validatecontrolvar   : 85
validateloopend      : 85
var                  : 13 14 83 86 98
varcte               : 81
whileloop            : 120
write                : 122
writeaux             : 99 101
writevalues          : 100 101


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (126) saveprogramname -> .
    VARS            reduce using rule 126 (saveprogramname -> .)
    FUNC            reduce using rule 126 (saveprogramname -> .)
    MAIN            reduce using rule 126 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (2) declare -> . decvars decfuncs main_block
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (127) empty -> .
    VARS            shift and go to state 8
    FUNC            reduce using rule 127 (empty -> .)
    MAIN            reduce using rule 127 (empty -> .)

    declare                        shift and go to state 5
    decvars                        shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (2) declare -> decvars . decfuncs main_block
    (36) decfuncs -> . empty
    (37) decfuncs -> . func decfuncs
    (127) empty -> .
    (38) func -> . FUNC functype ID changecontext LPAREN params RPAREN declareblock
    MAIN            reduce using rule 127 (empty -> .)
    FUNC            shift and go to state 12

    decfuncs                       shift and go to state 9
    empty                          shift and go to state 10
    func                           shift and go to state 11

state 7

    (8) decvars -> empty .
    FUNC            reduce using rule 8 (decvars -> empty .)
    MAIN            reduce using rule 8 (decvars -> empty .)
    RETURN          reduce using rule 8 (decvars -> empty .)
    ID              reduce using rule 8 (decvars -> empty .)
    FROM            reduce using rule 8 (decvars -> empty .)
    DO              reduce using rule 8 (decvars -> empty .)
    WHILE           reduce using rule 8 (decvars -> empty .)
    INPUT           reduce using rule 8 (decvars -> empty .)
    PRINT           reduce using rule 8 (decvars -> empty .)
    IF              reduce using rule 8 (decvars -> empty .)
    RCURLY          reduce using rule 8 (decvars -> empty .)


state 8

    (9) decvars -> VARS . decvar_line
    (10) decvar_line -> . decvar_type decvar SEMICOLON decvar_line
    (11) decvar_line -> . decvar_type decvar SEMICOLON
    (12) decvar_type -> . type
    (112) type -> . BOOL
    (113) type -> . FLOAT
    (114) type -> . INT
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    decvar_line                    shift and go to state 13
    decvar_type                    shift and go to state 14
    type                           shift and go to state 15

state 9

    (2) declare -> decvars decfuncs . main_block
    (3) main_block -> . MAIN changecontext LPAREN RPAREN declareblock
    MAIN            shift and go to state 20

    main_block                     shift and go to state 19

state 10

    (36) decfuncs -> empty .
    MAIN            reduce using rule 36 (decfuncs -> empty .)


state 11

    (37) decfuncs -> func . decfuncs
    (36) decfuncs -> . empty
    (37) decfuncs -> . func decfuncs
    (127) empty -> .
    (38) func -> . FUNC functype ID changecontext LPAREN params RPAREN declareblock
    MAIN            reduce using rule 127 (empty -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 11
    decfuncs                       shift and go to state 21
    empty                          shift and go to state 10

state 12

    (38) func -> FUNC . functype ID changecontext LPAREN params RPAREN declareblock
    (39) functype -> . type
    (40) functype -> . VOID
    (112) type -> . BOOL
    (113) type -> . FLOAT
    (114) type -> . INT
    VOID            shift and go to state 24
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    functype                       shift and go to state 22
    type                           shift and go to state 23

state 13

    (9) decvars -> VARS decvar_line .
    FUNC            reduce using rule 9 (decvars -> VARS decvar_line .)
    MAIN            reduce using rule 9 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 9 (decvars -> VARS decvar_line .)
    ID              reduce using rule 9 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 9 (decvars -> VARS decvar_line .)
    DO              reduce using rule 9 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 9 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 9 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 9 (decvars -> VARS decvar_line .)
    IF              reduce using rule 9 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 9 (decvars -> VARS decvar_line .)


state 14

    (10) decvar_line -> decvar_type . decvar SEMICOLON decvar_line
    (11) decvar_line -> decvar_type . decvar SEMICOLON
    (13) decvar -> . var COMMA decvar
    (14) decvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    decvar                         shift and go to state 25
    var                            shift and go to state 26

state 15

    (12) decvar_type -> type .
    BOOL            reduce using rule 12 (decvar_type -> type .)
    FLOAT           reduce using rule 12 (decvar_type -> type .)
    INT             reduce using rule 12 (decvar_type -> type .)
    ELSE            reduce using rule 12 (decvar_type -> type .)
    IF              reduce using rule 12 (decvar_type -> type .)
    PRINT           reduce using rule 12 (decvar_type -> type .)
    INPUT           reduce using rule 12 (decvar_type -> type .)
    WHILE           reduce using rule 12 (decvar_type -> type .)
    DO              reduce using rule 12 (decvar_type -> type .)
    BY              reduce using rule 12 (decvar_type -> type .)
    TO              reduce using rule 12 (decvar_type -> type .)
    FROM            reduce using rule 12 (decvar_type -> type .)
    VOID            reduce using rule 12 (decvar_type -> type .)
    RETURN          reduce using rule 12 (decvar_type -> type .)
    FUNC            reduce using rule 12 (decvar_type -> type .)
    MAIN            reduce using rule 12 (decvar_type -> type .)
    VARS            reduce using rule 12 (decvar_type -> type .)
    PROGRAM         reduce using rule 12 (decvar_type -> type .)
    ID              reduce using rule 12 (decvar_type -> type .)


state 16

    (112) type -> BOOL .
    BOOL            reduce using rule 112 (type -> BOOL .)
    FLOAT           reduce using rule 112 (type -> BOOL .)
    INT             reduce using rule 112 (type -> BOOL .)
    ELSE            reduce using rule 112 (type -> BOOL .)
    IF              reduce using rule 112 (type -> BOOL .)
    PRINT           reduce using rule 112 (type -> BOOL .)
    INPUT           reduce using rule 112 (type -> BOOL .)
    WHILE           reduce using rule 112 (type -> BOOL .)
    DO              reduce using rule 112 (type -> BOOL .)
    BY              reduce using rule 112 (type -> BOOL .)
    TO              reduce using rule 112 (type -> BOOL .)
    FROM            reduce using rule 112 (type -> BOOL .)
    VOID            reduce using rule 112 (type -> BOOL .)
    RETURN          reduce using rule 112 (type -> BOOL .)
    FUNC            reduce using rule 112 (type -> BOOL .)
    MAIN            reduce using rule 112 (type -> BOOL .)
    VARS            reduce using rule 112 (type -> BOOL .)
    PROGRAM         reduce using rule 112 (type -> BOOL .)
    ID              reduce using rule 112 (type -> BOOL .)


state 17

    (113) type -> FLOAT .
    BOOL            reduce using rule 113 (type -> FLOAT .)
    FLOAT           reduce using rule 113 (type -> FLOAT .)
    INT             reduce using rule 113 (type -> FLOAT .)
    ELSE            reduce using rule 113 (type -> FLOAT .)
    IF              reduce using rule 113 (type -> FLOAT .)
    PRINT           reduce using rule 113 (type -> FLOAT .)
    INPUT           reduce using rule 113 (type -> FLOAT .)
    WHILE           reduce using rule 113 (type -> FLOAT .)
    DO              reduce using rule 113 (type -> FLOAT .)
    BY              reduce using rule 113 (type -> FLOAT .)
    TO              reduce using rule 113 (type -> FLOAT .)
    FROM            reduce using rule 113 (type -> FLOAT .)
    VOID            reduce using rule 113 (type -> FLOAT .)
    RETURN          reduce using rule 113 (type -> FLOAT .)
    FUNC            reduce using rule 113 (type -> FLOAT .)
    MAIN            reduce using rule 113 (type -> FLOAT .)
    VARS            reduce using rule 113 (type -> FLOAT .)
    PROGRAM         reduce using rule 113 (type -> FLOAT .)
    ID              reduce using rule 113 (type -> FLOAT .)


state 18

    (114) type -> INT .
    BOOL            reduce using rule 114 (type -> INT .)
    FLOAT           reduce using rule 114 (type -> INT .)
    INT             reduce using rule 114 (type -> INT .)
    ELSE            reduce using rule 114 (type -> INT .)
    IF              reduce using rule 114 (type -> INT .)
    PRINT           reduce using rule 114 (type -> INT .)
    INPUT           reduce using rule 114 (type -> INT .)
    WHILE           reduce using rule 114 (type -> INT .)
    DO              reduce using rule 114 (type -> INT .)
    BY              reduce using rule 114 (type -> INT .)
    TO              reduce using rule 114 (type -> INT .)
    FROM            reduce using rule 114 (type -> INT .)
    VOID            reduce using rule 114 (type -> INT .)
    RETURN          reduce using rule 114 (type -> INT .)
    FUNC            reduce using rule 114 (type -> INT .)
    MAIN            reduce using rule 114 (type -> INT .)
    VARS            reduce using rule 114 (type -> INT .)
    PROGRAM         reduce using rule 114 (type -> INT .)
    ID              reduce using rule 114 (type -> INT .)


state 19

    (2) declare -> decvars decfuncs main_block .
    $end            reduce using rule 2 (declare -> decvars decfuncs main_block .)


state 20

    (3) main_block -> MAIN . changecontext LPAREN RPAREN declareblock
    (125) changecontext -> .
    LPAREN          reduce using rule 125 (changecontext -> .)

    changecontext                  shift and go to state 46

state 21

    (37) decfuncs -> func decfuncs .
    MAIN            reduce using rule 37 (decfuncs -> func decfuncs .)


state 22

    (38) func -> FUNC functype . ID changecontext LPAREN params RPAREN declareblock
    ID              shift and go to state 47


state 23

    (39) functype -> type .
    ID              reduce using rule 39 (functype -> type .)


state 24

    (40) functype -> VOID .
    ID              reduce using rule 40 (functype -> VOID .)


state 25

    (10) decvar_line -> decvar_type decvar . SEMICOLON decvar_line
    (11) decvar_line -> decvar_type decvar . SEMICOLON
    SEMICOLON       shift and go to state 48


state 26

    (13) decvar -> var . COMMA decvar
    (14) decvar -> var .
    COMMA           shift and go to state 49
    SEMICOLON       reduce using rule 14 (decvar -> var .)


state 27

    (15) var -> BOOL .
    COMMA           reduce using rule 15 (var -> BOOL .)
    SEMICOLON       reduce using rule 15 (var -> BOOL .)
    DIVIDE          reduce using rule 15 (var -> BOOL .)
    TIMES           reduce using rule 15 (var -> BOOL .)
    MINUS           reduce using rule 15 (var -> BOOL .)
    PLUS            reduce using rule 15 (var -> BOOL .)
    NEQ             reduce using rule 15 (var -> BOOL .)
    EQ              reduce using rule 15 (var -> BOOL .)
    LTE             reduce using rule 15 (var -> BOOL .)
    GTE             reduce using rule 15 (var -> BOOL .)
    LT              reduce using rule 15 (var -> BOOL .)
    GT              reduce using rule 15 (var -> BOOL .)
    OR              reduce using rule 15 (var -> BOOL .)
    AND             reduce using rule 15 (var -> BOOL .)
    RETURN          reduce using rule 15 (var -> BOOL .)
    ID              reduce using rule 15 (var -> BOOL .)
    FROM            reduce using rule 15 (var -> BOOL .)
    DO              reduce using rule 15 (var -> BOOL .)
    WHILE           reduce using rule 15 (var -> BOOL .)
    INPUT           reduce using rule 15 (var -> BOOL .)
    PRINT           reduce using rule 15 (var -> BOOL .)
    IF              reduce using rule 15 (var -> BOOL .)
    RCURLY          reduce using rule 15 (var -> BOOL .)
    ASSIGN          reduce using rule 15 (var -> BOOL .)
    RPAREN          reduce using rule 15 (var -> BOOL .)
    TO              reduce using rule 15 (var -> BOOL .)


state 28

    (16) var -> FLOAT .
    COMMA           reduce using rule 16 (var -> FLOAT .)
    SEMICOLON       reduce using rule 16 (var -> FLOAT .)
    DIVIDE          reduce using rule 16 (var -> FLOAT .)
    TIMES           reduce using rule 16 (var -> FLOAT .)
    MINUS           reduce using rule 16 (var -> FLOAT .)
    PLUS            reduce using rule 16 (var -> FLOAT .)
    NEQ             reduce using rule 16 (var -> FLOAT .)
    EQ              reduce using rule 16 (var -> FLOAT .)
    LTE             reduce using rule 16 (var -> FLOAT .)
    GTE             reduce using rule 16 (var -> FLOAT .)
    LT              reduce using rule 16 (var -> FLOAT .)
    GT              reduce using rule 16 (var -> FLOAT .)
    OR              reduce using rule 16 (var -> FLOAT .)
    AND             reduce using rule 16 (var -> FLOAT .)
    RETURN          reduce using rule 16 (var -> FLOAT .)
    ID              reduce using rule 16 (var -> FLOAT .)
    FROM            reduce using rule 16 (var -> FLOAT .)
    DO              reduce using rule 16 (var -> FLOAT .)
    WHILE           reduce using rule 16 (var -> FLOAT .)
    INPUT           reduce using rule 16 (var -> FLOAT .)
    PRINT           reduce using rule 16 (var -> FLOAT .)
    IF              reduce using rule 16 (var -> FLOAT .)
    RCURLY          reduce using rule 16 (var -> FLOAT .)
    ASSIGN          reduce using rule 16 (var -> FLOAT .)
    RPAREN          reduce using rule 16 (var -> FLOAT .)
    TO              reduce using rule 16 (var -> FLOAT .)


state 29

    (17) var -> INT .
    COMMA           reduce using rule 17 (var -> INT .)
    SEMICOLON       reduce using rule 17 (var -> INT .)
    DIVIDE          reduce using rule 17 (var -> INT .)
    TIMES           reduce using rule 17 (var -> INT .)
    MINUS           reduce using rule 17 (var -> INT .)
    PLUS            reduce using rule 17 (var -> INT .)
    NEQ             reduce using rule 17 (var -> INT .)
    EQ              reduce using rule 17 (var -> INT .)
    LTE             reduce using rule 17 (var -> INT .)
    GTE             reduce using rule 17 (var -> INT .)
    LT              reduce using rule 17 (var -> INT .)
    GT              reduce using rule 17 (var -> INT .)
    OR              reduce using rule 17 (var -> INT .)
    AND             reduce using rule 17 (var -> INT .)
    RETURN          reduce using rule 17 (var -> INT .)
    ID              reduce using rule 17 (var -> INT .)
    FROM            reduce using rule 17 (var -> INT .)
    DO              reduce using rule 17 (var -> INT .)
    WHILE           reduce using rule 17 (var -> INT .)
    INPUT           reduce using rule 17 (var -> INT .)
    PRINT           reduce using rule 17 (var -> INT .)
    IF              reduce using rule 17 (var -> INT .)
    RCURLY          reduce using rule 17 (var -> INT .)
    ASSIGN          reduce using rule 17 (var -> INT .)
    RPAREN          reduce using rule 17 (var -> INT .)
    TO              reduce using rule 17 (var -> INT .)


state 30

    (18) var -> ELSE .
    COMMA           reduce using rule 18 (var -> ELSE .)
    SEMICOLON       reduce using rule 18 (var -> ELSE .)
    DIVIDE          reduce using rule 18 (var -> ELSE .)
    TIMES           reduce using rule 18 (var -> ELSE .)
    MINUS           reduce using rule 18 (var -> ELSE .)
    PLUS            reduce using rule 18 (var -> ELSE .)
    NEQ             reduce using rule 18 (var -> ELSE .)
    EQ              reduce using rule 18 (var -> ELSE .)
    LTE             reduce using rule 18 (var -> ELSE .)
    GTE             reduce using rule 18 (var -> ELSE .)
    LT              reduce using rule 18 (var -> ELSE .)
    GT              reduce using rule 18 (var -> ELSE .)
    OR              reduce using rule 18 (var -> ELSE .)
    AND             reduce using rule 18 (var -> ELSE .)
    RETURN          reduce using rule 18 (var -> ELSE .)
    ID              reduce using rule 18 (var -> ELSE .)
    FROM            reduce using rule 18 (var -> ELSE .)
    DO              reduce using rule 18 (var -> ELSE .)
    WHILE           reduce using rule 18 (var -> ELSE .)
    INPUT           reduce using rule 18 (var -> ELSE .)
    PRINT           reduce using rule 18 (var -> ELSE .)
    IF              reduce using rule 18 (var -> ELSE .)
    RCURLY          reduce using rule 18 (var -> ELSE .)
    ASSIGN          reduce using rule 18 (var -> ELSE .)
    RPAREN          reduce using rule 18 (var -> ELSE .)
    TO              reduce using rule 18 (var -> ELSE .)


state 31

    (19) var -> IF .
    COMMA           reduce using rule 19 (var -> IF .)
    SEMICOLON       reduce using rule 19 (var -> IF .)
    DIVIDE          reduce using rule 19 (var -> IF .)
    TIMES           reduce using rule 19 (var -> IF .)
    MINUS           reduce using rule 19 (var -> IF .)
    PLUS            reduce using rule 19 (var -> IF .)
    NEQ             reduce using rule 19 (var -> IF .)
    EQ              reduce using rule 19 (var -> IF .)
    LTE             reduce using rule 19 (var -> IF .)
    GTE             reduce using rule 19 (var -> IF .)
    LT              reduce using rule 19 (var -> IF .)
    GT              reduce using rule 19 (var -> IF .)
    OR              reduce using rule 19 (var -> IF .)
    AND             reduce using rule 19 (var -> IF .)
    RETURN          reduce using rule 19 (var -> IF .)
    ID              reduce using rule 19 (var -> IF .)
    FROM            reduce using rule 19 (var -> IF .)
    DO              reduce using rule 19 (var -> IF .)
    WHILE           reduce using rule 19 (var -> IF .)
    INPUT           reduce using rule 19 (var -> IF .)
    PRINT           reduce using rule 19 (var -> IF .)
    IF              reduce using rule 19 (var -> IF .)
    RCURLY          reduce using rule 19 (var -> IF .)
    ASSIGN          reduce using rule 19 (var -> IF .)
    RPAREN          reduce using rule 19 (var -> IF .)
    TO              reduce using rule 19 (var -> IF .)


state 32

    (20) var -> PRINT .
    COMMA           reduce using rule 20 (var -> PRINT .)
    SEMICOLON       reduce using rule 20 (var -> PRINT .)
    DIVIDE          reduce using rule 20 (var -> PRINT .)
    TIMES           reduce using rule 20 (var -> PRINT .)
    MINUS           reduce using rule 20 (var -> PRINT .)
    PLUS            reduce using rule 20 (var -> PRINT .)
    NEQ             reduce using rule 20 (var -> PRINT .)
    EQ              reduce using rule 20 (var -> PRINT .)
    LTE             reduce using rule 20 (var -> PRINT .)
    GTE             reduce using rule 20 (var -> PRINT .)
    LT              reduce using rule 20 (var -> PRINT .)
    GT              reduce using rule 20 (var -> PRINT .)
    OR              reduce using rule 20 (var -> PRINT .)
    AND             reduce using rule 20 (var -> PRINT .)
    RETURN          reduce using rule 20 (var -> PRINT .)
    ID              reduce using rule 20 (var -> PRINT .)
    FROM            reduce using rule 20 (var -> PRINT .)
    DO              reduce using rule 20 (var -> PRINT .)
    WHILE           reduce using rule 20 (var -> PRINT .)
    INPUT           reduce using rule 20 (var -> PRINT .)
    PRINT           reduce using rule 20 (var -> PRINT .)
    IF              reduce using rule 20 (var -> PRINT .)
    RCURLY          reduce using rule 20 (var -> PRINT .)
    ASSIGN          reduce using rule 20 (var -> PRINT .)
    RPAREN          reduce using rule 20 (var -> PRINT .)
    TO              reduce using rule 20 (var -> PRINT .)


state 33

    (21) var -> INPUT .
    COMMA           reduce using rule 21 (var -> INPUT .)
    SEMICOLON       reduce using rule 21 (var -> INPUT .)
    DIVIDE          reduce using rule 21 (var -> INPUT .)
    TIMES           reduce using rule 21 (var -> INPUT .)
    MINUS           reduce using rule 21 (var -> INPUT .)
    PLUS            reduce using rule 21 (var -> INPUT .)
    NEQ             reduce using rule 21 (var -> INPUT .)
    EQ              reduce using rule 21 (var -> INPUT .)
    LTE             reduce using rule 21 (var -> INPUT .)
    GTE             reduce using rule 21 (var -> INPUT .)
    LT              reduce using rule 21 (var -> INPUT .)
    GT              reduce using rule 21 (var -> INPUT .)
    OR              reduce using rule 21 (var -> INPUT .)
    AND             reduce using rule 21 (var -> INPUT .)
    RETURN          reduce using rule 21 (var -> INPUT .)
    ID              reduce using rule 21 (var -> INPUT .)
    FROM            reduce using rule 21 (var -> INPUT .)
    DO              reduce using rule 21 (var -> INPUT .)
    WHILE           reduce using rule 21 (var -> INPUT .)
    INPUT           reduce using rule 21 (var -> INPUT .)
    PRINT           reduce using rule 21 (var -> INPUT .)
    IF              reduce using rule 21 (var -> INPUT .)
    RCURLY          reduce using rule 21 (var -> INPUT .)
    ASSIGN          reduce using rule 21 (var -> INPUT .)
    RPAREN          reduce using rule 21 (var -> INPUT .)
    TO              reduce using rule 21 (var -> INPUT .)


state 34

    (22) var -> WHILE .
    COMMA           reduce using rule 22 (var -> WHILE .)
    SEMICOLON       reduce using rule 22 (var -> WHILE .)
    DIVIDE          reduce using rule 22 (var -> WHILE .)
    TIMES           reduce using rule 22 (var -> WHILE .)
    MINUS           reduce using rule 22 (var -> WHILE .)
    PLUS            reduce using rule 22 (var -> WHILE .)
    NEQ             reduce using rule 22 (var -> WHILE .)
    EQ              reduce using rule 22 (var -> WHILE .)
    LTE             reduce using rule 22 (var -> WHILE .)
    GTE             reduce using rule 22 (var -> WHILE .)
    LT              reduce using rule 22 (var -> WHILE .)
    GT              reduce using rule 22 (var -> WHILE .)
    OR              reduce using rule 22 (var -> WHILE .)
    AND             reduce using rule 22 (var -> WHILE .)
    RETURN          reduce using rule 22 (var -> WHILE .)
    ID              reduce using rule 22 (var -> WHILE .)
    FROM            reduce using rule 22 (var -> WHILE .)
    DO              reduce using rule 22 (var -> WHILE .)
    WHILE           reduce using rule 22 (var -> WHILE .)
    INPUT           reduce using rule 22 (var -> WHILE .)
    PRINT           reduce using rule 22 (var -> WHILE .)
    IF              reduce using rule 22 (var -> WHILE .)
    RCURLY          reduce using rule 22 (var -> WHILE .)
    ASSIGN          reduce using rule 22 (var -> WHILE .)
    RPAREN          reduce using rule 22 (var -> WHILE .)
    TO              reduce using rule 22 (var -> WHILE .)


state 35

    (23) var -> DO .
    COMMA           reduce using rule 23 (var -> DO .)
    SEMICOLON       reduce using rule 23 (var -> DO .)
    DIVIDE          reduce using rule 23 (var -> DO .)
    TIMES           reduce using rule 23 (var -> DO .)
    MINUS           reduce using rule 23 (var -> DO .)
    PLUS            reduce using rule 23 (var -> DO .)
    NEQ             reduce using rule 23 (var -> DO .)
    EQ              reduce using rule 23 (var -> DO .)
    LTE             reduce using rule 23 (var -> DO .)
    GTE             reduce using rule 23 (var -> DO .)
    LT              reduce using rule 23 (var -> DO .)
    GT              reduce using rule 23 (var -> DO .)
    OR              reduce using rule 23 (var -> DO .)
    AND             reduce using rule 23 (var -> DO .)
    RETURN          reduce using rule 23 (var -> DO .)
    ID              reduce using rule 23 (var -> DO .)
    FROM            reduce using rule 23 (var -> DO .)
    DO              reduce using rule 23 (var -> DO .)
    WHILE           reduce using rule 23 (var -> DO .)
    INPUT           reduce using rule 23 (var -> DO .)
    PRINT           reduce using rule 23 (var -> DO .)
    IF              reduce using rule 23 (var -> DO .)
    RCURLY          reduce using rule 23 (var -> DO .)
    ASSIGN          reduce using rule 23 (var -> DO .)
    RPAREN          reduce using rule 23 (var -> DO .)
    TO              reduce using rule 23 (var -> DO .)


state 36

    (24) var -> BY .
    COMMA           reduce using rule 24 (var -> BY .)
    SEMICOLON       reduce using rule 24 (var -> BY .)
    DIVIDE          reduce using rule 24 (var -> BY .)
    TIMES           reduce using rule 24 (var -> BY .)
    MINUS           reduce using rule 24 (var -> BY .)
    PLUS            reduce using rule 24 (var -> BY .)
    NEQ             reduce using rule 24 (var -> BY .)
    EQ              reduce using rule 24 (var -> BY .)
    LTE             reduce using rule 24 (var -> BY .)
    GTE             reduce using rule 24 (var -> BY .)
    LT              reduce using rule 24 (var -> BY .)
    GT              reduce using rule 24 (var -> BY .)
    OR              reduce using rule 24 (var -> BY .)
    AND             reduce using rule 24 (var -> BY .)
    RETURN          reduce using rule 24 (var -> BY .)
    ID              reduce using rule 24 (var -> BY .)
    FROM            reduce using rule 24 (var -> BY .)
    DO              reduce using rule 24 (var -> BY .)
    WHILE           reduce using rule 24 (var -> BY .)
    INPUT           reduce using rule 24 (var -> BY .)
    PRINT           reduce using rule 24 (var -> BY .)
    IF              reduce using rule 24 (var -> BY .)
    RCURLY          reduce using rule 24 (var -> BY .)
    ASSIGN          reduce using rule 24 (var -> BY .)
    RPAREN          reduce using rule 24 (var -> BY .)
    TO              reduce using rule 24 (var -> BY .)


state 37

    (25) var -> TO .
    COMMA           reduce using rule 25 (var -> TO .)
    SEMICOLON       reduce using rule 25 (var -> TO .)
    DIVIDE          reduce using rule 25 (var -> TO .)
    TIMES           reduce using rule 25 (var -> TO .)
    MINUS           reduce using rule 25 (var -> TO .)
    PLUS            reduce using rule 25 (var -> TO .)
    NEQ             reduce using rule 25 (var -> TO .)
    EQ              reduce using rule 25 (var -> TO .)
    LTE             reduce using rule 25 (var -> TO .)
    GTE             reduce using rule 25 (var -> TO .)
    LT              reduce using rule 25 (var -> TO .)
    GT              reduce using rule 25 (var -> TO .)
    OR              reduce using rule 25 (var -> TO .)
    AND             reduce using rule 25 (var -> TO .)
    RETURN          reduce using rule 25 (var -> TO .)
    ID              reduce using rule 25 (var -> TO .)
    FROM            reduce using rule 25 (var -> TO .)
    DO              reduce using rule 25 (var -> TO .)
    WHILE           reduce using rule 25 (var -> TO .)
    INPUT           reduce using rule 25 (var -> TO .)
    PRINT           reduce using rule 25 (var -> TO .)
    IF              reduce using rule 25 (var -> TO .)
    RCURLY          reduce using rule 25 (var -> TO .)
    ASSIGN          reduce using rule 25 (var -> TO .)
    RPAREN          reduce using rule 25 (var -> TO .)
    TO              reduce using rule 25 (var -> TO .)


state 38

    (26) var -> FROM .
    COMMA           reduce using rule 26 (var -> FROM .)
    SEMICOLON       reduce using rule 26 (var -> FROM .)
    DIVIDE          reduce using rule 26 (var -> FROM .)
    TIMES           reduce using rule 26 (var -> FROM .)
    MINUS           reduce using rule 26 (var -> FROM .)
    PLUS            reduce using rule 26 (var -> FROM .)
    NEQ             reduce using rule 26 (var -> FROM .)
    EQ              reduce using rule 26 (var -> FROM .)
    LTE             reduce using rule 26 (var -> FROM .)
    GTE             reduce using rule 26 (var -> FROM .)
    LT              reduce using rule 26 (var -> FROM .)
    GT              reduce using rule 26 (var -> FROM .)
    OR              reduce using rule 26 (var -> FROM .)
    AND             reduce using rule 26 (var -> FROM .)
    RETURN          reduce using rule 26 (var -> FROM .)
    ID              reduce using rule 26 (var -> FROM .)
    FROM            reduce using rule 26 (var -> FROM .)
    DO              reduce using rule 26 (var -> FROM .)
    WHILE           reduce using rule 26 (var -> FROM .)
    INPUT           reduce using rule 26 (var -> FROM .)
    PRINT           reduce using rule 26 (var -> FROM .)
    IF              reduce using rule 26 (var -> FROM .)
    RCURLY          reduce using rule 26 (var -> FROM .)
    ASSIGN          reduce using rule 26 (var -> FROM .)
    RPAREN          reduce using rule 26 (var -> FROM .)
    TO              reduce using rule 26 (var -> FROM .)


state 39

    (27) var -> VOID .
    COMMA           reduce using rule 27 (var -> VOID .)
    SEMICOLON       reduce using rule 27 (var -> VOID .)
    DIVIDE          reduce using rule 27 (var -> VOID .)
    TIMES           reduce using rule 27 (var -> VOID .)
    MINUS           reduce using rule 27 (var -> VOID .)
    PLUS            reduce using rule 27 (var -> VOID .)
    NEQ             reduce using rule 27 (var -> VOID .)
    EQ              reduce using rule 27 (var -> VOID .)
    LTE             reduce using rule 27 (var -> VOID .)
    GTE             reduce using rule 27 (var -> VOID .)
    LT              reduce using rule 27 (var -> VOID .)
    GT              reduce using rule 27 (var -> VOID .)
    OR              reduce using rule 27 (var -> VOID .)
    AND             reduce using rule 27 (var -> VOID .)
    RETURN          reduce using rule 27 (var -> VOID .)
    ID              reduce using rule 27 (var -> VOID .)
    FROM            reduce using rule 27 (var -> VOID .)
    DO              reduce using rule 27 (var -> VOID .)
    WHILE           reduce using rule 27 (var -> VOID .)
    INPUT           reduce using rule 27 (var -> VOID .)
    PRINT           reduce using rule 27 (var -> VOID .)
    IF              reduce using rule 27 (var -> VOID .)
    RCURLY          reduce using rule 27 (var -> VOID .)
    ASSIGN          reduce using rule 27 (var -> VOID .)
    RPAREN          reduce using rule 27 (var -> VOID .)
    TO              reduce using rule 27 (var -> VOID .)


state 40

    (28) var -> RETURN .
    COMMA           reduce using rule 28 (var -> RETURN .)
    SEMICOLON       reduce using rule 28 (var -> RETURN .)
    DIVIDE          reduce using rule 28 (var -> RETURN .)
    TIMES           reduce using rule 28 (var -> RETURN .)
    MINUS           reduce using rule 28 (var -> RETURN .)
    PLUS            reduce using rule 28 (var -> RETURN .)
    NEQ             reduce using rule 28 (var -> RETURN .)
    EQ              reduce using rule 28 (var -> RETURN .)
    LTE             reduce using rule 28 (var -> RETURN .)
    GTE             reduce using rule 28 (var -> RETURN .)
    LT              reduce using rule 28 (var -> RETURN .)
    GT              reduce using rule 28 (var -> RETURN .)
    OR              reduce using rule 28 (var -> RETURN .)
    AND             reduce using rule 28 (var -> RETURN .)
    RETURN          reduce using rule 28 (var -> RETURN .)
    ID              reduce using rule 28 (var -> RETURN .)
    FROM            reduce using rule 28 (var -> RETURN .)
    DO              reduce using rule 28 (var -> RETURN .)
    WHILE           reduce using rule 28 (var -> RETURN .)
    INPUT           reduce using rule 28 (var -> RETURN .)
    PRINT           reduce using rule 28 (var -> RETURN .)
    IF              reduce using rule 28 (var -> RETURN .)
    RCURLY          reduce using rule 28 (var -> RETURN .)
    ASSIGN          reduce using rule 28 (var -> RETURN .)
    RPAREN          reduce using rule 28 (var -> RETURN .)
    TO              reduce using rule 28 (var -> RETURN .)


state 41

    (29) var -> FUNC .
    COMMA           reduce using rule 29 (var -> FUNC .)
    SEMICOLON       reduce using rule 29 (var -> FUNC .)
    DIVIDE          reduce using rule 29 (var -> FUNC .)
    TIMES           reduce using rule 29 (var -> FUNC .)
    MINUS           reduce using rule 29 (var -> FUNC .)
    PLUS            reduce using rule 29 (var -> FUNC .)
    NEQ             reduce using rule 29 (var -> FUNC .)
    EQ              reduce using rule 29 (var -> FUNC .)
    LTE             reduce using rule 29 (var -> FUNC .)
    GTE             reduce using rule 29 (var -> FUNC .)
    LT              reduce using rule 29 (var -> FUNC .)
    GT              reduce using rule 29 (var -> FUNC .)
    OR              reduce using rule 29 (var -> FUNC .)
    AND             reduce using rule 29 (var -> FUNC .)
    RETURN          reduce using rule 29 (var -> FUNC .)
    ID              reduce using rule 29 (var -> FUNC .)
    FROM            reduce using rule 29 (var -> FUNC .)
    DO              reduce using rule 29 (var -> FUNC .)
    WHILE           reduce using rule 29 (var -> FUNC .)
    INPUT           reduce using rule 29 (var -> FUNC .)
    PRINT           reduce using rule 29 (var -> FUNC .)
    IF              reduce using rule 29 (var -> FUNC .)
    RCURLY          reduce using rule 29 (var -> FUNC .)
    ASSIGN          reduce using rule 29 (var -> FUNC .)
    RPAREN          reduce using rule 29 (var -> FUNC .)
    TO              reduce using rule 29 (var -> FUNC .)


state 42

    (30) var -> MAIN .
    COMMA           reduce using rule 30 (var -> MAIN .)
    SEMICOLON       reduce using rule 30 (var -> MAIN .)
    DIVIDE          reduce using rule 30 (var -> MAIN .)
    TIMES           reduce using rule 30 (var -> MAIN .)
    MINUS           reduce using rule 30 (var -> MAIN .)
    PLUS            reduce using rule 30 (var -> MAIN .)
    NEQ             reduce using rule 30 (var -> MAIN .)
    EQ              reduce using rule 30 (var -> MAIN .)
    LTE             reduce using rule 30 (var -> MAIN .)
    GTE             reduce using rule 30 (var -> MAIN .)
    LT              reduce using rule 30 (var -> MAIN .)
    GT              reduce using rule 30 (var -> MAIN .)
    OR              reduce using rule 30 (var -> MAIN .)
    AND             reduce using rule 30 (var -> MAIN .)
    RETURN          reduce using rule 30 (var -> MAIN .)
    ID              reduce using rule 30 (var -> MAIN .)
    FROM            reduce using rule 30 (var -> MAIN .)
    DO              reduce using rule 30 (var -> MAIN .)
    WHILE           reduce using rule 30 (var -> MAIN .)
    INPUT           reduce using rule 30 (var -> MAIN .)
    PRINT           reduce using rule 30 (var -> MAIN .)
    IF              reduce using rule 30 (var -> MAIN .)
    RCURLY          reduce using rule 30 (var -> MAIN .)
    ASSIGN          reduce using rule 30 (var -> MAIN .)
    RPAREN          reduce using rule 30 (var -> MAIN .)
    TO              reduce using rule 30 (var -> MAIN .)


state 43

    (31) var -> VARS .
    COMMA           reduce using rule 31 (var -> VARS .)
    SEMICOLON       reduce using rule 31 (var -> VARS .)
    DIVIDE          reduce using rule 31 (var -> VARS .)
    TIMES           reduce using rule 31 (var -> VARS .)
    MINUS           reduce using rule 31 (var -> VARS .)
    PLUS            reduce using rule 31 (var -> VARS .)
    NEQ             reduce using rule 31 (var -> VARS .)
    EQ              reduce using rule 31 (var -> VARS .)
    LTE             reduce using rule 31 (var -> VARS .)
    GTE             reduce using rule 31 (var -> VARS .)
    LT              reduce using rule 31 (var -> VARS .)
    GT              reduce using rule 31 (var -> VARS .)
    OR              reduce using rule 31 (var -> VARS .)
    AND             reduce using rule 31 (var -> VARS .)
    RETURN          reduce using rule 31 (var -> VARS .)
    ID              reduce using rule 31 (var -> VARS .)
    FROM            reduce using rule 31 (var -> VARS .)
    DO              reduce using rule 31 (var -> VARS .)
    WHILE           reduce using rule 31 (var -> VARS .)
    INPUT           reduce using rule 31 (var -> VARS .)
    PRINT           reduce using rule 31 (var -> VARS .)
    IF              reduce using rule 31 (var -> VARS .)
    RCURLY          reduce using rule 31 (var -> VARS .)
    ASSIGN          reduce using rule 31 (var -> VARS .)
    RPAREN          reduce using rule 31 (var -> VARS .)
    TO              reduce using rule 31 (var -> VARS .)


state 44

    (32) var -> PROGRAM .
    COMMA           reduce using rule 32 (var -> PROGRAM .)
    SEMICOLON       reduce using rule 32 (var -> PROGRAM .)
    DIVIDE          reduce using rule 32 (var -> PROGRAM .)
    TIMES           reduce using rule 32 (var -> PROGRAM .)
    MINUS           reduce using rule 32 (var -> PROGRAM .)
    PLUS            reduce using rule 32 (var -> PROGRAM .)
    NEQ             reduce using rule 32 (var -> PROGRAM .)
    EQ              reduce using rule 32 (var -> PROGRAM .)
    LTE             reduce using rule 32 (var -> PROGRAM .)
    GTE             reduce using rule 32 (var -> PROGRAM .)
    LT              reduce using rule 32 (var -> PROGRAM .)
    GT              reduce using rule 32 (var -> PROGRAM .)
    OR              reduce using rule 32 (var -> PROGRAM .)
    AND             reduce using rule 32 (var -> PROGRAM .)
    RETURN          reduce using rule 32 (var -> PROGRAM .)
    ID              reduce using rule 32 (var -> PROGRAM .)
    FROM            reduce using rule 32 (var -> PROGRAM .)
    DO              reduce using rule 32 (var -> PROGRAM .)
    WHILE           reduce using rule 32 (var -> PROGRAM .)
    INPUT           reduce using rule 32 (var -> PROGRAM .)
    PRINT           reduce using rule 32 (var -> PROGRAM .)
    IF              reduce using rule 32 (var -> PROGRAM .)
    RCURLY          reduce using rule 32 (var -> PROGRAM .)
    ASSIGN          reduce using rule 32 (var -> PROGRAM .)
    RPAREN          reduce using rule 32 (var -> PROGRAM .)
    TO              reduce using rule 32 (var -> PROGRAM .)


state 45

    (33) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID . LBRACKET CTEINT RBRACKET
    (35) var -> ID .
    LBRACKET        shift and go to state 50
    COMMA           reduce using rule 35 (var -> ID .)
    SEMICOLON       reduce using rule 35 (var -> ID .)
    ASSIGN          reduce using rule 35 (var -> ID .)
    RPAREN          reduce using rule 35 (var -> ID .)


state 46

    (3) main_block -> MAIN changecontext . LPAREN RPAREN declareblock
    LPAREN          shift and go to state 51


state 47

    (38) func -> FUNC functype ID . changecontext LPAREN params RPAREN declareblock
    (125) changecontext -> .
    LPAREN          reduce using rule 125 (changecontext -> .)

    changecontext                  shift and go to state 52

state 48

    (10) decvar_line -> decvar_type decvar SEMICOLON . decvar_line
    (11) decvar_line -> decvar_type decvar SEMICOLON .
    (10) decvar_line -> . decvar_type decvar SEMICOLON decvar_line
    (11) decvar_line -> . decvar_type decvar SEMICOLON
    (12) decvar_type -> . type
    (112) type -> . BOOL
    (113) type -> . FLOAT
    (114) type -> . INT
    FUNC            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    MAIN            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    RETURN          reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    ID              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    FROM            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    DO              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    WHILE           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    INPUT           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    PRINT           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    IF              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    RCURLY          reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    decvar_type                    shift and go to state 14
    decvar_line                    shift and go to state 53
    type                           shift and go to state 15

state 49

    (13) decvar -> var COMMA . decvar
    (13) decvar -> . var COMMA decvar
    (14) decvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 26
    decvar                         shift and go to state 54

state 50

    (33) var -> ID LBRACKET . CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 55


state 51

    (3) main_block -> MAIN changecontext LPAREN . RPAREN declareblock
    RPAREN          shift and go to state 56


state 52

    (38) func -> FUNC functype ID changecontext . LPAREN params RPAREN declareblock
    LPAREN          shift and go to state 57


state 53

    (10) decvar_line -> decvar_type decvar SEMICOLON decvar_line .
    FUNC            reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    MAIN            reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    DO              reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)


state 54

    (13) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 13 (decvar -> var COMMA decvar .)


state 55

    (33) var -> ID LBRACKET CTEINT . RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 58


state 56

    (3) main_block -> MAIN changecontext LPAREN RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 60

    declareblock                   shift and go to state 59

state 57

    (38) func -> FUNC functype ID changecontext LPAREN . params RPAREN declareblock
    (41) params -> . empty
    (42) params -> . param params_aux
    (127) empty -> .
    (43) param -> . type ID
    (112) type -> . BOOL
    (113) type -> . FLOAT
    (114) type -> . INT
    RPAREN          reduce using rule 127 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    params                         shift and go to state 61
    empty                          shift and go to state 62
    param                          shift and go to state 63
    type                           shift and go to state 64

state 58

    (33) var -> ID LBRACKET CTEINT RBRACKET . LBRACKET CTEINT RBRACKET
    (34) var -> ID LBRACKET CTEINT RBRACKET .
    LBRACKET        shift and go to state 65
    COMMA           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    RETURN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    ID              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    FROM            reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    WHILE           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    INPUT           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    PRINT           reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    IF              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    RCURLY          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 34 (var -> ID LBRACKET CTEINT RBRACKET .)


state 59

    (3) main_block -> MAIN changecontext LPAREN RPAREN declareblock .
    $end            reduce using rule 3 (main_block -> MAIN changecontext LPAREN RPAREN declareblock .)


state 60

    (5) declareblock -> LCURLY . decvars blockcontent RCURLY
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (127) empty -> .
    VARS            shift and go to state 8
    RETURN          reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)

    decvars                        shift and go to state 66
    empty                          shift and go to state 7

state 61

    (38) func -> FUNC functype ID changecontext LPAREN params . RPAREN declareblock
    RPAREN          shift and go to state 67


state 62

    (41) params -> empty .
    RPAREN          reduce using rule 41 (params -> empty .)


state 63

    (42) params -> param . params_aux
    (44) params_aux -> . empty
    (45) params_aux -> . COMMA params
    (127) empty -> .
    COMMA           shift and go to state 70
    RPAREN          reduce using rule 127 (empty -> .)

    params_aux                     shift and go to state 68
    empty                          shift and go to state 69

state 64

    (43) param -> type . ID
    ID              shift and go to state 71


state 65

    (33) var -> ID LBRACKET CTEINT RBRACKET LBRACKET . CTEINT RBRACKET
    CTEINT          shift and go to state 72


state 66

    (5) declareblock -> LCURLY decvars . blockcontent RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (127) empty -> .
    (116) statute -> . returnstmt
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (115) returnstmt -> . RETURN super_exp
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (85) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (91) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (90) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (95) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (99) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (104) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (105) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (92) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (94) assignment_var -> . ID
    RCURLY          reduce using rule 127 (empty -> .)
    RETURN          shift and go to state 85
    ID              shift and go to state 86
    FROM            shift and go to state 87
    DO              shift and go to state 88
    WHILE           shift and go to state 89
    INPUT           shift and go to state 90
    PRINT           shift and go to state 91
    IF              shift and go to state 92

    blockcontent                   shift and go to state 73
    empty                          shift and go to state 74
    statute                        shift and go to state 75
    returnstmt                     shift and go to state 76
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 93

state 67

    (38) func -> FUNC functype ID changecontext LPAREN params RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 60

    declareblock                   shift and go to state 94

state 68

    (42) params -> param params_aux .
    RPAREN          reduce using rule 42 (params -> param params_aux .)


state 69

    (44) params_aux -> empty .
    RPAREN          reduce using rule 44 (params_aux -> empty .)


state 70

    (45) params_aux -> COMMA . params
    (41) params -> . empty
    (42) params -> . param params_aux
    (127) empty -> .
    (43) param -> . type ID
    (112) type -> . BOOL
    (113) type -> . FLOAT
    (114) type -> . INT
    RPAREN          reduce using rule 127 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    params                         shift and go to state 95
    empty                          shift and go to state 62
    param                          shift and go to state 63
    type                           shift and go to state 64

state 71

    (43) param -> type ID .
    COMMA           reduce using rule 43 (param -> type ID .)
    RPAREN          reduce using rule 43 (param -> type ID .)


state 72

    (33) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT . RBRACKET
    RBRACKET        shift and go to state 96


state 73

    (5) declareblock -> LCURLY decvars blockcontent . RCURLY
    RCURLY          shift and go to state 97


state 74

    (6) blockcontent -> empty .
    RCURLY          reduce using rule 6 (blockcontent -> empty .)


state 75

    (7) blockcontent -> statute . blockcontent
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (127) empty -> .
    (116) statute -> . returnstmt
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (115) returnstmt -> . RETURN super_exp
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (85) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (91) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (90) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (95) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (99) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (104) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (105) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (92) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (94) assignment_var -> . ID
    RCURLY          reduce using rule 127 (empty -> .)
    RETURN          shift and go to state 85
    ID              shift and go to state 86
    FROM            shift and go to state 87
    DO              shift and go to state 88
    WHILE           shift and go to state 89
    INPUT           shift and go to state 90
    PRINT           shift and go to state 91
    IF              shift and go to state 92

    statute                        shift and go to state 75
    blockcontent                   shift and go to state 98
    empty                          shift and go to state 74
    returnstmt                     shift and go to state 76
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 93

state 76

    (116) statute -> returnstmt .
    RETURN          reduce using rule 116 (statute -> returnstmt .)
    ID              reduce using rule 116 (statute -> returnstmt .)
    FROM            reduce using rule 116 (statute -> returnstmt .)
    DO              reduce using rule 116 (statute -> returnstmt .)
    WHILE           reduce using rule 116 (statute -> returnstmt .)
    INPUT           reduce using rule 116 (statute -> returnstmt .)
    PRINT           reduce using rule 116 (statute -> returnstmt .)
    IF              reduce using rule 116 (statute -> returnstmt .)
    RCURLY          reduce using rule 116 (statute -> returnstmt .)


state 77

    (117) statute -> call .
    RETURN          reduce using rule 117 (statute -> call .)
    ID              reduce using rule 117 (statute -> call .)
    FROM            reduce using rule 117 (statute -> call .)
    DO              reduce using rule 117 (statute -> call .)
    WHILE           reduce using rule 117 (statute -> call .)
    INPUT           reduce using rule 117 (statute -> call .)
    PRINT           reduce using rule 117 (statute -> call .)
    IF              reduce using rule 117 (statute -> call .)
    RCURLY          reduce using rule 117 (statute -> call .)


state 78

    (118) statute -> forloop .
    RETURN          reduce using rule 118 (statute -> forloop .)
    ID              reduce using rule 118 (statute -> forloop .)
    FROM            reduce using rule 118 (statute -> forloop .)
    DO              reduce using rule 118 (statute -> forloop .)
    WHILE           reduce using rule 118 (statute -> forloop .)
    INPUT           reduce using rule 118 (statute -> forloop .)
    PRINT           reduce using rule 118 (statute -> forloop .)
    IF              reduce using rule 118 (statute -> forloop .)
    RCURLY          reduce using rule 118 (statute -> forloop .)


state 79

    (119) statute -> dowhileloop .
    RETURN          reduce using rule 119 (statute -> dowhileloop .)
    ID              reduce using rule 119 (statute -> dowhileloop .)
    FROM            reduce using rule 119 (statute -> dowhileloop .)
    DO              reduce using rule 119 (statute -> dowhileloop .)
    WHILE           reduce using rule 119 (statute -> dowhileloop .)
    INPUT           reduce using rule 119 (statute -> dowhileloop .)
    PRINT           reduce using rule 119 (statute -> dowhileloop .)
    IF              reduce using rule 119 (statute -> dowhileloop .)
    RCURLY          reduce using rule 119 (statute -> dowhileloop .)


state 80

    (120) statute -> whileloop .
    RETURN          reduce using rule 120 (statute -> whileloop .)
    ID              reduce using rule 120 (statute -> whileloop .)
    FROM            reduce using rule 120 (statute -> whileloop .)
    DO              reduce using rule 120 (statute -> whileloop .)
    WHILE           reduce using rule 120 (statute -> whileloop .)
    INPUT           reduce using rule 120 (statute -> whileloop .)
    PRINT           reduce using rule 120 (statute -> whileloop .)
    IF              reduce using rule 120 (statute -> whileloop .)
    RCURLY          reduce using rule 120 (statute -> whileloop .)


state 81

    (121) statute -> read .
    RETURN          reduce using rule 121 (statute -> read .)
    ID              reduce using rule 121 (statute -> read .)
    FROM            reduce using rule 121 (statute -> read .)
    DO              reduce using rule 121 (statute -> read .)
    WHILE           reduce using rule 121 (statute -> read .)
    INPUT           reduce using rule 121 (statute -> read .)
    PRINT           reduce using rule 121 (statute -> read .)
    IF              reduce using rule 121 (statute -> read .)
    RCURLY          reduce using rule 121 (statute -> read .)


state 82

    (122) statute -> write .
    RETURN          reduce using rule 122 (statute -> write .)
    ID              reduce using rule 122 (statute -> write .)
    FROM            reduce using rule 122 (statute -> write .)
    DO              reduce using rule 122 (statute -> write .)
    WHILE           reduce using rule 122 (statute -> write .)
    INPUT           reduce using rule 122 (statute -> write .)
    PRINT           reduce using rule 122 (statute -> write .)
    IF              reduce using rule 122 (statute -> write .)
    RCURLY          reduce using rule 122 (statute -> write .)


state 83

    (123) statute -> condition .
    RETURN          reduce using rule 123 (statute -> condition .)
    ID              reduce using rule 123 (statute -> condition .)
    FROM            reduce using rule 123 (statute -> condition .)
    DO              reduce using rule 123 (statute -> condition .)
    WHILE           reduce using rule 123 (statute -> condition .)
    INPUT           reduce using rule 123 (statute -> condition .)
    PRINT           reduce using rule 123 (statute -> condition .)
    IF              reduce using rule 123 (statute -> condition .)
    RCURLY          reduce using rule 123 (statute -> condition .)


state 84

    (124) statute -> assignment .
    RETURN          reduce using rule 124 (statute -> assignment .)
    ID              reduce using rule 124 (statute -> assignment .)
    FROM            reduce using rule 124 (statute -> assignment .)
    DO              reduce using rule 124 (statute -> assignment .)
    WHILE           reduce using rule 124 (statute -> assignment .)
    INPUT           reduce using rule 124 (statute -> assignment .)
    PRINT           reduce using rule 124 (statute -> assignment .)
    IF              reduce using rule 124 (statute -> assignment .)
    RCURLY          reduce using rule 124 (statute -> assignment .)


state 85

    (115) returnstmt -> RETURN . super_exp
    (54) super_exp -> . expression super_exp_quadgen super_exp_aux
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 99
    expression                     shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 86

    (46) call -> ID . generate_era LPAREN callvalues RPAREN
    (94) assignment_var -> ID .
    (47) generate_era -> .
    ASSIGN          reduce using rule 94 (assignment_var -> ID .)
    LPAREN          reduce using rule 47 (generate_era -> .)

    generate_era                   shift and go to state 112

state 87

    (85) forloop -> FROM . forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (86) forloopcontrolvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    forloopcontrolvar              shift and go to state 113
    var                            shift and go to state 114

state 88

    (91) dowhileloop -> DO . saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (107) saveposition -> .
    LCURLY          reduce using rule 107 (saveposition -> .)

    saveposition                   shift and go to state 115

state 89

    (90) whileloop -> WHILE . saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (107) saveposition -> .
    LPAREN          reduce using rule 107 (saveposition -> .)

    saveposition                   shift and go to state 116

state 90

    (95) read -> INPUT . LPAREN readaux RPAREN SEMICOLON
    LPAREN          shift and go to state 117


state 91

    (99) write -> PRINT . LPAREN writeaux RPAREN SEMICOLON
    LPAREN          shift and go to state 118


state 92

    (104) condition -> IF . LPAREN super_exp RPAREN openjumpslot block filljumps
    (105) condition -> IF . LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    LPAREN          shift and go to state 119


state 93

    (92) assignment -> assignment_var . assignment_sign expression SEMICOLON
    (93) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 121

    assignment_sign                shift and go to state 120

state 94

    (38) func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock .
    FUNC            reduce using rule 38 (func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock .)
    MAIN            reduce using rule 38 (func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock .)


state 95

    (45) params_aux -> COMMA params .
    RPAREN          reduce using rule 45 (params_aux -> COMMA params .)


state 96

    (33) var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .
    COMMA           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DIVIDE          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TIMES           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    MINUS           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    PLUS            reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    NEQ             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    EQ              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LTE             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GTE             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    LT              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    GT              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    OR              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    AND             reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RETURN          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    ID              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    FROM            reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    DO              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    WHILE           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    INPUT           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    PRINT           reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    IF              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RCURLY          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    ASSIGN          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    RPAREN          reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)
    TO              reduce using rule 33 (var -> ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET .)


state 97

    (5) declareblock -> LCURLY decvars blockcontent RCURLY .
    $end            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    FUNC            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    MAIN            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)


state 98

    (7) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 7 (blockcontent -> statute blockcontent .)


state 99

    (115) returnstmt -> RETURN super_exp .
    RETURN          reduce using rule 115 (returnstmt -> RETURN super_exp .)
    ID              reduce using rule 115 (returnstmt -> RETURN super_exp .)
    FROM            reduce using rule 115 (returnstmt -> RETURN super_exp .)
    DO              reduce using rule 115 (returnstmt -> RETURN super_exp .)
    WHILE           reduce using rule 115 (returnstmt -> RETURN super_exp .)
    INPUT           reduce using rule 115 (returnstmt -> RETURN super_exp .)
    PRINT           reduce using rule 115 (returnstmt -> RETURN super_exp .)
    IF              reduce using rule 115 (returnstmt -> RETURN super_exp .)
    RCURLY          reduce using rule 115 (returnstmt -> RETURN super_exp .)


state 100

    (54) super_exp -> expression . super_exp_quadgen super_exp_aux
    (57) super_exp_quadgen -> .
    OR              reduce using rule 57 (super_exp_quadgen -> .)
    AND             reduce using rule 57 (super_exp_quadgen -> .)
    RETURN          reduce using rule 57 (super_exp_quadgen -> .)
    ID              reduce using rule 57 (super_exp_quadgen -> .)
    FROM            reduce using rule 57 (super_exp_quadgen -> .)
    DO              reduce using rule 57 (super_exp_quadgen -> .)
    WHILE           reduce using rule 57 (super_exp_quadgen -> .)
    INPUT           reduce using rule 57 (super_exp_quadgen -> .)
    PRINT           reduce using rule 57 (super_exp_quadgen -> .)
    IF              reduce using rule 57 (super_exp_quadgen -> .)
    RCURLY          reduce using rule 57 (super_exp_quadgen -> .)
    COMMA           reduce using rule 57 (super_exp_quadgen -> .)
    RPAREN          reduce using rule 57 (super_exp_quadgen -> .)

    super_exp_quadgen              shift and go to state 122

state 101

    (60) expression -> exp . expression_quadgen expression_aux
    (67) expression_quadgen -> .
    NEQ             reduce using rule 67 (expression_quadgen -> .)
    EQ              reduce using rule 67 (expression_quadgen -> .)
    LTE             reduce using rule 67 (expression_quadgen -> .)
    GTE             reduce using rule 67 (expression_quadgen -> .)
    LT              reduce using rule 67 (expression_quadgen -> .)
    GT              reduce using rule 67 (expression_quadgen -> .)
    OR              reduce using rule 67 (expression_quadgen -> .)
    AND             reduce using rule 67 (expression_quadgen -> .)
    RETURN          reduce using rule 67 (expression_quadgen -> .)
    ID              reduce using rule 67 (expression_quadgen -> .)
    FROM            reduce using rule 67 (expression_quadgen -> .)
    DO              reduce using rule 67 (expression_quadgen -> .)
    WHILE           reduce using rule 67 (expression_quadgen -> .)
    INPUT           reduce using rule 67 (expression_quadgen -> .)
    PRINT           reduce using rule 67 (expression_quadgen -> .)
    IF              reduce using rule 67 (expression_quadgen -> .)
    RCURLY          reduce using rule 67 (expression_quadgen -> .)
    COMMA           reduce using rule 67 (expression_quadgen -> .)
    RPAREN          reduce using rule 67 (expression_quadgen -> .)
    SEMICOLON       reduce using rule 67 (expression_quadgen -> .)
    TO              reduce using rule 67 (expression_quadgen -> .)

    expression_quadgen             shift and go to state 123

state 102

    (70) exp -> term . exp_quadgen exp_aux
    (73) exp_quadgen -> .
    MINUS           reduce using rule 73 (exp_quadgen -> .)
    PLUS            reduce using rule 73 (exp_quadgen -> .)
    NEQ             reduce using rule 73 (exp_quadgen -> .)
    EQ              reduce using rule 73 (exp_quadgen -> .)
    LTE             reduce using rule 73 (exp_quadgen -> .)
    GTE             reduce using rule 73 (exp_quadgen -> .)
    LT              reduce using rule 73 (exp_quadgen -> .)
    GT              reduce using rule 73 (exp_quadgen -> .)
    OR              reduce using rule 73 (exp_quadgen -> .)
    AND             reduce using rule 73 (exp_quadgen -> .)
    RETURN          reduce using rule 73 (exp_quadgen -> .)
    ID              reduce using rule 73 (exp_quadgen -> .)
    FROM            reduce using rule 73 (exp_quadgen -> .)
    DO              reduce using rule 73 (exp_quadgen -> .)
    WHILE           reduce using rule 73 (exp_quadgen -> .)
    INPUT           reduce using rule 73 (exp_quadgen -> .)
    PRINT           reduce using rule 73 (exp_quadgen -> .)
    IF              reduce using rule 73 (exp_quadgen -> .)
    RCURLY          reduce using rule 73 (exp_quadgen -> .)
    COMMA           reduce using rule 73 (exp_quadgen -> .)
    RPAREN          reduce using rule 73 (exp_quadgen -> .)
    SEMICOLON       reduce using rule 73 (exp_quadgen -> .)
    TO              reduce using rule 73 (exp_quadgen -> .)

    exp_quadgen                    shift and go to state 124

state 103

    (76) term -> factor . term_quadgen term_aux
    (79) term_quadgen -> .
    DIVIDE          reduce using rule 79 (term_quadgen -> .)
    TIMES           reduce using rule 79 (term_quadgen -> .)
    MINUS           reduce using rule 79 (term_quadgen -> .)
    PLUS            reduce using rule 79 (term_quadgen -> .)
    NEQ             reduce using rule 79 (term_quadgen -> .)
    EQ              reduce using rule 79 (term_quadgen -> .)
    LTE             reduce using rule 79 (term_quadgen -> .)
    GTE             reduce using rule 79 (term_quadgen -> .)
    LT              reduce using rule 79 (term_quadgen -> .)
    GT              reduce using rule 79 (term_quadgen -> .)
    OR              reduce using rule 79 (term_quadgen -> .)
    AND             reduce using rule 79 (term_quadgen -> .)
    RETURN          reduce using rule 79 (term_quadgen -> .)
    ID              reduce using rule 79 (term_quadgen -> .)
    FROM            reduce using rule 79 (term_quadgen -> .)
    DO              reduce using rule 79 (term_quadgen -> .)
    WHILE           reduce using rule 79 (term_quadgen -> .)
    INPUT           reduce using rule 79 (term_quadgen -> .)
    PRINT           reduce using rule 79 (term_quadgen -> .)
    IF              reduce using rule 79 (term_quadgen -> .)
    RCURLY          reduce using rule 79 (term_quadgen -> .)
    COMMA           reduce using rule 79 (term_quadgen -> .)
    RPAREN          reduce using rule 79 (term_quadgen -> .)
    SEMICOLON       reduce using rule 79 (term_quadgen -> .)
    TO              reduce using rule 79 (term_quadgen -> .)

    term_quadgen                   shift and go to state 125

state 104

    (80) factor -> LPAREN . fakefloor super_exp RPAREN
    (84) fakefloor -> .
    LPAREN          reduce using rule 84 (fakefloor -> .)
    CTEBOOL         reduce using rule 84 (fakefloor -> .)
    CTEFLOAT        reduce using rule 84 (fakefloor -> .)
    CTEINT          reduce using rule 84 (fakefloor -> .)
    ID              reduce using rule 84 (fakefloor -> .)
    BOOL            reduce using rule 84 (fakefloor -> .)
    FLOAT           reduce using rule 84 (fakefloor -> .)
    INT             reduce using rule 84 (fakefloor -> .)
    ELSE            reduce using rule 84 (fakefloor -> .)
    IF              reduce using rule 84 (fakefloor -> .)
    PRINT           reduce using rule 84 (fakefloor -> .)
    INPUT           reduce using rule 84 (fakefloor -> .)
    WHILE           reduce using rule 84 (fakefloor -> .)
    DO              reduce using rule 84 (fakefloor -> .)
    BY              reduce using rule 84 (fakefloor -> .)
    TO              reduce using rule 84 (fakefloor -> .)
    FROM            reduce using rule 84 (fakefloor -> .)
    VOID            reduce using rule 84 (fakefloor -> .)
    RETURN          reduce using rule 84 (fakefloor -> .)
    FUNC            reduce using rule 84 (fakefloor -> .)
    MAIN            reduce using rule 84 (fakefloor -> .)
    VARS            reduce using rule 84 (fakefloor -> .)
    PROGRAM         reduce using rule 84 (fakefloor -> .)

    fakefloor                      shift and go to state 126

state 105

    (81) factor -> varcte .
    DIVIDE          reduce using rule 81 (factor -> varcte .)
    TIMES           reduce using rule 81 (factor -> varcte .)
    MINUS           reduce using rule 81 (factor -> varcte .)
    PLUS            reduce using rule 81 (factor -> varcte .)
    NEQ             reduce using rule 81 (factor -> varcte .)
    EQ              reduce using rule 81 (factor -> varcte .)
    LTE             reduce using rule 81 (factor -> varcte .)
    GTE             reduce using rule 81 (factor -> varcte .)
    LT              reduce using rule 81 (factor -> varcte .)
    GT              reduce using rule 81 (factor -> varcte .)
    OR              reduce using rule 81 (factor -> varcte .)
    AND             reduce using rule 81 (factor -> varcte .)
    RETURN          reduce using rule 81 (factor -> varcte .)
    ID              reduce using rule 81 (factor -> varcte .)
    FROM            reduce using rule 81 (factor -> varcte .)
    DO              reduce using rule 81 (factor -> varcte .)
    WHILE           reduce using rule 81 (factor -> varcte .)
    INPUT           reduce using rule 81 (factor -> varcte .)
    PRINT           reduce using rule 81 (factor -> varcte .)
    IF              reduce using rule 81 (factor -> varcte .)
    RCURLY          reduce using rule 81 (factor -> varcte .)
    COMMA           reduce using rule 81 (factor -> varcte .)
    RPAREN          reduce using rule 81 (factor -> varcte .)
    SEMICOLON       reduce using rule 81 (factor -> varcte .)
    TO              reduce using rule 81 (factor -> varcte .)


state 106

    (82) factor -> call .
    DIVIDE          reduce using rule 82 (factor -> call .)
    TIMES           reduce using rule 82 (factor -> call .)
    MINUS           reduce using rule 82 (factor -> call .)
    PLUS            reduce using rule 82 (factor -> call .)
    NEQ             reduce using rule 82 (factor -> call .)
    EQ              reduce using rule 82 (factor -> call .)
    LTE             reduce using rule 82 (factor -> call .)
    GTE             reduce using rule 82 (factor -> call .)
    LT              reduce using rule 82 (factor -> call .)
    GT              reduce using rule 82 (factor -> call .)
    OR              reduce using rule 82 (factor -> call .)
    AND             reduce using rule 82 (factor -> call .)
    RETURN          reduce using rule 82 (factor -> call .)
    ID              reduce using rule 82 (factor -> call .)
    FROM            reduce using rule 82 (factor -> call .)
    DO              reduce using rule 82 (factor -> call .)
    WHILE           reduce using rule 82 (factor -> call .)
    INPUT           reduce using rule 82 (factor -> call .)
    PRINT           reduce using rule 82 (factor -> call .)
    IF              reduce using rule 82 (factor -> call .)
    RCURLY          reduce using rule 82 (factor -> call .)
    COMMA           reduce using rule 82 (factor -> call .)
    RPAREN          reduce using rule 82 (factor -> call .)
    SEMICOLON       reduce using rule 82 (factor -> call .)
    TO              reduce using rule 82 (factor -> call .)


state 107

    (83) factor -> var .
    DIVIDE          reduce using rule 83 (factor -> var .)
    TIMES           reduce using rule 83 (factor -> var .)
    MINUS           reduce using rule 83 (factor -> var .)
    PLUS            reduce using rule 83 (factor -> var .)
    NEQ             reduce using rule 83 (factor -> var .)
    EQ              reduce using rule 83 (factor -> var .)
    LTE             reduce using rule 83 (factor -> var .)
    GTE             reduce using rule 83 (factor -> var .)
    LT              reduce using rule 83 (factor -> var .)
    GT              reduce using rule 83 (factor -> var .)
    OR              reduce using rule 83 (factor -> var .)
    AND             reduce using rule 83 (factor -> var .)
    RETURN          reduce using rule 83 (factor -> var .)
    ID              reduce using rule 83 (factor -> var .)
    FROM            reduce using rule 83 (factor -> var .)
    DO              reduce using rule 83 (factor -> var .)
    WHILE           reduce using rule 83 (factor -> var .)
    INPUT           reduce using rule 83 (factor -> var .)
    PRINT           reduce using rule 83 (factor -> var .)
    IF              reduce using rule 83 (factor -> var .)
    RCURLY          reduce using rule 83 (factor -> var .)
    COMMA           reduce using rule 83 (factor -> var .)
    RPAREN          reduce using rule 83 (factor -> var .)
    SEMICOLON       reduce using rule 83 (factor -> var .)
    TO              reduce using rule 83 (factor -> var .)


state 108

    (109) varcte -> CTEBOOL .
    DIVIDE          reduce using rule 109 (varcte -> CTEBOOL .)
    TIMES           reduce using rule 109 (varcte -> CTEBOOL .)
    MINUS           reduce using rule 109 (varcte -> CTEBOOL .)
    PLUS            reduce using rule 109 (varcte -> CTEBOOL .)
    NEQ             reduce using rule 109 (varcte -> CTEBOOL .)
    EQ              reduce using rule 109 (varcte -> CTEBOOL .)
    LTE             reduce using rule 109 (varcte -> CTEBOOL .)
    GTE             reduce using rule 109 (varcte -> CTEBOOL .)
    LT              reduce using rule 109 (varcte -> CTEBOOL .)
    GT              reduce using rule 109 (varcte -> CTEBOOL .)
    OR              reduce using rule 109 (varcte -> CTEBOOL .)
    AND             reduce using rule 109 (varcte -> CTEBOOL .)
    RETURN          reduce using rule 109 (varcte -> CTEBOOL .)
    ID              reduce using rule 109 (varcte -> CTEBOOL .)
    FROM            reduce using rule 109 (varcte -> CTEBOOL .)
    DO              reduce using rule 109 (varcte -> CTEBOOL .)
    WHILE           reduce using rule 109 (varcte -> CTEBOOL .)
    INPUT           reduce using rule 109 (varcte -> CTEBOOL .)
    PRINT           reduce using rule 109 (varcte -> CTEBOOL .)
    IF              reduce using rule 109 (varcte -> CTEBOOL .)
    RCURLY          reduce using rule 109 (varcte -> CTEBOOL .)
    COMMA           reduce using rule 109 (varcte -> CTEBOOL .)
    RPAREN          reduce using rule 109 (varcte -> CTEBOOL .)
    SEMICOLON       reduce using rule 109 (varcte -> CTEBOOL .)
    TO              reduce using rule 109 (varcte -> CTEBOOL .)


state 109

    (110) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 110 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 110 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 110 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 110 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 110 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 110 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 110 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 110 (varcte -> CTEFLOAT .)
    LT              reduce using rule 110 (varcte -> CTEFLOAT .)
    GT              reduce using rule 110 (varcte -> CTEFLOAT .)
    OR              reduce using rule 110 (varcte -> CTEFLOAT .)
    AND             reduce using rule 110 (varcte -> CTEFLOAT .)
    RETURN          reduce using rule 110 (varcte -> CTEFLOAT .)
    ID              reduce using rule 110 (varcte -> CTEFLOAT .)
    FROM            reduce using rule 110 (varcte -> CTEFLOAT .)
    DO              reduce using rule 110 (varcte -> CTEFLOAT .)
    WHILE           reduce using rule 110 (varcte -> CTEFLOAT .)
    INPUT           reduce using rule 110 (varcte -> CTEFLOAT .)
    PRINT           reduce using rule 110 (varcte -> CTEFLOAT .)
    IF              reduce using rule 110 (varcte -> CTEFLOAT .)
    RCURLY          reduce using rule 110 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 110 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 110 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 110 (varcte -> CTEFLOAT .)
    TO              reduce using rule 110 (varcte -> CTEFLOAT .)


state 110

    (111) varcte -> CTEINT .
    DIVIDE          reduce using rule 111 (varcte -> CTEINT .)
    TIMES           reduce using rule 111 (varcte -> CTEINT .)
    MINUS           reduce using rule 111 (varcte -> CTEINT .)
    PLUS            reduce using rule 111 (varcte -> CTEINT .)
    NEQ             reduce using rule 111 (varcte -> CTEINT .)
    EQ              reduce using rule 111 (varcte -> CTEINT .)
    LTE             reduce using rule 111 (varcte -> CTEINT .)
    GTE             reduce using rule 111 (varcte -> CTEINT .)
    LT              reduce using rule 111 (varcte -> CTEINT .)
    GT              reduce using rule 111 (varcte -> CTEINT .)
    OR              reduce using rule 111 (varcte -> CTEINT .)
    AND             reduce using rule 111 (varcte -> CTEINT .)
    RETURN          reduce using rule 111 (varcte -> CTEINT .)
    ID              reduce using rule 111 (varcte -> CTEINT .)
    FROM            reduce using rule 111 (varcte -> CTEINT .)
    DO              reduce using rule 111 (varcte -> CTEINT .)
    WHILE           reduce using rule 111 (varcte -> CTEINT .)
    INPUT           reduce using rule 111 (varcte -> CTEINT .)
    PRINT           reduce using rule 111 (varcte -> CTEINT .)
    IF              reduce using rule 111 (varcte -> CTEINT .)
    RCURLY          reduce using rule 111 (varcte -> CTEINT .)
    COMMA           reduce using rule 111 (varcte -> CTEINT .)
    RPAREN          reduce using rule 111 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 111 (varcte -> CTEINT .)
    TO              reduce using rule 111 (varcte -> CTEINT .)


state 111

    (46) call -> ID . generate_era LPAREN callvalues RPAREN
    (33) var -> ID . LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> ID . LBRACKET CTEINT RBRACKET
    (35) var -> ID .
    (47) generate_era -> .
    LBRACKET        shift and go to state 50
    DIVIDE          reduce using rule 35 (var -> ID .)
    TIMES           reduce using rule 35 (var -> ID .)
    MINUS           reduce using rule 35 (var -> ID .)
    PLUS            reduce using rule 35 (var -> ID .)
    NEQ             reduce using rule 35 (var -> ID .)
    EQ              reduce using rule 35 (var -> ID .)
    LTE             reduce using rule 35 (var -> ID .)
    GTE             reduce using rule 35 (var -> ID .)
    LT              reduce using rule 35 (var -> ID .)
    GT              reduce using rule 35 (var -> ID .)
    OR              reduce using rule 35 (var -> ID .)
    AND             reduce using rule 35 (var -> ID .)
    RETURN          reduce using rule 35 (var -> ID .)
    ID              reduce using rule 35 (var -> ID .)
    FROM            reduce using rule 35 (var -> ID .)
    DO              reduce using rule 35 (var -> ID .)
    WHILE           reduce using rule 35 (var -> ID .)
    INPUT           reduce using rule 35 (var -> ID .)
    PRINT           reduce using rule 35 (var -> ID .)
    IF              reduce using rule 35 (var -> ID .)
    RCURLY          reduce using rule 35 (var -> ID .)
    COMMA           reduce using rule 35 (var -> ID .)
    RPAREN          reduce using rule 35 (var -> ID .)
    SEMICOLON       reduce using rule 35 (var -> ID .)
    TO              reduce using rule 35 (var -> ID .)
    LPAREN          reduce using rule 47 (generate_era -> .)

    generate_era                   shift and go to state 112

state 112

    (46) call -> ID generate_era . LPAREN callvalues RPAREN
    LPAREN          shift and go to state 127


state 113

    (85) forloop -> FROM forloopcontrolvar . assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (93) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 121

    assignment_sign                shift and go to state 128

state 114

    (86) forloopcontrolvar -> var .
    ASSIGN          reduce using rule 86 (forloopcontrolvar -> var .)


state 115

    (91) dowhileloop -> DO saveposition . block WHILE LPAREN expression RPAREN openjumpslot
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 130

    block                          shift and go to state 129

state 116

    (90) whileloop -> WHILE saveposition . LPAREN expression RPAREN openjumpslot block filljumps
    LPAREN          shift and go to state 131


state 117

    (95) read -> INPUT LPAREN . readaux RPAREN SEMICOLON
    (96) readaux -> . readvalue COMMA readaux
    (97) readaux -> . readvalue
    (98) readvalue -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    readaux                        shift and go to state 132
    readvalue                      shift and go to state 133
    var                            shift and go to state 134

state 118

    (99) write -> PRINT LPAREN . writeaux RPAREN SEMICOLON
    (100) writeaux -> . writevalues
    (101) writeaux -> . writevalues COMMA writeaux
    (102) writevalues -> . CTESTRING
    (103) writevalues -> . super_exp
    (54) super_exp -> . expression super_exp_quadgen super_exp_aux
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    CTESTRING       shift and go to state 137
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    writeaux                       shift and go to state 135
    writevalues                    shift and go to state 136
    super_exp                      shift and go to state 138
    expression                     shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 119

    (104) condition -> IF LPAREN . super_exp RPAREN openjumpslot block filljumps
    (105) condition -> IF LPAREN . super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (54) super_exp -> . expression super_exp_quadgen super_exp_aux
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 139
    expression                     shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 120

    (92) assignment -> assignment_var assignment_sign . expression SEMICOLON
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 140
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 121

    (93) assignment_sign -> ASSIGN .
    LPAREN          reduce using rule 93 (assignment_sign -> ASSIGN .)
    CTEBOOL         reduce using rule 93 (assignment_sign -> ASSIGN .)
    CTEFLOAT        reduce using rule 93 (assignment_sign -> ASSIGN .)
    CTEINT          reduce using rule 93 (assignment_sign -> ASSIGN .)
    ID              reduce using rule 93 (assignment_sign -> ASSIGN .)
    BOOL            reduce using rule 93 (assignment_sign -> ASSIGN .)
    FLOAT           reduce using rule 93 (assignment_sign -> ASSIGN .)
    INT             reduce using rule 93 (assignment_sign -> ASSIGN .)
    ELSE            reduce using rule 93 (assignment_sign -> ASSIGN .)
    IF              reduce using rule 93 (assignment_sign -> ASSIGN .)
    PRINT           reduce using rule 93 (assignment_sign -> ASSIGN .)
    INPUT           reduce using rule 93 (assignment_sign -> ASSIGN .)
    WHILE           reduce using rule 93 (assignment_sign -> ASSIGN .)
    DO              reduce using rule 93 (assignment_sign -> ASSIGN .)
    BY              reduce using rule 93 (assignment_sign -> ASSIGN .)
    TO              reduce using rule 93 (assignment_sign -> ASSIGN .)
    FROM            reduce using rule 93 (assignment_sign -> ASSIGN .)
    VOID            reduce using rule 93 (assignment_sign -> ASSIGN .)
    RETURN          reduce using rule 93 (assignment_sign -> ASSIGN .)
    FUNC            reduce using rule 93 (assignment_sign -> ASSIGN .)
    MAIN            reduce using rule 93 (assignment_sign -> ASSIGN .)
    VARS            reduce using rule 93 (assignment_sign -> ASSIGN .)
    PROGRAM         reduce using rule 93 (assignment_sign -> ASSIGN .)


state 122

    (54) super_exp -> expression super_exp_quadgen . super_exp_aux
    (52) super_exp_aux -> . logic super_exp
    (53) super_exp_aux -> . empty
    (55) logic -> . OR
    (56) logic -> . AND
    (127) empty -> .
    OR              shift and go to state 144
    AND             shift and go to state 145
    RETURN          reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    super_exp_aux                  shift and go to state 141
    logic                          shift and go to state 142
    empty                          shift and go to state 143

state 123

    (60) expression -> exp expression_quadgen . expression_aux
    (58) expression_aux -> . relation expression
    (59) expression_aux -> . empty
    (61) relation -> . NEQ
    (62) relation -> . EQ
    (63) relation -> . LTE
    (64) relation -> . GTE
    (65) relation -> . LT
    (66) relation -> . GT
    (127) empty -> .
    NEQ             shift and go to state 149
    EQ              shift and go to state 150
    LTE             shift and go to state 151
    GTE             shift and go to state 152
    LT              shift and go to state 153
    GT              shift and go to state 154
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)

    expression_aux                 shift and go to state 146
    relation                       shift and go to state 147
    empty                          shift and go to state 148

state 124

    (70) exp -> term exp_quadgen . exp_aux
    (68) exp_aux -> . exp_sign exp
    (69) exp_aux -> . empty
    (71) exp_sign -> . MINUS
    (72) exp_sign -> . PLUS
    (127) empty -> .
    MINUS           shift and go to state 158
    PLUS            shift and go to state 159
    NEQ             reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    LTE             reduce using rule 127 (empty -> .)
    GTE             reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)

    exp_aux                        shift and go to state 155
    exp_sign                       shift and go to state 156
    empty                          shift and go to state 157

state 125

    (76) term -> factor term_quadgen . term_aux
    (74) term_aux -> . term_sign term
    (75) term_aux -> . empty
    (77) term_sign -> . DIVIDE
    (78) term_sign -> . TIMES
    (127) empty -> .
    DIVIDE          shift and go to state 163
    TIMES           shift and go to state 164
    MINUS           reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    LTE             reduce using rule 127 (empty -> .)
    GTE             reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    OR              reduce using rule 127 (empty -> .)
    AND             reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    ID              reduce using rule 127 (empty -> .)
    FROM            reduce using rule 127 (empty -> .)
    DO              reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    INPUT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    RCURLY          reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    TO              reduce using rule 127 (empty -> .)

    term_aux                       shift and go to state 160
    term_sign                      shift and go to state 161
    empty                          shift and go to state 162

state 126

    (80) factor -> LPAREN fakefloor . super_exp RPAREN
    (54) super_exp -> . expression super_exp_quadgen super_exp_aux
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 165
    expression                     shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 127

    (46) call -> ID generate_era LPAREN . callvalues RPAREN
    (50) callvalues -> . exp generate_param callvalues_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    callvalues                     shift and go to state 166
    exp                            shift and go to state 167
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 128

    (85) forloop -> FROM forloopcontrolvar assignment_sign . expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 168
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 129

    (91) dowhileloop -> DO saveposition block . WHILE LPAREN expression RPAREN openjumpslot
    WHILE           shift and go to state 169


state 130

    (4) block -> LCURLY . blockcontent RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (127) empty -> .
    (116) statute -> . returnstmt
    (117) statute -> . call
    (118) statute -> . forloop
    (119) statute -> . dowhileloop
    (120) statute -> . whileloop
    (121) statute -> . read
    (122) statute -> . write
    (123) statute -> . condition
    (124) statute -> . assignment
    (115) returnstmt -> . RETURN super_exp
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (85) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (91) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (90) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (95) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (99) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (104) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (105) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (92) assignment -> . assignment_var assignment_sign expression SEMICOLON
    (94) assignment_var -> . ID
    RCURLY          reduce using rule 127 (empty -> .)
    RETURN          shift and go to state 85
    ID              shift and go to state 86
    FROM            shift and go to state 87
    DO              shift and go to state 88
    WHILE           shift and go to state 89
    INPUT           shift and go to state 90
    PRINT           shift and go to state 91
    IF              shift and go to state 92

    blockcontent                   shift and go to state 170
    empty                          shift and go to state 74
    statute                        shift and go to state 75
    returnstmt                     shift and go to state 76
    call                           shift and go to state 77
    forloop                        shift and go to state 78
    dowhileloop                    shift and go to state 79
    whileloop                      shift and go to state 80
    read                           shift and go to state 81
    write                          shift and go to state 82
    condition                      shift and go to state 83
    assignment                     shift and go to state 84
    assignment_var                 shift and go to state 93

state 131

    (90) whileloop -> WHILE saveposition LPAREN . expression RPAREN openjumpslot block filljumps
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 171
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 132

    (95) read -> INPUT LPAREN readaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 172


state 133

    (96) readaux -> readvalue . COMMA readaux
    (97) readaux -> readvalue .
    COMMA           shift and go to state 173
    RPAREN          reduce using rule 97 (readaux -> readvalue .)


state 134

    (98) readvalue -> var .
    COMMA           reduce using rule 98 (readvalue -> var .)
    RPAREN          reduce using rule 98 (readvalue -> var .)


state 135

    (99) write -> PRINT LPAREN writeaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 174


state 136

    (100) writeaux -> writevalues .
    (101) writeaux -> writevalues . COMMA writeaux
    RPAREN          reduce using rule 100 (writeaux -> writevalues .)
    COMMA           shift and go to state 175


state 137

    (102) writevalues -> CTESTRING .
    COMMA           reduce using rule 102 (writevalues -> CTESTRING .)
    RPAREN          reduce using rule 102 (writevalues -> CTESTRING .)


state 138

    (103) writevalues -> super_exp .
    COMMA           reduce using rule 103 (writevalues -> super_exp .)
    RPAREN          reduce using rule 103 (writevalues -> super_exp .)


state 139

    (104) condition -> IF LPAREN super_exp . RPAREN openjumpslot block filljumps
    (105) condition -> IF LPAREN super_exp . RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    RPAREN          shift and go to state 176


state 140

    (92) assignment -> assignment_var assignment_sign expression . SEMICOLON
    SEMICOLON       shift and go to state 177


state 141

    (54) super_exp -> expression super_exp_quadgen super_exp_aux .
    RETURN          reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    ID              reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    FROM            reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    DO              reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    WHILE           reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    INPUT           reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    PRINT           reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    IF              reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RCURLY          reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    COMMA           reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RPAREN          reduce using rule 54 (super_exp -> expression super_exp_quadgen super_exp_aux .)


state 142

    (52) super_exp_aux -> logic . super_exp
    (54) super_exp -> . expression super_exp_quadgen super_exp_aux
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    super_exp                      shift and go to state 178
    expression                     shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 143

    (53) super_exp_aux -> empty .
    RETURN          reduce using rule 53 (super_exp_aux -> empty .)
    ID              reduce using rule 53 (super_exp_aux -> empty .)
    FROM            reduce using rule 53 (super_exp_aux -> empty .)
    DO              reduce using rule 53 (super_exp_aux -> empty .)
    WHILE           reduce using rule 53 (super_exp_aux -> empty .)
    INPUT           reduce using rule 53 (super_exp_aux -> empty .)
    PRINT           reduce using rule 53 (super_exp_aux -> empty .)
    IF              reduce using rule 53 (super_exp_aux -> empty .)
    RCURLY          reduce using rule 53 (super_exp_aux -> empty .)
    COMMA           reduce using rule 53 (super_exp_aux -> empty .)
    RPAREN          reduce using rule 53 (super_exp_aux -> empty .)


state 144

    (55) logic -> OR .
    LPAREN          reduce using rule 55 (logic -> OR .)
    CTEBOOL         reduce using rule 55 (logic -> OR .)
    CTEFLOAT        reduce using rule 55 (logic -> OR .)
    CTEINT          reduce using rule 55 (logic -> OR .)
    ID              reduce using rule 55 (logic -> OR .)
    BOOL            reduce using rule 55 (logic -> OR .)
    FLOAT           reduce using rule 55 (logic -> OR .)
    INT             reduce using rule 55 (logic -> OR .)
    ELSE            reduce using rule 55 (logic -> OR .)
    IF              reduce using rule 55 (logic -> OR .)
    PRINT           reduce using rule 55 (logic -> OR .)
    INPUT           reduce using rule 55 (logic -> OR .)
    WHILE           reduce using rule 55 (logic -> OR .)
    DO              reduce using rule 55 (logic -> OR .)
    BY              reduce using rule 55 (logic -> OR .)
    TO              reduce using rule 55 (logic -> OR .)
    FROM            reduce using rule 55 (logic -> OR .)
    VOID            reduce using rule 55 (logic -> OR .)
    RETURN          reduce using rule 55 (logic -> OR .)
    FUNC            reduce using rule 55 (logic -> OR .)
    MAIN            reduce using rule 55 (logic -> OR .)
    VARS            reduce using rule 55 (logic -> OR .)
    PROGRAM         reduce using rule 55 (logic -> OR .)


state 145

    (56) logic -> AND .
    LPAREN          reduce using rule 56 (logic -> AND .)
    CTEBOOL         reduce using rule 56 (logic -> AND .)
    CTEFLOAT        reduce using rule 56 (logic -> AND .)
    CTEINT          reduce using rule 56 (logic -> AND .)
    ID              reduce using rule 56 (logic -> AND .)
    BOOL            reduce using rule 56 (logic -> AND .)
    FLOAT           reduce using rule 56 (logic -> AND .)
    INT             reduce using rule 56 (logic -> AND .)
    ELSE            reduce using rule 56 (logic -> AND .)
    IF              reduce using rule 56 (logic -> AND .)
    PRINT           reduce using rule 56 (logic -> AND .)
    INPUT           reduce using rule 56 (logic -> AND .)
    WHILE           reduce using rule 56 (logic -> AND .)
    DO              reduce using rule 56 (logic -> AND .)
    BY              reduce using rule 56 (logic -> AND .)
    TO              reduce using rule 56 (logic -> AND .)
    FROM            reduce using rule 56 (logic -> AND .)
    VOID            reduce using rule 56 (logic -> AND .)
    RETURN          reduce using rule 56 (logic -> AND .)
    FUNC            reduce using rule 56 (logic -> AND .)
    MAIN            reduce using rule 56 (logic -> AND .)
    VARS            reduce using rule 56 (logic -> AND .)
    PROGRAM         reduce using rule 56 (logic -> AND .)


state 146

    (60) expression -> exp expression_quadgen expression_aux .
    OR              reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    AND             reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    RETURN          reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    ID              reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    FROM            reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    DO              reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    WHILE           reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    INPUT           reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    PRINT           reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    IF              reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    RCURLY          reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    COMMA           reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    RPAREN          reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    SEMICOLON       reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)
    TO              reduce using rule 60 (expression -> exp expression_quadgen expression_aux .)


state 147

    (58) expression_aux -> relation . expression
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 179
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 148

    (59) expression_aux -> empty .
    OR              reduce using rule 59 (expression_aux -> empty .)
    AND             reduce using rule 59 (expression_aux -> empty .)
    RETURN          reduce using rule 59 (expression_aux -> empty .)
    ID              reduce using rule 59 (expression_aux -> empty .)
    FROM            reduce using rule 59 (expression_aux -> empty .)
    DO              reduce using rule 59 (expression_aux -> empty .)
    WHILE           reduce using rule 59 (expression_aux -> empty .)
    INPUT           reduce using rule 59 (expression_aux -> empty .)
    PRINT           reduce using rule 59 (expression_aux -> empty .)
    IF              reduce using rule 59 (expression_aux -> empty .)
    RCURLY          reduce using rule 59 (expression_aux -> empty .)
    COMMA           reduce using rule 59 (expression_aux -> empty .)
    RPAREN          reduce using rule 59 (expression_aux -> empty .)
    SEMICOLON       reduce using rule 59 (expression_aux -> empty .)
    TO              reduce using rule 59 (expression_aux -> empty .)


state 149

    (61) relation -> NEQ .
    LPAREN          reduce using rule 61 (relation -> NEQ .)
    CTEBOOL         reduce using rule 61 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 61 (relation -> NEQ .)
    CTEINT          reduce using rule 61 (relation -> NEQ .)
    ID              reduce using rule 61 (relation -> NEQ .)
    BOOL            reduce using rule 61 (relation -> NEQ .)
    FLOAT           reduce using rule 61 (relation -> NEQ .)
    INT             reduce using rule 61 (relation -> NEQ .)
    ELSE            reduce using rule 61 (relation -> NEQ .)
    IF              reduce using rule 61 (relation -> NEQ .)
    PRINT           reduce using rule 61 (relation -> NEQ .)
    INPUT           reduce using rule 61 (relation -> NEQ .)
    WHILE           reduce using rule 61 (relation -> NEQ .)
    DO              reduce using rule 61 (relation -> NEQ .)
    BY              reduce using rule 61 (relation -> NEQ .)
    TO              reduce using rule 61 (relation -> NEQ .)
    FROM            reduce using rule 61 (relation -> NEQ .)
    VOID            reduce using rule 61 (relation -> NEQ .)
    RETURN          reduce using rule 61 (relation -> NEQ .)
    FUNC            reduce using rule 61 (relation -> NEQ .)
    MAIN            reduce using rule 61 (relation -> NEQ .)
    VARS            reduce using rule 61 (relation -> NEQ .)
    PROGRAM         reduce using rule 61 (relation -> NEQ .)


state 150

    (62) relation -> EQ .
    LPAREN          reduce using rule 62 (relation -> EQ .)
    CTEBOOL         reduce using rule 62 (relation -> EQ .)
    CTEFLOAT        reduce using rule 62 (relation -> EQ .)
    CTEINT          reduce using rule 62 (relation -> EQ .)
    ID              reduce using rule 62 (relation -> EQ .)
    BOOL            reduce using rule 62 (relation -> EQ .)
    FLOAT           reduce using rule 62 (relation -> EQ .)
    INT             reduce using rule 62 (relation -> EQ .)
    ELSE            reduce using rule 62 (relation -> EQ .)
    IF              reduce using rule 62 (relation -> EQ .)
    PRINT           reduce using rule 62 (relation -> EQ .)
    INPUT           reduce using rule 62 (relation -> EQ .)
    WHILE           reduce using rule 62 (relation -> EQ .)
    DO              reduce using rule 62 (relation -> EQ .)
    BY              reduce using rule 62 (relation -> EQ .)
    TO              reduce using rule 62 (relation -> EQ .)
    FROM            reduce using rule 62 (relation -> EQ .)
    VOID            reduce using rule 62 (relation -> EQ .)
    RETURN          reduce using rule 62 (relation -> EQ .)
    FUNC            reduce using rule 62 (relation -> EQ .)
    MAIN            reduce using rule 62 (relation -> EQ .)
    VARS            reduce using rule 62 (relation -> EQ .)
    PROGRAM         reduce using rule 62 (relation -> EQ .)


state 151

    (63) relation -> LTE .
    LPAREN          reduce using rule 63 (relation -> LTE .)
    CTEBOOL         reduce using rule 63 (relation -> LTE .)
    CTEFLOAT        reduce using rule 63 (relation -> LTE .)
    CTEINT          reduce using rule 63 (relation -> LTE .)
    ID              reduce using rule 63 (relation -> LTE .)
    BOOL            reduce using rule 63 (relation -> LTE .)
    FLOAT           reduce using rule 63 (relation -> LTE .)
    INT             reduce using rule 63 (relation -> LTE .)
    ELSE            reduce using rule 63 (relation -> LTE .)
    IF              reduce using rule 63 (relation -> LTE .)
    PRINT           reduce using rule 63 (relation -> LTE .)
    INPUT           reduce using rule 63 (relation -> LTE .)
    WHILE           reduce using rule 63 (relation -> LTE .)
    DO              reduce using rule 63 (relation -> LTE .)
    BY              reduce using rule 63 (relation -> LTE .)
    TO              reduce using rule 63 (relation -> LTE .)
    FROM            reduce using rule 63 (relation -> LTE .)
    VOID            reduce using rule 63 (relation -> LTE .)
    RETURN          reduce using rule 63 (relation -> LTE .)
    FUNC            reduce using rule 63 (relation -> LTE .)
    MAIN            reduce using rule 63 (relation -> LTE .)
    VARS            reduce using rule 63 (relation -> LTE .)
    PROGRAM         reduce using rule 63 (relation -> LTE .)


state 152

    (64) relation -> GTE .
    LPAREN          reduce using rule 64 (relation -> GTE .)
    CTEBOOL         reduce using rule 64 (relation -> GTE .)
    CTEFLOAT        reduce using rule 64 (relation -> GTE .)
    CTEINT          reduce using rule 64 (relation -> GTE .)
    ID              reduce using rule 64 (relation -> GTE .)
    BOOL            reduce using rule 64 (relation -> GTE .)
    FLOAT           reduce using rule 64 (relation -> GTE .)
    INT             reduce using rule 64 (relation -> GTE .)
    ELSE            reduce using rule 64 (relation -> GTE .)
    IF              reduce using rule 64 (relation -> GTE .)
    PRINT           reduce using rule 64 (relation -> GTE .)
    INPUT           reduce using rule 64 (relation -> GTE .)
    WHILE           reduce using rule 64 (relation -> GTE .)
    DO              reduce using rule 64 (relation -> GTE .)
    BY              reduce using rule 64 (relation -> GTE .)
    TO              reduce using rule 64 (relation -> GTE .)
    FROM            reduce using rule 64 (relation -> GTE .)
    VOID            reduce using rule 64 (relation -> GTE .)
    RETURN          reduce using rule 64 (relation -> GTE .)
    FUNC            reduce using rule 64 (relation -> GTE .)
    MAIN            reduce using rule 64 (relation -> GTE .)
    VARS            reduce using rule 64 (relation -> GTE .)
    PROGRAM         reduce using rule 64 (relation -> GTE .)


state 153

    (65) relation -> LT .
    LPAREN          reduce using rule 65 (relation -> LT .)
    CTEBOOL         reduce using rule 65 (relation -> LT .)
    CTEFLOAT        reduce using rule 65 (relation -> LT .)
    CTEINT          reduce using rule 65 (relation -> LT .)
    ID              reduce using rule 65 (relation -> LT .)
    BOOL            reduce using rule 65 (relation -> LT .)
    FLOAT           reduce using rule 65 (relation -> LT .)
    INT             reduce using rule 65 (relation -> LT .)
    ELSE            reduce using rule 65 (relation -> LT .)
    IF              reduce using rule 65 (relation -> LT .)
    PRINT           reduce using rule 65 (relation -> LT .)
    INPUT           reduce using rule 65 (relation -> LT .)
    WHILE           reduce using rule 65 (relation -> LT .)
    DO              reduce using rule 65 (relation -> LT .)
    BY              reduce using rule 65 (relation -> LT .)
    TO              reduce using rule 65 (relation -> LT .)
    FROM            reduce using rule 65 (relation -> LT .)
    VOID            reduce using rule 65 (relation -> LT .)
    RETURN          reduce using rule 65 (relation -> LT .)
    FUNC            reduce using rule 65 (relation -> LT .)
    MAIN            reduce using rule 65 (relation -> LT .)
    VARS            reduce using rule 65 (relation -> LT .)
    PROGRAM         reduce using rule 65 (relation -> LT .)


state 154

    (66) relation -> GT .
    LPAREN          reduce using rule 66 (relation -> GT .)
    CTEBOOL         reduce using rule 66 (relation -> GT .)
    CTEFLOAT        reduce using rule 66 (relation -> GT .)
    CTEINT          reduce using rule 66 (relation -> GT .)
    ID              reduce using rule 66 (relation -> GT .)
    BOOL            reduce using rule 66 (relation -> GT .)
    FLOAT           reduce using rule 66 (relation -> GT .)
    INT             reduce using rule 66 (relation -> GT .)
    ELSE            reduce using rule 66 (relation -> GT .)
    IF              reduce using rule 66 (relation -> GT .)
    PRINT           reduce using rule 66 (relation -> GT .)
    INPUT           reduce using rule 66 (relation -> GT .)
    WHILE           reduce using rule 66 (relation -> GT .)
    DO              reduce using rule 66 (relation -> GT .)
    BY              reduce using rule 66 (relation -> GT .)
    TO              reduce using rule 66 (relation -> GT .)
    FROM            reduce using rule 66 (relation -> GT .)
    VOID            reduce using rule 66 (relation -> GT .)
    RETURN          reduce using rule 66 (relation -> GT .)
    FUNC            reduce using rule 66 (relation -> GT .)
    MAIN            reduce using rule 66 (relation -> GT .)
    VARS            reduce using rule 66 (relation -> GT .)
    PROGRAM         reduce using rule 66 (relation -> GT .)


state 155

    (70) exp -> term exp_quadgen exp_aux .
    NEQ             reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    EQ              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    LTE             reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    GTE             reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    LT              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    GT              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    OR              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    AND             reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    RETURN          reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    ID              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    FROM            reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    DO              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    WHILE           reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    INPUT           reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    PRINT           reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    IF              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    RCURLY          reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    COMMA           reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    RPAREN          reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    SEMICOLON       reduce using rule 70 (exp -> term exp_quadgen exp_aux .)
    TO              reduce using rule 70 (exp -> term exp_quadgen exp_aux .)


state 156

    (68) exp_aux -> exp_sign . exp
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    exp                            shift and go to state 180
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 157

    (69) exp_aux -> empty .
    NEQ             reduce using rule 69 (exp_aux -> empty .)
    EQ              reduce using rule 69 (exp_aux -> empty .)
    LTE             reduce using rule 69 (exp_aux -> empty .)
    GTE             reduce using rule 69 (exp_aux -> empty .)
    LT              reduce using rule 69 (exp_aux -> empty .)
    GT              reduce using rule 69 (exp_aux -> empty .)
    OR              reduce using rule 69 (exp_aux -> empty .)
    AND             reduce using rule 69 (exp_aux -> empty .)
    RETURN          reduce using rule 69 (exp_aux -> empty .)
    ID              reduce using rule 69 (exp_aux -> empty .)
    FROM            reduce using rule 69 (exp_aux -> empty .)
    DO              reduce using rule 69 (exp_aux -> empty .)
    WHILE           reduce using rule 69 (exp_aux -> empty .)
    INPUT           reduce using rule 69 (exp_aux -> empty .)
    PRINT           reduce using rule 69 (exp_aux -> empty .)
    IF              reduce using rule 69 (exp_aux -> empty .)
    RCURLY          reduce using rule 69 (exp_aux -> empty .)
    COMMA           reduce using rule 69 (exp_aux -> empty .)
    RPAREN          reduce using rule 69 (exp_aux -> empty .)
    SEMICOLON       reduce using rule 69 (exp_aux -> empty .)
    TO              reduce using rule 69 (exp_aux -> empty .)


state 158

    (71) exp_sign -> MINUS .
    LPAREN          reduce using rule 71 (exp_sign -> MINUS .)
    CTEBOOL         reduce using rule 71 (exp_sign -> MINUS .)
    CTEFLOAT        reduce using rule 71 (exp_sign -> MINUS .)
    CTEINT          reduce using rule 71 (exp_sign -> MINUS .)
    ID              reduce using rule 71 (exp_sign -> MINUS .)
    BOOL            reduce using rule 71 (exp_sign -> MINUS .)
    FLOAT           reduce using rule 71 (exp_sign -> MINUS .)
    INT             reduce using rule 71 (exp_sign -> MINUS .)
    ELSE            reduce using rule 71 (exp_sign -> MINUS .)
    IF              reduce using rule 71 (exp_sign -> MINUS .)
    PRINT           reduce using rule 71 (exp_sign -> MINUS .)
    INPUT           reduce using rule 71 (exp_sign -> MINUS .)
    WHILE           reduce using rule 71 (exp_sign -> MINUS .)
    DO              reduce using rule 71 (exp_sign -> MINUS .)
    BY              reduce using rule 71 (exp_sign -> MINUS .)
    TO              reduce using rule 71 (exp_sign -> MINUS .)
    FROM            reduce using rule 71 (exp_sign -> MINUS .)
    VOID            reduce using rule 71 (exp_sign -> MINUS .)
    RETURN          reduce using rule 71 (exp_sign -> MINUS .)
    FUNC            reduce using rule 71 (exp_sign -> MINUS .)
    MAIN            reduce using rule 71 (exp_sign -> MINUS .)
    VARS            reduce using rule 71 (exp_sign -> MINUS .)
    PROGRAM         reduce using rule 71 (exp_sign -> MINUS .)


state 159

    (72) exp_sign -> PLUS .
    LPAREN          reduce using rule 72 (exp_sign -> PLUS .)
    CTEBOOL         reduce using rule 72 (exp_sign -> PLUS .)
    CTEFLOAT        reduce using rule 72 (exp_sign -> PLUS .)
    CTEINT          reduce using rule 72 (exp_sign -> PLUS .)
    ID              reduce using rule 72 (exp_sign -> PLUS .)
    BOOL            reduce using rule 72 (exp_sign -> PLUS .)
    FLOAT           reduce using rule 72 (exp_sign -> PLUS .)
    INT             reduce using rule 72 (exp_sign -> PLUS .)
    ELSE            reduce using rule 72 (exp_sign -> PLUS .)
    IF              reduce using rule 72 (exp_sign -> PLUS .)
    PRINT           reduce using rule 72 (exp_sign -> PLUS .)
    INPUT           reduce using rule 72 (exp_sign -> PLUS .)
    WHILE           reduce using rule 72 (exp_sign -> PLUS .)
    DO              reduce using rule 72 (exp_sign -> PLUS .)
    BY              reduce using rule 72 (exp_sign -> PLUS .)
    TO              reduce using rule 72 (exp_sign -> PLUS .)
    FROM            reduce using rule 72 (exp_sign -> PLUS .)
    VOID            reduce using rule 72 (exp_sign -> PLUS .)
    RETURN          reduce using rule 72 (exp_sign -> PLUS .)
    FUNC            reduce using rule 72 (exp_sign -> PLUS .)
    MAIN            reduce using rule 72 (exp_sign -> PLUS .)
    VARS            reduce using rule 72 (exp_sign -> PLUS .)
    PROGRAM         reduce using rule 72 (exp_sign -> PLUS .)


state 160

    (76) term -> factor term_quadgen term_aux .
    MINUS           reduce using rule 76 (term -> factor term_quadgen term_aux .)
    PLUS            reduce using rule 76 (term -> factor term_quadgen term_aux .)
    NEQ             reduce using rule 76 (term -> factor term_quadgen term_aux .)
    EQ              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    LTE             reduce using rule 76 (term -> factor term_quadgen term_aux .)
    GTE             reduce using rule 76 (term -> factor term_quadgen term_aux .)
    LT              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    GT              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    OR              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    AND             reduce using rule 76 (term -> factor term_quadgen term_aux .)
    RETURN          reduce using rule 76 (term -> factor term_quadgen term_aux .)
    ID              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    FROM            reduce using rule 76 (term -> factor term_quadgen term_aux .)
    DO              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    WHILE           reduce using rule 76 (term -> factor term_quadgen term_aux .)
    INPUT           reduce using rule 76 (term -> factor term_quadgen term_aux .)
    PRINT           reduce using rule 76 (term -> factor term_quadgen term_aux .)
    IF              reduce using rule 76 (term -> factor term_quadgen term_aux .)
    RCURLY          reduce using rule 76 (term -> factor term_quadgen term_aux .)
    COMMA           reduce using rule 76 (term -> factor term_quadgen term_aux .)
    RPAREN          reduce using rule 76 (term -> factor term_quadgen term_aux .)
    SEMICOLON       reduce using rule 76 (term -> factor term_quadgen term_aux .)
    TO              reduce using rule 76 (term -> factor term_quadgen term_aux .)


state 161

    (74) term_aux -> term_sign . term
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    term                           shift and go to state 181
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 162

    (75) term_aux -> empty .
    MINUS           reduce using rule 75 (term_aux -> empty .)
    PLUS            reduce using rule 75 (term_aux -> empty .)
    NEQ             reduce using rule 75 (term_aux -> empty .)
    EQ              reduce using rule 75 (term_aux -> empty .)
    LTE             reduce using rule 75 (term_aux -> empty .)
    GTE             reduce using rule 75 (term_aux -> empty .)
    LT              reduce using rule 75 (term_aux -> empty .)
    GT              reduce using rule 75 (term_aux -> empty .)
    OR              reduce using rule 75 (term_aux -> empty .)
    AND             reduce using rule 75 (term_aux -> empty .)
    RETURN          reduce using rule 75 (term_aux -> empty .)
    ID              reduce using rule 75 (term_aux -> empty .)
    FROM            reduce using rule 75 (term_aux -> empty .)
    DO              reduce using rule 75 (term_aux -> empty .)
    WHILE           reduce using rule 75 (term_aux -> empty .)
    INPUT           reduce using rule 75 (term_aux -> empty .)
    PRINT           reduce using rule 75 (term_aux -> empty .)
    IF              reduce using rule 75 (term_aux -> empty .)
    RCURLY          reduce using rule 75 (term_aux -> empty .)
    COMMA           reduce using rule 75 (term_aux -> empty .)
    RPAREN          reduce using rule 75 (term_aux -> empty .)
    SEMICOLON       reduce using rule 75 (term_aux -> empty .)
    TO              reduce using rule 75 (term_aux -> empty .)


state 163

    (77) term_sign -> DIVIDE .
    LPAREN          reduce using rule 77 (term_sign -> DIVIDE .)
    CTEBOOL         reduce using rule 77 (term_sign -> DIVIDE .)
    CTEFLOAT        reduce using rule 77 (term_sign -> DIVIDE .)
    CTEINT          reduce using rule 77 (term_sign -> DIVIDE .)
    ID              reduce using rule 77 (term_sign -> DIVIDE .)
    BOOL            reduce using rule 77 (term_sign -> DIVIDE .)
    FLOAT           reduce using rule 77 (term_sign -> DIVIDE .)
    INT             reduce using rule 77 (term_sign -> DIVIDE .)
    ELSE            reduce using rule 77 (term_sign -> DIVIDE .)
    IF              reduce using rule 77 (term_sign -> DIVIDE .)
    PRINT           reduce using rule 77 (term_sign -> DIVIDE .)
    INPUT           reduce using rule 77 (term_sign -> DIVIDE .)
    WHILE           reduce using rule 77 (term_sign -> DIVIDE .)
    DO              reduce using rule 77 (term_sign -> DIVIDE .)
    BY              reduce using rule 77 (term_sign -> DIVIDE .)
    TO              reduce using rule 77 (term_sign -> DIVIDE .)
    FROM            reduce using rule 77 (term_sign -> DIVIDE .)
    VOID            reduce using rule 77 (term_sign -> DIVIDE .)
    RETURN          reduce using rule 77 (term_sign -> DIVIDE .)
    FUNC            reduce using rule 77 (term_sign -> DIVIDE .)
    MAIN            reduce using rule 77 (term_sign -> DIVIDE .)
    VARS            reduce using rule 77 (term_sign -> DIVIDE .)
    PROGRAM         reduce using rule 77 (term_sign -> DIVIDE .)


state 164

    (78) term_sign -> TIMES .
    LPAREN          reduce using rule 78 (term_sign -> TIMES .)
    CTEBOOL         reduce using rule 78 (term_sign -> TIMES .)
    CTEFLOAT        reduce using rule 78 (term_sign -> TIMES .)
    CTEINT          reduce using rule 78 (term_sign -> TIMES .)
    ID              reduce using rule 78 (term_sign -> TIMES .)
    BOOL            reduce using rule 78 (term_sign -> TIMES .)
    FLOAT           reduce using rule 78 (term_sign -> TIMES .)
    INT             reduce using rule 78 (term_sign -> TIMES .)
    ELSE            reduce using rule 78 (term_sign -> TIMES .)
    IF              reduce using rule 78 (term_sign -> TIMES .)
    PRINT           reduce using rule 78 (term_sign -> TIMES .)
    INPUT           reduce using rule 78 (term_sign -> TIMES .)
    WHILE           reduce using rule 78 (term_sign -> TIMES .)
    DO              reduce using rule 78 (term_sign -> TIMES .)
    BY              reduce using rule 78 (term_sign -> TIMES .)
    TO              reduce using rule 78 (term_sign -> TIMES .)
    FROM            reduce using rule 78 (term_sign -> TIMES .)
    VOID            reduce using rule 78 (term_sign -> TIMES .)
    RETURN          reduce using rule 78 (term_sign -> TIMES .)
    FUNC            reduce using rule 78 (term_sign -> TIMES .)
    MAIN            reduce using rule 78 (term_sign -> TIMES .)
    VARS            reduce using rule 78 (term_sign -> TIMES .)
    PROGRAM         reduce using rule 78 (term_sign -> TIMES .)


state 165

    (80) factor -> LPAREN fakefloor super_exp . RPAREN
    RPAREN          shift and go to state 182


state 166

    (46) call -> ID generate_era LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 183


state 167

    (50) callvalues -> exp . generate_param callvalues_aux
    (51) generate_param -> .
    COMMA           reduce using rule 51 (generate_param -> .)
    RPAREN          reduce using rule 51 (generate_param -> .)

    generate_param                 shift and go to state 184

state 168

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression . validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (87) validatecontrolvar -> .
    TO              reduce using rule 87 (validatecontrolvar -> .)

    validatecontrolvar             shift and go to state 185

state 169

    (91) dowhileloop -> DO saveposition block WHILE . LPAREN expression RPAREN openjumpslot
    LPAREN          shift and go to state 186


state 170

    (4) block -> LCURLY blockcontent . RCURLY
    RCURLY          shift and go to state 187


state 171

    (90) whileloop -> WHILE saveposition LPAREN expression . RPAREN openjumpslot block filljumps
    RPAREN          shift and go to state 188


state 172

    (95) read -> INPUT LPAREN readaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 189


state 173

    (96) readaux -> readvalue COMMA . readaux
    (96) readaux -> . readvalue COMMA readaux
    (97) readaux -> . readvalue
    (98) readvalue -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    readvalue                      shift and go to state 133
    readaux                        shift and go to state 190
    var                            shift and go to state 134

state 174

    (99) write -> PRINT LPAREN writeaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 191


state 175

    (101) writeaux -> writevalues COMMA . writeaux
    (100) writeaux -> . writevalues
    (101) writeaux -> . writevalues COMMA writeaux
    (102) writevalues -> . CTESTRING
    (103) writevalues -> . super_exp
    (54) super_exp -> . expression super_exp_quadgen super_exp_aux
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    CTESTRING       shift and go to state 137
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    writevalues                    shift and go to state 136
    writeaux                       shift and go to state 192
    super_exp                      shift and go to state 138
    expression                     shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 176

    (104) condition -> IF LPAREN super_exp RPAREN . openjumpslot block filljumps
    (105) condition -> IF LPAREN super_exp RPAREN . openjumpslot block ELSE filljumps openjumpslot block filljumps
    (106) openjumpslot -> .
    LCURLY          reduce using rule 106 (openjumpslot -> .)

    openjumpslot                   shift and go to state 193

state 177

    (92) assignment -> assignment_var assignment_sign expression SEMICOLON .
    RETURN          reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    ID              reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    FROM            reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    DO              reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    WHILE           reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    INPUT           reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    PRINT           reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    IF              reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)
    RCURLY          reduce using rule 92 (assignment -> assignment_var assignment_sign expression SEMICOLON .)


state 178

    (52) super_exp_aux -> logic super_exp .
    RETURN          reduce using rule 52 (super_exp_aux -> logic super_exp .)
    ID              reduce using rule 52 (super_exp_aux -> logic super_exp .)
    FROM            reduce using rule 52 (super_exp_aux -> logic super_exp .)
    DO              reduce using rule 52 (super_exp_aux -> logic super_exp .)
    WHILE           reduce using rule 52 (super_exp_aux -> logic super_exp .)
    INPUT           reduce using rule 52 (super_exp_aux -> logic super_exp .)
    PRINT           reduce using rule 52 (super_exp_aux -> logic super_exp .)
    IF              reduce using rule 52 (super_exp_aux -> logic super_exp .)
    RCURLY          reduce using rule 52 (super_exp_aux -> logic super_exp .)
    COMMA           reduce using rule 52 (super_exp_aux -> logic super_exp .)
    RPAREN          reduce using rule 52 (super_exp_aux -> logic super_exp .)


state 179

    (58) expression_aux -> relation expression .
    OR              reduce using rule 58 (expression_aux -> relation expression .)
    AND             reduce using rule 58 (expression_aux -> relation expression .)
    RETURN          reduce using rule 58 (expression_aux -> relation expression .)
    ID              reduce using rule 58 (expression_aux -> relation expression .)
    FROM            reduce using rule 58 (expression_aux -> relation expression .)
    DO              reduce using rule 58 (expression_aux -> relation expression .)
    WHILE           reduce using rule 58 (expression_aux -> relation expression .)
    INPUT           reduce using rule 58 (expression_aux -> relation expression .)
    PRINT           reduce using rule 58 (expression_aux -> relation expression .)
    IF              reduce using rule 58 (expression_aux -> relation expression .)
    RCURLY          reduce using rule 58 (expression_aux -> relation expression .)
    COMMA           reduce using rule 58 (expression_aux -> relation expression .)
    RPAREN          reduce using rule 58 (expression_aux -> relation expression .)
    SEMICOLON       reduce using rule 58 (expression_aux -> relation expression .)
    TO              reduce using rule 58 (expression_aux -> relation expression .)


state 180

    (68) exp_aux -> exp_sign exp .
    NEQ             reduce using rule 68 (exp_aux -> exp_sign exp .)
    EQ              reduce using rule 68 (exp_aux -> exp_sign exp .)
    LTE             reduce using rule 68 (exp_aux -> exp_sign exp .)
    GTE             reduce using rule 68 (exp_aux -> exp_sign exp .)
    LT              reduce using rule 68 (exp_aux -> exp_sign exp .)
    GT              reduce using rule 68 (exp_aux -> exp_sign exp .)
    OR              reduce using rule 68 (exp_aux -> exp_sign exp .)
    AND             reduce using rule 68 (exp_aux -> exp_sign exp .)
    RETURN          reduce using rule 68 (exp_aux -> exp_sign exp .)
    ID              reduce using rule 68 (exp_aux -> exp_sign exp .)
    FROM            reduce using rule 68 (exp_aux -> exp_sign exp .)
    DO              reduce using rule 68 (exp_aux -> exp_sign exp .)
    WHILE           reduce using rule 68 (exp_aux -> exp_sign exp .)
    INPUT           reduce using rule 68 (exp_aux -> exp_sign exp .)
    PRINT           reduce using rule 68 (exp_aux -> exp_sign exp .)
    IF              reduce using rule 68 (exp_aux -> exp_sign exp .)
    RCURLY          reduce using rule 68 (exp_aux -> exp_sign exp .)
    COMMA           reduce using rule 68 (exp_aux -> exp_sign exp .)
    RPAREN          reduce using rule 68 (exp_aux -> exp_sign exp .)
    SEMICOLON       reduce using rule 68 (exp_aux -> exp_sign exp .)
    TO              reduce using rule 68 (exp_aux -> exp_sign exp .)


state 181

    (74) term_aux -> term_sign term .
    MINUS           reduce using rule 74 (term_aux -> term_sign term .)
    PLUS            reduce using rule 74 (term_aux -> term_sign term .)
    NEQ             reduce using rule 74 (term_aux -> term_sign term .)
    EQ              reduce using rule 74 (term_aux -> term_sign term .)
    LTE             reduce using rule 74 (term_aux -> term_sign term .)
    GTE             reduce using rule 74 (term_aux -> term_sign term .)
    LT              reduce using rule 74 (term_aux -> term_sign term .)
    GT              reduce using rule 74 (term_aux -> term_sign term .)
    OR              reduce using rule 74 (term_aux -> term_sign term .)
    AND             reduce using rule 74 (term_aux -> term_sign term .)
    RETURN          reduce using rule 74 (term_aux -> term_sign term .)
    ID              reduce using rule 74 (term_aux -> term_sign term .)
    FROM            reduce using rule 74 (term_aux -> term_sign term .)
    DO              reduce using rule 74 (term_aux -> term_sign term .)
    WHILE           reduce using rule 74 (term_aux -> term_sign term .)
    INPUT           reduce using rule 74 (term_aux -> term_sign term .)
    PRINT           reduce using rule 74 (term_aux -> term_sign term .)
    IF              reduce using rule 74 (term_aux -> term_sign term .)
    RCURLY          reduce using rule 74 (term_aux -> term_sign term .)
    COMMA           reduce using rule 74 (term_aux -> term_sign term .)
    RPAREN          reduce using rule 74 (term_aux -> term_sign term .)
    SEMICOLON       reduce using rule 74 (term_aux -> term_sign term .)
    TO              reduce using rule 74 (term_aux -> term_sign term .)


state 182

    (80) factor -> LPAREN fakefloor super_exp RPAREN .
    DIVIDE          reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TIMES           reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    MINUS           reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PLUS            reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    NEQ             reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    EQ              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LTE             reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GTE             reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LT              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GT              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    OR              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    AND             reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RETURN          reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    ID              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    FROM            reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    DO              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    WHILE           reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    INPUT           reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PRINT           reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    IF              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RCURLY          reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    COMMA           reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RPAREN          reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    SEMICOLON       reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TO              reduce using rule 80 (factor -> LPAREN fakefloor super_exp RPAREN .)


state 183

    (46) call -> ID generate_era LPAREN callvalues RPAREN .
    RETURN          reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    ID              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    FROM            reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    DO              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    IF              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    DIVIDE          reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    EQ              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    LTE             reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    GTE             reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    LT              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    GT              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    OR              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    AND             reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)
    TO              reduce using rule 46 (call -> ID generate_era LPAREN callvalues RPAREN .)


state 184

    (50) callvalues -> exp generate_param . callvalues_aux
    (48) callvalues_aux -> . COMMA callvalues
    (49) callvalues_aux -> . empty
    (127) empty -> .
    COMMA           shift and go to state 195
    RPAREN          reduce using rule 127 (empty -> .)

    callvalues_aux                 shift and go to state 194
    empty                          shift and go to state 196

state 185

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar . TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    TO              shift and go to state 197


state 186

    (91) dowhileloop -> DO saveposition block WHILE LPAREN . expression RPAREN openjumpslot
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 198
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 187

    (4) block -> LCURLY blockcontent RCURLY .
    WHILE           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ELSE            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RETURN          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ID              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    FROM            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    DO              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    INPUT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    PRINT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    IF              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RCURLY          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)


state 188

    (90) whileloop -> WHILE saveposition LPAREN expression RPAREN . openjumpslot block filljumps
    (106) openjumpslot -> .
    LCURLY          reduce using rule 106 (openjumpslot -> .)

    openjumpslot                   shift and go to state 199

state 189

    (95) read -> INPUT LPAREN readaux RPAREN SEMICOLON .
    RETURN          reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    ID              reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    FROM            reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    DO              reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    IF              reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 95 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)


state 190

    (96) readaux -> readvalue COMMA readaux .
    RPAREN          reduce using rule 96 (readaux -> readvalue COMMA readaux .)


state 191

    (99) write -> PRINT LPAREN writeaux RPAREN SEMICOLON .
    RETURN          reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    ID              reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    FROM            reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    DO              reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    IF              reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 99 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)


state 192

    (101) writeaux -> writevalues COMMA writeaux .
    RPAREN          reduce using rule 101 (writeaux -> writevalues COMMA writeaux .)


state 193

    (104) condition -> IF LPAREN super_exp RPAREN openjumpslot . block filljumps
    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot . block ELSE filljumps openjumpslot block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 130

    block                          shift and go to state 200

state 194

    (50) callvalues -> exp generate_param callvalues_aux .
    RPAREN          reduce using rule 50 (callvalues -> exp generate_param callvalues_aux .)


state 195

    (48) callvalues_aux -> COMMA . callvalues
    (50) callvalues -> . exp generate_param callvalues_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    callvalues                     shift and go to state 201
    exp                            shift and go to state 167
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 196

    (49) callvalues_aux -> empty .
    RPAREN          reduce using rule 49 (callvalues_aux -> empty .)


state 197

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO . createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (88) createfinaltempvar -> .
    LPAREN          reduce using rule 88 (createfinaltempvar -> .)
    CTEBOOL         reduce using rule 88 (createfinaltempvar -> .)
    CTEFLOAT        reduce using rule 88 (createfinaltempvar -> .)
    CTEINT          reduce using rule 88 (createfinaltempvar -> .)
    ID              reduce using rule 88 (createfinaltempvar -> .)
    BOOL            reduce using rule 88 (createfinaltempvar -> .)
    FLOAT           reduce using rule 88 (createfinaltempvar -> .)
    INT             reduce using rule 88 (createfinaltempvar -> .)
    ELSE            reduce using rule 88 (createfinaltempvar -> .)
    IF              reduce using rule 88 (createfinaltempvar -> .)
    PRINT           reduce using rule 88 (createfinaltempvar -> .)
    INPUT           reduce using rule 88 (createfinaltempvar -> .)
    WHILE           reduce using rule 88 (createfinaltempvar -> .)
    DO              reduce using rule 88 (createfinaltempvar -> .)
    BY              reduce using rule 88 (createfinaltempvar -> .)
    TO              reduce using rule 88 (createfinaltempvar -> .)
    FROM            reduce using rule 88 (createfinaltempvar -> .)
    VOID            reduce using rule 88 (createfinaltempvar -> .)
    RETURN          reduce using rule 88 (createfinaltempvar -> .)
    FUNC            reduce using rule 88 (createfinaltempvar -> .)
    MAIN            reduce using rule 88 (createfinaltempvar -> .)
    VARS            reduce using rule 88 (createfinaltempvar -> .)
    PROGRAM         reduce using rule 88 (createfinaltempvar -> .)

    createfinaltempvar             shift and go to state 202

state 198

    (91) dowhileloop -> DO saveposition block WHILE LPAREN expression . RPAREN openjumpslot
    RPAREN          shift and go to state 203


state 199

    (90) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 130

    block                          shift and go to state 204

state 200

    (104) condition -> IF LPAREN super_exp RPAREN openjumpslot block . filljumps
    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot block . ELSE filljumps openjumpslot block filljumps
    (108) filljumps -> .
    ELSE            shift and go to state 206
    RETURN          reduce using rule 108 (filljumps -> .)
    ID              reduce using rule 108 (filljumps -> .)
    FROM            reduce using rule 108 (filljumps -> .)
    DO              reduce using rule 108 (filljumps -> .)
    WHILE           reduce using rule 108 (filljumps -> .)
    INPUT           reduce using rule 108 (filljumps -> .)
    PRINT           reduce using rule 108 (filljumps -> .)
    IF              reduce using rule 108 (filljumps -> .)
    RCURLY          reduce using rule 108 (filljumps -> .)

    filljumps                      shift and go to state 205

state 201

    (48) callvalues_aux -> COMMA callvalues .
    RPAREN          reduce using rule 48 (callvalues_aux -> COMMA callvalues .)


state 202

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar . expression validateloopend DO openjumpslot block filljumps
    (60) expression -> . exp expression_quadgen expression_aux
    (70) exp -> . term exp_quadgen exp_aux
    (76) term -> . factor term_quadgen term_aux
    (80) factor -> . LPAREN fakefloor super_exp RPAREN
    (81) factor -> . varcte
    (82) factor -> . call
    (83) factor -> . var
    (109) varcte -> . CTEBOOL
    (110) varcte -> . CTEFLOAT
    (111) varcte -> . CTEINT
    (46) call -> . ID generate_era LPAREN callvalues RPAREN
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID LBRACKET CTEINT RBRACKET LBRACKET CTEINT RBRACKET
    (34) var -> . ID LBRACKET CTEINT RBRACKET
    (35) var -> . ID
    LPAREN          shift and go to state 104
    CTEBOOL         shift and go to state 108
    CTEFLOAT        shift and go to state 109
    CTEINT          shift and go to state 110
    ID              shift and go to state 111
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44

    expression                     shift and go to state 207
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    varcte                         shift and go to state 105
    call                           shift and go to state 106
    var                            shift and go to state 107

state 203

    (91) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN . openjumpslot
    (106) openjumpslot -> .
    RETURN          reduce using rule 106 (openjumpslot -> .)
    ID              reduce using rule 106 (openjumpslot -> .)
    FROM            reduce using rule 106 (openjumpslot -> .)
    DO              reduce using rule 106 (openjumpslot -> .)
    WHILE           reduce using rule 106 (openjumpslot -> .)
    INPUT           reduce using rule 106 (openjumpslot -> .)
    PRINT           reduce using rule 106 (openjumpslot -> .)
    IF              reduce using rule 106 (openjumpslot -> .)
    RCURLY          reduce using rule 106 (openjumpslot -> .)

    openjumpslot                   shift and go to state 208

state 204

    (90) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block . filljumps
    (108) filljumps -> .
    RETURN          reduce using rule 108 (filljumps -> .)
    ID              reduce using rule 108 (filljumps -> .)
    FROM            reduce using rule 108 (filljumps -> .)
    DO              reduce using rule 108 (filljumps -> .)
    WHILE           reduce using rule 108 (filljumps -> .)
    INPUT           reduce using rule 108 (filljumps -> .)
    PRINT           reduce using rule 108 (filljumps -> .)
    IF              reduce using rule 108 (filljumps -> .)
    RCURLY          reduce using rule 108 (filljumps -> .)

    filljumps                      shift and go to state 209

state 205

    (104) condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .
    RETURN          reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    ID              reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 104 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)


state 206

    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE . filljumps openjumpslot block filljumps
    (108) filljumps -> .
    LCURLY          reduce using rule 108 (filljumps -> .)

    filljumps                      shift and go to state 210

state 207

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression . validateloopend DO openjumpslot block filljumps
    (89) validateloopend -> .
    DO              reduce using rule 89 (validateloopend -> .)

    validateloopend                shift and go to state 211

state 208

    (91) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .
    RETURN          reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    ID              reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    FROM            reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    DO              reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    WHILE           reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    INPUT           reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    PRINT           reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    IF              reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    RCURLY          reduce using rule 91 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)


state 209

    (90) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .
    RETURN          reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    ID              reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 90 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)


state 210

    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps . openjumpslot block filljumps
    (106) openjumpslot -> .
    LCURLY          reduce using rule 106 (openjumpslot -> .)

    openjumpslot                   shift and go to state 212

state 211

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend . DO openjumpslot block filljumps
    DO              shift and go to state 213


state 212

    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 130

    block                          shift and go to state 214

state 213

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO . openjumpslot block filljumps
    (106) openjumpslot -> .
    LCURLY          reduce using rule 106 (openjumpslot -> .)

    openjumpslot                   shift and go to state 215

state 214

    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block . filljumps
    (108) filljumps -> .
    RETURN          reduce using rule 108 (filljumps -> .)
    ID              reduce using rule 108 (filljumps -> .)
    FROM            reduce using rule 108 (filljumps -> .)
    DO              reduce using rule 108 (filljumps -> .)
    WHILE           reduce using rule 108 (filljumps -> .)
    INPUT           reduce using rule 108 (filljumps -> .)
    PRINT           reduce using rule 108 (filljumps -> .)
    IF              reduce using rule 108 (filljumps -> .)
    RCURLY          reduce using rule 108 (filljumps -> .)

    filljumps                      shift and go to state 216

state 215

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 130

    block                          shift and go to state 217

state 216

    (105) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .
    RETURN          reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    ID              reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    FROM            reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    DO              reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    WHILE           reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    INPUT           reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    PRINT           reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    IF              reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    RCURLY          reduce using rule 105 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)


state 217

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block . filljumps
    (108) filljumps -> .
    RETURN          reduce using rule 108 (filljumps -> .)
    ID              reduce using rule 108 (filljumps -> .)
    FROM            reduce using rule 108 (filljumps -> .)
    DO              reduce using rule 108 (filljumps -> .)
    WHILE           reduce using rule 108 (filljumps -> .)
    INPUT           reduce using rule 108 (filljumps -> .)
    PRINT           reduce using rule 108 (filljumps -> .)
    IF              reduce using rule 108 (filljumps -> .)
    RCURLY          reduce using rule 108 (filljumps -> .)

    filljumps                      shift and go to state 218

state 218

    (85) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .
    RETURN          reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    ID              reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    FROM            reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    DO              reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    WHILE           reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    INPUT           reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    PRINT           reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    IF              reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    RCURLY          reduce using rule 85 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
