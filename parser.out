Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     saveprogramname -> <empty>
Rule 3     declare -> main_block
Rule 4     declare -> decfuncs main_block
Rule 5     declare -> decvars saveglobalvars main_block
Rule 6     declare -> decvars saveglobalvars decfuncs main_block
Rule 7     main_block -> MAIN changecontext LPAREN RPAREN block
Rule 8     block -> LCURLY blockcontent RCURLY
Rule 9     returnblock -> LCURLY blockcontent RETURN exp SEMICOLON RCURLY
Rule 10    blockcontent -> empty
Rule 11    blockcontent -> statute blockcontent
Rule 12    decvars -> VARS decvar_line
Rule 13    decvar_line -> type decvar SEMICOLON decvar_line
Rule 14    decvar_line -> type decvar SEMICOLON
Rule 15    decvar -> var COMMA decvar
Rule 16    decvar -> var
Rule 17    var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 18    var -> ID LBRACKET exp RBRACKET
Rule 19    var -> ID
Rule 20    decfuncs -> func
Rule 21    decfuncs -> func decfuncs
Rule 22    func -> FUNC typefunc
Rule 23    func -> FUNC voidfunc
Rule 24    voidfunc -> VOID ID changecontext LPAREN params RPAREN block
Rule 25    typefunc -> type ID changecontext LPAREN params RPAREN returnblock
Rule 26    params -> empty
Rule 27    params -> type ID COMMA params
Rule 28    params -> type ID
Rule 29    call -> ID LPAREN callvalues RPAREN
Rule 30    callvalues -> empty
Rule 31    callvalues -> exp COMMA callvalues
Rule 32    callvalues -> exp
Rule 33    super_exp -> expression OR super_exp
Rule 34    super_exp -> expression AND super_exp
Rule 35    super_exp -> expression
Rule 36    expression -> exp relation exp
Rule 37    expression -> exp
Rule 38    relation -> NEQ
Rule 39    relation -> EQ
Rule 40    relation -> LTE
Rule 41    relation -> GTE
Rule 42    relation -> LT
Rule 43    relation -> GT
Rule 44    exp -> term MINUS exp
Rule 45    exp -> term PLUS exp
Rule 46    exp -> term
Rule 47    term -> factor DIVIDE term
Rule 48    term -> factor TIMES term
Rule 49    term -> factor
Rule 50    factor -> LPAREN super_exp RPAREN
Rule 51    factor -> varcte
Rule 52    factor -> call
Rule 53    factor -> var
Rule 54    forloop -> FROM var ASSIGN expression TO expression BY expression DO block
Rule 55    forloop -> FROM var ASSIGN expression TO expression DO block
Rule 56    whileloop -> WHILE LPAREN expression RPAREN block
Rule 57    assignment -> ID ASSIGN expression SEMICOLON
Rule 58    read -> INPUT LPAREN decvar RPAREN SEMICOLON
Rule 59    write -> PRINT LPAREN writevalues RPAREN SEMICOLON
Rule 60    writevalues -> CTESTRING COMMA writevalues
Rule 61    writevalues -> super_exp COMMA writevalues
Rule 62    writevalues -> CTESTRING
Rule 63    writevalues -> super_exp
Rule 64    condition -> IF LPAREN expression RPAREN block ELSE block
Rule 65    condition -> IF LPAREN expression RPAREN block
Rule 66    varcte -> CTEFLOAT
Rule 67    varcte -> CTEINT
Rule 68    type -> FLOAT
Rule 69    type -> INT
Rule 70    statute -> call
Rule 71    statute -> decvars
Rule 72    statute -> forloop
Rule 73    statute -> whileloop
Rule 74    statute -> read
Rule 75    statute -> write
Rule 76    statute -> condition
Rule 77    statute -> assignment
Rule 78    changecontext -> <empty>
Rule 79    saveglobalvars -> <empty>
Rule 80    empty -> <empty>

Terminals, with rules where they appear:

AND                  : 34
ASSIGN               : 54 55 57
BY                   : 54
COMMA                : 15 27 31 60 61
CTEFLOAT             : 66
CTEINT               : 67
CTESTRING            : 60 62
DIVIDE               : 47
DO                   : 54 55
ELSE                 : 64
EQ                   : 39
FLOAT                : 68
FROM                 : 54 55
FUNC                 : 22 23
GT                   : 43
GTE                  : 41
ID                   : 1 17 18 19 24 25 27 28 29 57
IF                   : 64 65
INPUT                : 58
INT                  : 69
LBRACKET             : 17 17 18
LCURLY               : 8 9
LPAREN               : 7 24 25 29 50 56 58 59 64 65
LT                   : 42
LTE                  : 40
MAIN                 : 7
MINUS                : 44
NEQ                  : 38
OR                   : 33
PLUS                 : 45
PRINT                : 59
PROGRAM              : 1
RBRACKET             : 17 17 18
RCURLY               : 8 9
RETURN               : 9
RPAREN               : 7 24 25 29 50 56 58 59 64 65
SEMICOLON            : 9 13 14 57 58 59
TIMES                : 48
TO                   : 54 55
VARS                 : 12
VOID                 : 24
WHILE                : 56
error                : 

Nonterminals, with rules where they appear:

assignment           : 77
block                : 7 24 54 55 56 64 64 65
blockcontent         : 8 9 11
call                 : 52 70
callvalues           : 29 31
changecontext        : 7 24 25
condition            : 76
decfuncs             : 4 6 21
declare              : 1
decvar               : 13 14 15 58
decvar_line          : 12 13
decvars              : 5 6 71
empty                : 10 26 30
exp                  : 9 17 17 18 31 32 36 36 37 44 45
expression           : 33 34 35 54 54 54 55 55 56 57 64 65
factor               : 47 48 49
forloop              : 72
func                 : 20 21
main_block           : 3 4 5 6
params               : 24 25 27
program              : 0
read                 : 74
relation             : 36
returnblock          : 25
saveglobalvars       : 5 6
saveprogramname      : 1
statute              : 11
super_exp            : 33 34 50 61 63
term                 : 44 45 46 47 48
type                 : 13 14 25 27 28
typefunc             : 22
var                  : 15 16 53 54 55
varcte               : 51
voidfunc             : 23
whileloop            : 73
write                : 75
writevalues          : 59 60 61


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (2) saveprogramname -> .
    MAIN            reduce using rule 2 (saveprogramname -> .)
    VARS            reduce using rule 2 (saveprogramname -> .)
    FUNC            reduce using rule 2 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (3) declare -> . main_block
    (4) declare -> . decfuncs main_block
    (5) declare -> . decvars saveglobalvars main_block
    (6) declare -> . decvars saveglobalvars decfuncs main_block
    (7) main_block -> . MAIN changecontext LPAREN RPAREN block
    (20) decfuncs -> . func
    (21) decfuncs -> . func decfuncs
    (12) decvars -> . VARS decvar_line
    (22) func -> . FUNC typefunc
    (23) func -> . FUNC voidfunc
    MAIN            shift and go to state 9
    VARS            shift and go to state 11
    FUNC            shift and go to state 12

    declare                        shift and go to state 5
    main_block                     shift and go to state 6
    decfuncs                       shift and go to state 7
    decvars                        shift and go to state 8
    func                           shift and go to state 10

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (3) declare -> main_block .
    $end            reduce using rule 3 (declare -> main_block .)


state 7

    (4) declare -> decfuncs . main_block
    (7) main_block -> . MAIN changecontext LPAREN RPAREN block
    MAIN            shift and go to state 9

    main_block                     shift and go to state 13

state 8

    (5) declare -> decvars . saveglobalvars main_block
    (6) declare -> decvars . saveglobalvars decfuncs main_block
    (79) saveglobalvars -> .
    MAIN            reduce using rule 79 (saveglobalvars -> .)
    FUNC            reduce using rule 79 (saveglobalvars -> .)

    saveglobalvars                 shift and go to state 14

state 9

    (7) main_block -> MAIN . changecontext LPAREN RPAREN block
    (78) changecontext -> .
    LPAREN          reduce using rule 78 (changecontext -> .)

    changecontext                  shift and go to state 15

state 10

    (20) decfuncs -> func .
    (21) decfuncs -> func . decfuncs
    (20) decfuncs -> . func
    (21) decfuncs -> . func decfuncs
    (22) func -> . FUNC typefunc
    (23) func -> . FUNC voidfunc
    MAIN            reduce using rule 20 (decfuncs -> func .)
    FUNC            shift and go to state 12

    func                           shift and go to state 10
    decfuncs                       shift and go to state 16

state 11

    (12) decvars -> VARS . decvar_line
    (13) decvar_line -> . type decvar SEMICOLON decvar_line
    (14) decvar_line -> . type decvar SEMICOLON
    (68) type -> . FLOAT
    (69) type -> . INT
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    decvar_line                    shift and go to state 17
    type                           shift and go to state 18

state 12

    (22) func -> FUNC . typefunc
    (23) func -> FUNC . voidfunc
    (25) typefunc -> . type ID changecontext LPAREN params RPAREN returnblock
    (24) voidfunc -> . VOID ID changecontext LPAREN params RPAREN block
    (68) type -> . FLOAT
    (69) type -> . INT
    VOID            shift and go to state 24
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    typefunc                       shift and go to state 21
    voidfunc                       shift and go to state 22
    type                           shift and go to state 23

state 13

    (4) declare -> decfuncs main_block .
    $end            reduce using rule 4 (declare -> decfuncs main_block .)


state 14

    (5) declare -> decvars saveglobalvars . main_block
    (6) declare -> decvars saveglobalvars . decfuncs main_block
    (7) main_block -> . MAIN changecontext LPAREN RPAREN block
    (20) decfuncs -> . func
    (21) decfuncs -> . func decfuncs
    (22) func -> . FUNC typefunc
    (23) func -> . FUNC voidfunc
    MAIN            shift and go to state 9
    FUNC            shift and go to state 12

    main_block                     shift and go to state 25
    decfuncs                       shift and go to state 26
    func                           shift and go to state 10

state 15

    (7) main_block -> MAIN changecontext . LPAREN RPAREN block
    LPAREN          shift and go to state 27


state 16

    (21) decfuncs -> func decfuncs .
    MAIN            reduce using rule 21 (decfuncs -> func decfuncs .)


state 17

    (12) decvars -> VARS decvar_line .
    MAIN            reduce using rule 12 (decvars -> VARS decvar_line .)
    FUNC            reduce using rule 12 (decvars -> VARS decvar_line .)
    ID              reduce using rule 12 (decvars -> VARS decvar_line .)
    VARS            reduce using rule 12 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 12 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 12 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 12 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 12 (decvars -> VARS decvar_line .)
    IF              reduce using rule 12 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 12 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 12 (decvars -> VARS decvar_line .)


state 18

    (13) decvar_line -> type . decvar SEMICOLON decvar_line
    (14) decvar_line -> type . decvar SEMICOLON
    (15) decvar -> . var COMMA decvar
    (16) decvar -> . var
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    ID              shift and go to state 30

    decvar                         shift and go to state 28
    var                            shift and go to state 29

state 19

    (68) type -> FLOAT .
    ID              reduce using rule 68 (type -> FLOAT .)


state 20

    (69) type -> INT .
    ID              reduce using rule 69 (type -> INT .)


state 21

    (22) func -> FUNC typefunc .
    FUNC            reduce using rule 22 (func -> FUNC typefunc .)
    MAIN            reduce using rule 22 (func -> FUNC typefunc .)


state 22

    (23) func -> FUNC voidfunc .
    FUNC            reduce using rule 23 (func -> FUNC voidfunc .)
    MAIN            reduce using rule 23 (func -> FUNC voidfunc .)


state 23

    (25) typefunc -> type . ID changecontext LPAREN params RPAREN returnblock
    ID              shift and go to state 31


state 24

    (24) voidfunc -> VOID . ID changecontext LPAREN params RPAREN block
    ID              shift and go to state 32


state 25

    (5) declare -> decvars saveglobalvars main_block .
    $end            reduce using rule 5 (declare -> decvars saveglobalvars main_block .)


state 26

    (6) declare -> decvars saveglobalvars decfuncs . main_block
    (7) main_block -> . MAIN changecontext LPAREN RPAREN block
    MAIN            shift and go to state 9

    main_block                     shift and go to state 33

state 27

    (7) main_block -> MAIN changecontext LPAREN . RPAREN block
    RPAREN          shift and go to state 34


state 28

    (13) decvar_line -> type decvar . SEMICOLON decvar_line
    (14) decvar_line -> type decvar . SEMICOLON
    SEMICOLON       shift and go to state 35


state 29

    (15) decvar -> var . COMMA decvar
    (16) decvar -> var .
    COMMA           shift and go to state 36
    SEMICOLON       reduce using rule 16 (decvar -> var .)
    RPAREN          reduce using rule 16 (decvar -> var .)


state 30

    (17) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> ID . LBRACKET exp RBRACKET
    (19) var -> ID .
    LBRACKET        shift and go to state 37
    COMMA           reduce using rule 19 (var -> ID .)
    SEMICOLON       reduce using rule 19 (var -> ID .)
    RPAREN          reduce using rule 19 (var -> ID .)
    ASSIGN          reduce using rule 19 (var -> ID .)


state 31

    (25) typefunc -> type ID . changecontext LPAREN params RPAREN returnblock
    (78) changecontext -> .
    LPAREN          reduce using rule 78 (changecontext -> .)

    changecontext                  shift and go to state 38

state 32

    (24) voidfunc -> VOID ID . changecontext LPAREN params RPAREN block
    (78) changecontext -> .
    LPAREN          reduce using rule 78 (changecontext -> .)

    changecontext                  shift and go to state 39

state 33

    (6) declare -> decvars saveglobalvars decfuncs main_block .
    $end            reduce using rule 6 (declare -> decvars saveglobalvars decfuncs main_block .)


state 34

    (7) main_block -> MAIN changecontext LPAREN RPAREN . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 40

state 35

    (13) decvar_line -> type decvar SEMICOLON . decvar_line
    (14) decvar_line -> type decvar SEMICOLON .
    (13) decvar_line -> . type decvar SEMICOLON decvar_line
    (14) decvar_line -> . type decvar SEMICOLON
    (68) type -> . FLOAT
    (69) type -> . INT
    MAIN            reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    FUNC            reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    ID              reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    VARS            reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    FROM            reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    WHILE           reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    INPUT           reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    PRINT           reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    IF              reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    RCURLY          reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    RETURN          reduce using rule 14 (decvar_line -> type decvar SEMICOLON .)
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    type                           shift and go to state 18
    decvar_line                    shift and go to state 42

state 36

    (15) decvar -> var COMMA . decvar
    (15) decvar -> . var COMMA decvar
    (16) decvar -> . var
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    ID              shift and go to state 30

    var                            shift and go to state 29
    decvar                         shift and go to state 43

state 37

    (17) var -> ID LBRACKET . exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> ID LBRACKET . exp RBRACKET
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    exp                            shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 38

    (25) typefunc -> type ID changecontext . LPAREN params RPAREN returnblock
    LPAREN          shift and go to state 54


state 39

    (24) voidfunc -> VOID ID changecontext . LPAREN params RPAREN block
    LPAREN          shift and go to state 55


state 40

    (7) main_block -> MAIN changecontext LPAREN RPAREN block .
    $end            reduce using rule 7 (main_block -> MAIN changecontext LPAREN RPAREN block .)


state 41

    (8) block -> LCURLY . blockcontent RCURLY
    (10) blockcontent -> . empty
    (11) blockcontent -> . statute blockcontent
    (80) empty -> .
    (70) statute -> . call
    (71) statute -> . decvars
    (72) statute -> . forloop
    (73) statute -> . whileloop
    (74) statute -> . read
    (75) statute -> . write
    (76) statute -> . condition
    (77) statute -> . assignment
    (29) call -> . ID LPAREN callvalues RPAREN
    (12) decvars -> . VARS decvar_line
    (54) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (55) forloop -> . FROM var ASSIGN expression TO expression DO block
    (56) whileloop -> . WHILE LPAREN expression RPAREN block
    (58) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (59) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (64) condition -> . IF LPAREN expression RPAREN block ELSE block
    (65) condition -> . IF LPAREN expression RPAREN block
    (57) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 80 (empty -> .)
    ID              shift and go to state 67
    VARS            shift and go to state 11
    FROM            shift and go to state 68
    WHILE           shift and go to state 69
    INPUT           shift and go to state 70
    PRINT           shift and go to state 71
    IF              shift and go to state 72

    blockcontent                   shift and go to state 56
    empty                          shift and go to state 57
    statute                        shift and go to state 58
    call                           shift and go to state 59
    decvars                        shift and go to state 60
    forloop                        shift and go to state 61
    whileloop                      shift and go to state 62
    read                           shift and go to state 63
    write                          shift and go to state 64
    condition                      shift and go to state 65
    assignment                     shift and go to state 66

state 42

    (13) decvar_line -> type decvar SEMICOLON decvar_line .
    MAIN            reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FUNC            reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    VARS            reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 13 (decvar_line -> type decvar SEMICOLON decvar_line .)


state 43

    (15) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 15 (decvar -> var COMMA decvar .)
    RPAREN          reduce using rule 15 (decvar -> var COMMA decvar .)


state 44

    (29) call -> ID . LPAREN callvalues RPAREN
    (17) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> ID . LBRACKET exp RBRACKET
    (19) var -> ID .
    LPAREN          shift and go to state 73
    LBRACKET        shift and go to state 37
    DIVIDE          reduce using rule 19 (var -> ID .)
    TIMES           reduce using rule 19 (var -> ID .)
    MINUS           reduce using rule 19 (var -> ID .)
    PLUS            reduce using rule 19 (var -> ID .)
    RBRACKET        reduce using rule 19 (var -> ID .)
    NEQ             reduce using rule 19 (var -> ID .)
    EQ              reduce using rule 19 (var -> ID .)
    LTE             reduce using rule 19 (var -> ID .)
    GTE             reduce using rule 19 (var -> ID .)
    LT              reduce using rule 19 (var -> ID .)
    GT              reduce using rule 19 (var -> ID .)
    OR              reduce using rule 19 (var -> ID .)
    AND             reduce using rule 19 (var -> ID .)
    RPAREN          reduce using rule 19 (var -> ID .)
    COMMA           reduce using rule 19 (var -> ID .)
    SEMICOLON       reduce using rule 19 (var -> ID .)
    TO              reduce using rule 19 (var -> ID .)
    BY              reduce using rule 19 (var -> ID .)
    DO              reduce using rule 19 (var -> ID .)


state 45

    (17) var -> ID LBRACKET exp . RBRACKET LBRACKET exp RBRACKET
    (18) var -> ID LBRACKET exp . RBRACKET
    RBRACKET        shift and go to state 74


state 46

    (44) exp -> term . MINUS exp
    (45) exp -> term . PLUS exp
    (46) exp -> term .
    MINUS           shift and go to state 75
    PLUS            shift and go to state 76
    RBRACKET        reduce using rule 46 (exp -> term .)
    NEQ             reduce using rule 46 (exp -> term .)
    EQ              reduce using rule 46 (exp -> term .)
    LTE             reduce using rule 46 (exp -> term .)
    GTE             reduce using rule 46 (exp -> term .)
    LT              reduce using rule 46 (exp -> term .)
    GT              reduce using rule 46 (exp -> term .)
    OR              reduce using rule 46 (exp -> term .)
    AND             reduce using rule 46 (exp -> term .)
    RPAREN          reduce using rule 46 (exp -> term .)
    COMMA           reduce using rule 46 (exp -> term .)
    SEMICOLON       reduce using rule 46 (exp -> term .)
    TO              reduce using rule 46 (exp -> term .)
    BY              reduce using rule 46 (exp -> term .)
    DO              reduce using rule 46 (exp -> term .)


state 47

    (47) term -> factor . DIVIDE term
    (48) term -> factor . TIMES term
    (49) term -> factor .
    DIVIDE          shift and go to state 77
    TIMES           shift and go to state 78
    MINUS           reduce using rule 49 (term -> factor .)
    PLUS            reduce using rule 49 (term -> factor .)
    RBRACKET        reduce using rule 49 (term -> factor .)
    NEQ             reduce using rule 49 (term -> factor .)
    EQ              reduce using rule 49 (term -> factor .)
    LTE             reduce using rule 49 (term -> factor .)
    GTE             reduce using rule 49 (term -> factor .)
    LT              reduce using rule 49 (term -> factor .)
    GT              reduce using rule 49 (term -> factor .)
    OR              reduce using rule 49 (term -> factor .)
    AND             reduce using rule 49 (term -> factor .)
    RPAREN          reduce using rule 49 (term -> factor .)
    COMMA           reduce using rule 49 (term -> factor .)
    SEMICOLON       reduce using rule 49 (term -> factor .)
    TO              reduce using rule 49 (term -> factor .)
    BY              reduce using rule 49 (term -> factor .)
    DO              reduce using rule 49 (term -> factor .)


state 48

    (50) factor -> LPAREN . super_exp RPAREN
    (33) super_exp -> . expression OR super_exp
    (34) super_exp -> . expression AND super_exp
    (35) super_exp -> . expression
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    super_exp                      shift and go to state 79
    expression                     shift and go to state 80
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 49

    (51) factor -> varcte .
    DIVIDE          reduce using rule 51 (factor -> varcte .)
    TIMES           reduce using rule 51 (factor -> varcte .)
    MINUS           reduce using rule 51 (factor -> varcte .)
    PLUS            reduce using rule 51 (factor -> varcte .)
    RBRACKET        reduce using rule 51 (factor -> varcte .)
    NEQ             reduce using rule 51 (factor -> varcte .)
    EQ              reduce using rule 51 (factor -> varcte .)
    LTE             reduce using rule 51 (factor -> varcte .)
    GTE             reduce using rule 51 (factor -> varcte .)
    LT              reduce using rule 51 (factor -> varcte .)
    GT              reduce using rule 51 (factor -> varcte .)
    OR              reduce using rule 51 (factor -> varcte .)
    AND             reduce using rule 51 (factor -> varcte .)
    RPAREN          reduce using rule 51 (factor -> varcte .)
    COMMA           reduce using rule 51 (factor -> varcte .)
    SEMICOLON       reduce using rule 51 (factor -> varcte .)
    TO              reduce using rule 51 (factor -> varcte .)
    BY              reduce using rule 51 (factor -> varcte .)
    DO              reduce using rule 51 (factor -> varcte .)


state 50

    (52) factor -> call .
    DIVIDE          reduce using rule 52 (factor -> call .)
    TIMES           reduce using rule 52 (factor -> call .)
    MINUS           reduce using rule 52 (factor -> call .)
    PLUS            reduce using rule 52 (factor -> call .)
    RBRACKET        reduce using rule 52 (factor -> call .)
    NEQ             reduce using rule 52 (factor -> call .)
    EQ              reduce using rule 52 (factor -> call .)
    LTE             reduce using rule 52 (factor -> call .)
    GTE             reduce using rule 52 (factor -> call .)
    LT              reduce using rule 52 (factor -> call .)
    GT              reduce using rule 52 (factor -> call .)
    OR              reduce using rule 52 (factor -> call .)
    AND             reduce using rule 52 (factor -> call .)
    RPAREN          reduce using rule 52 (factor -> call .)
    COMMA           reduce using rule 52 (factor -> call .)
    SEMICOLON       reduce using rule 52 (factor -> call .)
    TO              reduce using rule 52 (factor -> call .)
    BY              reduce using rule 52 (factor -> call .)
    DO              reduce using rule 52 (factor -> call .)


state 51

    (53) factor -> var .
    DIVIDE          reduce using rule 53 (factor -> var .)
    TIMES           reduce using rule 53 (factor -> var .)
    MINUS           reduce using rule 53 (factor -> var .)
    PLUS            reduce using rule 53 (factor -> var .)
    RBRACKET        reduce using rule 53 (factor -> var .)
    NEQ             reduce using rule 53 (factor -> var .)
    EQ              reduce using rule 53 (factor -> var .)
    LTE             reduce using rule 53 (factor -> var .)
    GTE             reduce using rule 53 (factor -> var .)
    LT              reduce using rule 53 (factor -> var .)
    GT              reduce using rule 53 (factor -> var .)
    OR              reduce using rule 53 (factor -> var .)
    AND             reduce using rule 53 (factor -> var .)
    RPAREN          reduce using rule 53 (factor -> var .)
    COMMA           reduce using rule 53 (factor -> var .)
    SEMICOLON       reduce using rule 53 (factor -> var .)
    TO              reduce using rule 53 (factor -> var .)
    BY              reduce using rule 53 (factor -> var .)
    DO              reduce using rule 53 (factor -> var .)


state 52

    (66) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 66 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 66 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 66 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 66 (varcte -> CTEFLOAT .)
    RBRACKET        reduce using rule 66 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 66 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 66 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 66 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 66 (varcte -> CTEFLOAT .)
    LT              reduce using rule 66 (varcte -> CTEFLOAT .)
    GT              reduce using rule 66 (varcte -> CTEFLOAT .)
    OR              reduce using rule 66 (varcte -> CTEFLOAT .)
    AND             reduce using rule 66 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 66 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 66 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 66 (varcte -> CTEFLOAT .)
    TO              reduce using rule 66 (varcte -> CTEFLOAT .)
    BY              reduce using rule 66 (varcte -> CTEFLOAT .)
    DO              reduce using rule 66 (varcte -> CTEFLOAT .)


state 53

    (67) varcte -> CTEINT .
    DIVIDE          reduce using rule 67 (varcte -> CTEINT .)
    TIMES           reduce using rule 67 (varcte -> CTEINT .)
    MINUS           reduce using rule 67 (varcte -> CTEINT .)
    PLUS            reduce using rule 67 (varcte -> CTEINT .)
    RBRACKET        reduce using rule 67 (varcte -> CTEINT .)
    NEQ             reduce using rule 67 (varcte -> CTEINT .)
    EQ              reduce using rule 67 (varcte -> CTEINT .)
    LTE             reduce using rule 67 (varcte -> CTEINT .)
    GTE             reduce using rule 67 (varcte -> CTEINT .)
    LT              reduce using rule 67 (varcte -> CTEINT .)
    GT              reduce using rule 67 (varcte -> CTEINT .)
    OR              reduce using rule 67 (varcte -> CTEINT .)
    AND             reduce using rule 67 (varcte -> CTEINT .)
    RPAREN          reduce using rule 67 (varcte -> CTEINT .)
    COMMA           reduce using rule 67 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 67 (varcte -> CTEINT .)
    TO              reduce using rule 67 (varcte -> CTEINT .)
    BY              reduce using rule 67 (varcte -> CTEINT .)
    DO              reduce using rule 67 (varcte -> CTEINT .)


state 54

    (25) typefunc -> type ID changecontext LPAREN . params RPAREN returnblock
    (26) params -> . empty
    (27) params -> . type ID COMMA params
    (28) params -> . type ID
    (80) empty -> .
    (68) type -> . FLOAT
    (69) type -> . INT
    RPAREN          reduce using rule 80 (empty -> .)
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    type                           shift and go to state 82
    params                         shift and go to state 83
    empty                          shift and go to state 84

state 55

    (24) voidfunc -> VOID ID changecontext LPAREN . params RPAREN block
    (26) params -> . empty
    (27) params -> . type ID COMMA params
    (28) params -> . type ID
    (80) empty -> .
    (68) type -> . FLOAT
    (69) type -> . INT
    RPAREN          reduce using rule 80 (empty -> .)
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    params                         shift and go to state 85
    empty                          shift and go to state 84
    type                           shift and go to state 82

state 56

    (8) block -> LCURLY blockcontent . RCURLY
    RCURLY          shift and go to state 86


state 57

    (10) blockcontent -> empty .
    RCURLY          reduce using rule 10 (blockcontent -> empty .)
    RETURN          reduce using rule 10 (blockcontent -> empty .)


state 58

    (11) blockcontent -> statute . blockcontent
    (10) blockcontent -> . empty
    (11) blockcontent -> . statute blockcontent
    (80) empty -> .
    (70) statute -> . call
    (71) statute -> . decvars
    (72) statute -> . forloop
    (73) statute -> . whileloop
    (74) statute -> . read
    (75) statute -> . write
    (76) statute -> . condition
    (77) statute -> . assignment
    (29) call -> . ID LPAREN callvalues RPAREN
    (12) decvars -> . VARS decvar_line
    (54) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (55) forloop -> . FROM var ASSIGN expression TO expression DO block
    (56) whileloop -> . WHILE LPAREN expression RPAREN block
    (58) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (59) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (64) condition -> . IF LPAREN expression RPAREN block ELSE block
    (65) condition -> . IF LPAREN expression RPAREN block
    (57) assignment -> . ID ASSIGN expression SEMICOLON
    RCURLY          reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    ID              shift and go to state 67
    VARS            shift and go to state 11
    FROM            shift and go to state 68
    WHILE           shift and go to state 69
    INPUT           shift and go to state 70
    PRINT           shift and go to state 71
    IF              shift and go to state 72

    statute                        shift and go to state 58
    blockcontent                   shift and go to state 87
    empty                          shift and go to state 57
    call                           shift and go to state 59
    decvars                        shift and go to state 60
    forloop                        shift and go to state 61
    whileloop                      shift and go to state 62
    read                           shift and go to state 63
    write                          shift and go to state 64
    condition                      shift and go to state 65
    assignment                     shift and go to state 66

state 59

    (70) statute -> call .
    ID              reduce using rule 70 (statute -> call .)
    VARS            reduce using rule 70 (statute -> call .)
    FROM            reduce using rule 70 (statute -> call .)
    WHILE           reduce using rule 70 (statute -> call .)
    INPUT           reduce using rule 70 (statute -> call .)
    PRINT           reduce using rule 70 (statute -> call .)
    IF              reduce using rule 70 (statute -> call .)
    RCURLY          reduce using rule 70 (statute -> call .)
    RETURN          reduce using rule 70 (statute -> call .)


state 60

    (71) statute -> decvars .
    ID              reduce using rule 71 (statute -> decvars .)
    VARS            reduce using rule 71 (statute -> decvars .)
    FROM            reduce using rule 71 (statute -> decvars .)
    WHILE           reduce using rule 71 (statute -> decvars .)
    INPUT           reduce using rule 71 (statute -> decvars .)
    PRINT           reduce using rule 71 (statute -> decvars .)
    IF              reduce using rule 71 (statute -> decvars .)
    RCURLY          reduce using rule 71 (statute -> decvars .)
    RETURN          reduce using rule 71 (statute -> decvars .)


state 61

    (72) statute -> forloop .
    ID              reduce using rule 72 (statute -> forloop .)
    VARS            reduce using rule 72 (statute -> forloop .)
    FROM            reduce using rule 72 (statute -> forloop .)
    WHILE           reduce using rule 72 (statute -> forloop .)
    INPUT           reduce using rule 72 (statute -> forloop .)
    PRINT           reduce using rule 72 (statute -> forloop .)
    IF              reduce using rule 72 (statute -> forloop .)
    RCURLY          reduce using rule 72 (statute -> forloop .)
    RETURN          reduce using rule 72 (statute -> forloop .)


state 62

    (73) statute -> whileloop .
    ID              reduce using rule 73 (statute -> whileloop .)
    VARS            reduce using rule 73 (statute -> whileloop .)
    FROM            reduce using rule 73 (statute -> whileloop .)
    WHILE           reduce using rule 73 (statute -> whileloop .)
    INPUT           reduce using rule 73 (statute -> whileloop .)
    PRINT           reduce using rule 73 (statute -> whileloop .)
    IF              reduce using rule 73 (statute -> whileloop .)
    RCURLY          reduce using rule 73 (statute -> whileloop .)
    RETURN          reduce using rule 73 (statute -> whileloop .)


state 63

    (74) statute -> read .
    ID              reduce using rule 74 (statute -> read .)
    VARS            reduce using rule 74 (statute -> read .)
    FROM            reduce using rule 74 (statute -> read .)
    WHILE           reduce using rule 74 (statute -> read .)
    INPUT           reduce using rule 74 (statute -> read .)
    PRINT           reduce using rule 74 (statute -> read .)
    IF              reduce using rule 74 (statute -> read .)
    RCURLY          reduce using rule 74 (statute -> read .)
    RETURN          reduce using rule 74 (statute -> read .)


state 64

    (75) statute -> write .
    ID              reduce using rule 75 (statute -> write .)
    VARS            reduce using rule 75 (statute -> write .)
    FROM            reduce using rule 75 (statute -> write .)
    WHILE           reduce using rule 75 (statute -> write .)
    INPUT           reduce using rule 75 (statute -> write .)
    PRINT           reduce using rule 75 (statute -> write .)
    IF              reduce using rule 75 (statute -> write .)
    RCURLY          reduce using rule 75 (statute -> write .)
    RETURN          reduce using rule 75 (statute -> write .)


state 65

    (76) statute -> condition .
    ID              reduce using rule 76 (statute -> condition .)
    VARS            reduce using rule 76 (statute -> condition .)
    FROM            reduce using rule 76 (statute -> condition .)
    WHILE           reduce using rule 76 (statute -> condition .)
    INPUT           reduce using rule 76 (statute -> condition .)
    PRINT           reduce using rule 76 (statute -> condition .)
    IF              reduce using rule 76 (statute -> condition .)
    RCURLY          reduce using rule 76 (statute -> condition .)
    RETURN          reduce using rule 76 (statute -> condition .)


state 66

    (77) statute -> assignment .
    ID              reduce using rule 77 (statute -> assignment .)
    VARS            reduce using rule 77 (statute -> assignment .)
    FROM            reduce using rule 77 (statute -> assignment .)
    WHILE           reduce using rule 77 (statute -> assignment .)
    INPUT           reduce using rule 77 (statute -> assignment .)
    PRINT           reduce using rule 77 (statute -> assignment .)
    IF              reduce using rule 77 (statute -> assignment .)
    RCURLY          reduce using rule 77 (statute -> assignment .)
    RETURN          reduce using rule 77 (statute -> assignment .)


state 67

    (29) call -> ID . LPAREN callvalues RPAREN
    (57) assignment -> ID . ASSIGN expression SEMICOLON
    LPAREN          shift and go to state 73
    ASSIGN          shift and go to state 88


state 68

    (54) forloop -> FROM . var ASSIGN expression TO expression BY expression DO block
    (55) forloop -> FROM . var ASSIGN expression TO expression DO block
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    ID              shift and go to state 30

    var                            shift and go to state 89

state 69

    (56) whileloop -> WHILE . LPAREN expression RPAREN block
    LPAREN          shift and go to state 90


state 70

    (58) read -> INPUT . LPAREN decvar RPAREN SEMICOLON
    LPAREN          shift and go to state 91


state 71

    (59) write -> PRINT . LPAREN writevalues RPAREN SEMICOLON
    LPAREN          shift and go to state 92


state 72

    (64) condition -> IF . LPAREN expression RPAREN block ELSE block
    (65) condition -> IF . LPAREN expression RPAREN block
    LPAREN          shift and go to state 93


state 73

    (29) call -> ID LPAREN . callvalues RPAREN
    (30) callvalues -> . empty
    (31) callvalues -> . exp COMMA callvalues
    (32) callvalues -> . exp
    (80) empty -> .
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    RPAREN          reduce using rule 80 (empty -> .)
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    callvalues                     shift and go to state 94
    empty                          shift and go to state 95
    exp                            shift and go to state 96
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 74

    (17) var -> ID LBRACKET exp RBRACKET . LBRACKET exp RBRACKET
    (18) var -> ID LBRACKET exp RBRACKET .
    LBRACKET        shift and go to state 97
    COMMA           reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    NEQ             reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    EQ              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    LTE             reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    GTE             reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    LT              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    GT              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    OR              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    AND             reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    ASSIGN          reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    TO              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    BY              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)
    DO              reduce using rule 18 (var -> ID LBRACKET exp RBRACKET .)


state 75

    (44) exp -> term MINUS . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    term                           shift and go to state 46
    exp                            shift and go to state 98
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 76

    (45) exp -> term PLUS . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    term                           shift and go to state 46
    exp                            shift and go to state 99
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 77

    (47) term -> factor DIVIDE . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    factor                         shift and go to state 47
    term                           shift and go to state 100
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 78

    (48) term -> factor TIMES . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    factor                         shift and go to state 47
    term                           shift and go to state 101
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 79

    (50) factor -> LPAREN super_exp . RPAREN
    RPAREN          shift and go to state 102


state 80

    (33) super_exp -> expression . OR super_exp
    (34) super_exp -> expression . AND super_exp
    (35) super_exp -> expression .
    OR              shift and go to state 103
    AND             shift and go to state 104
    RPAREN          reduce using rule 35 (super_exp -> expression .)
    COMMA           reduce using rule 35 (super_exp -> expression .)


state 81

    (36) expression -> exp . relation exp
    (37) expression -> exp .
    (38) relation -> . NEQ
    (39) relation -> . EQ
    (40) relation -> . LTE
    (41) relation -> . GTE
    (42) relation -> . LT
    (43) relation -> . GT
    OR              reduce using rule 37 (expression -> exp .)
    AND             reduce using rule 37 (expression -> exp .)
    RPAREN          reduce using rule 37 (expression -> exp .)
    SEMICOLON       reduce using rule 37 (expression -> exp .)
    COMMA           reduce using rule 37 (expression -> exp .)
    TO              reduce using rule 37 (expression -> exp .)
    BY              reduce using rule 37 (expression -> exp .)
    DO              reduce using rule 37 (expression -> exp .)
    NEQ             shift and go to state 106
    EQ              shift and go to state 107
    LTE             shift and go to state 108
    GTE             shift and go to state 109
    LT              shift and go to state 110
    GT              shift and go to state 111

    relation                       shift and go to state 105

state 82

    (27) params -> type . ID COMMA params
    (28) params -> type . ID
    ID              shift and go to state 112


state 83

    (25) typefunc -> type ID changecontext LPAREN params . RPAREN returnblock
    RPAREN          shift and go to state 113


state 84

    (26) params -> empty .
    RPAREN          reduce using rule 26 (params -> empty .)


state 85

    (24) voidfunc -> VOID ID changecontext LPAREN params . RPAREN block
    RPAREN          shift and go to state 114


state 86

    (8) block -> LCURLY blockcontent RCURLY .
    $end            reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    FUNC            reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    MAIN            reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    ID              reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    VARS            reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    FROM            reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    WHILE           reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    INPUT           reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    PRINT           reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    IF              reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    RCURLY          reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    RETURN          reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)
    ELSE            reduce using rule 8 (block -> LCURLY blockcontent RCURLY .)


state 87

    (11) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 11 (blockcontent -> statute blockcontent .)
    RETURN          reduce using rule 11 (blockcontent -> statute blockcontent .)


state 88

    (57) assignment -> ID ASSIGN . expression SEMICOLON
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    expression                     shift and go to state 115
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 89

    (54) forloop -> FROM var . ASSIGN expression TO expression BY expression DO block
    (55) forloop -> FROM var . ASSIGN expression TO expression DO block
    ASSIGN          shift and go to state 116


state 90

    (56) whileloop -> WHILE LPAREN . expression RPAREN block
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    expression                     shift and go to state 117
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 91

    (58) read -> INPUT LPAREN . decvar RPAREN SEMICOLON
    (15) decvar -> . var COMMA decvar
    (16) decvar -> . var
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    ID              shift and go to state 30

    decvar                         shift and go to state 118
    var                            shift and go to state 29

state 92

    (59) write -> PRINT LPAREN . writevalues RPAREN SEMICOLON
    (60) writevalues -> . CTESTRING COMMA writevalues
    (61) writevalues -> . super_exp COMMA writevalues
    (62) writevalues -> . CTESTRING
    (63) writevalues -> . super_exp
    (33) super_exp -> . expression OR super_exp
    (34) super_exp -> . expression AND super_exp
    (35) super_exp -> . expression
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    CTESTRING       shift and go to state 120
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    writevalues                    shift and go to state 119
    super_exp                      shift and go to state 121
    expression                     shift and go to state 80
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 93

    (64) condition -> IF LPAREN . expression RPAREN block ELSE block
    (65) condition -> IF LPAREN . expression RPAREN block
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    expression                     shift and go to state 122
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 94

    (29) call -> ID LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 123


state 95

    (30) callvalues -> empty .
    RPAREN          reduce using rule 30 (callvalues -> empty .)


state 96

    (31) callvalues -> exp . COMMA callvalues
    (32) callvalues -> exp .
    COMMA           shift and go to state 124
    RPAREN          reduce using rule 32 (callvalues -> exp .)


state 97

    (17) var -> ID LBRACKET exp RBRACKET LBRACKET . exp RBRACKET
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    exp                            shift and go to state 125
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 98

    (44) exp -> term MINUS exp .
    RBRACKET        reduce using rule 44 (exp -> term MINUS exp .)
    NEQ             reduce using rule 44 (exp -> term MINUS exp .)
    EQ              reduce using rule 44 (exp -> term MINUS exp .)
    LTE             reduce using rule 44 (exp -> term MINUS exp .)
    GTE             reduce using rule 44 (exp -> term MINUS exp .)
    LT              reduce using rule 44 (exp -> term MINUS exp .)
    GT              reduce using rule 44 (exp -> term MINUS exp .)
    OR              reduce using rule 44 (exp -> term MINUS exp .)
    AND             reduce using rule 44 (exp -> term MINUS exp .)
    RPAREN          reduce using rule 44 (exp -> term MINUS exp .)
    COMMA           reduce using rule 44 (exp -> term MINUS exp .)
    SEMICOLON       reduce using rule 44 (exp -> term MINUS exp .)
    TO              reduce using rule 44 (exp -> term MINUS exp .)
    BY              reduce using rule 44 (exp -> term MINUS exp .)
    DO              reduce using rule 44 (exp -> term MINUS exp .)


state 99

    (45) exp -> term PLUS exp .
    RBRACKET        reduce using rule 45 (exp -> term PLUS exp .)
    NEQ             reduce using rule 45 (exp -> term PLUS exp .)
    EQ              reduce using rule 45 (exp -> term PLUS exp .)
    LTE             reduce using rule 45 (exp -> term PLUS exp .)
    GTE             reduce using rule 45 (exp -> term PLUS exp .)
    LT              reduce using rule 45 (exp -> term PLUS exp .)
    GT              reduce using rule 45 (exp -> term PLUS exp .)
    OR              reduce using rule 45 (exp -> term PLUS exp .)
    AND             reduce using rule 45 (exp -> term PLUS exp .)
    RPAREN          reduce using rule 45 (exp -> term PLUS exp .)
    COMMA           reduce using rule 45 (exp -> term PLUS exp .)
    SEMICOLON       reduce using rule 45 (exp -> term PLUS exp .)
    TO              reduce using rule 45 (exp -> term PLUS exp .)
    BY              reduce using rule 45 (exp -> term PLUS exp .)
    DO              reduce using rule 45 (exp -> term PLUS exp .)


state 100

    (47) term -> factor DIVIDE term .
    MINUS           reduce using rule 47 (term -> factor DIVIDE term .)
    PLUS            reduce using rule 47 (term -> factor DIVIDE term .)
    RBRACKET        reduce using rule 47 (term -> factor DIVIDE term .)
    NEQ             reduce using rule 47 (term -> factor DIVIDE term .)
    EQ              reduce using rule 47 (term -> factor DIVIDE term .)
    LTE             reduce using rule 47 (term -> factor DIVIDE term .)
    GTE             reduce using rule 47 (term -> factor DIVIDE term .)
    LT              reduce using rule 47 (term -> factor DIVIDE term .)
    GT              reduce using rule 47 (term -> factor DIVIDE term .)
    OR              reduce using rule 47 (term -> factor DIVIDE term .)
    AND             reduce using rule 47 (term -> factor DIVIDE term .)
    RPAREN          reduce using rule 47 (term -> factor DIVIDE term .)
    COMMA           reduce using rule 47 (term -> factor DIVIDE term .)
    SEMICOLON       reduce using rule 47 (term -> factor DIVIDE term .)
    TO              reduce using rule 47 (term -> factor DIVIDE term .)
    BY              reduce using rule 47 (term -> factor DIVIDE term .)
    DO              reduce using rule 47 (term -> factor DIVIDE term .)


state 101

    (48) term -> factor TIMES term .
    MINUS           reduce using rule 48 (term -> factor TIMES term .)
    PLUS            reduce using rule 48 (term -> factor TIMES term .)
    RBRACKET        reduce using rule 48 (term -> factor TIMES term .)
    NEQ             reduce using rule 48 (term -> factor TIMES term .)
    EQ              reduce using rule 48 (term -> factor TIMES term .)
    LTE             reduce using rule 48 (term -> factor TIMES term .)
    GTE             reduce using rule 48 (term -> factor TIMES term .)
    LT              reduce using rule 48 (term -> factor TIMES term .)
    GT              reduce using rule 48 (term -> factor TIMES term .)
    OR              reduce using rule 48 (term -> factor TIMES term .)
    AND             reduce using rule 48 (term -> factor TIMES term .)
    RPAREN          reduce using rule 48 (term -> factor TIMES term .)
    COMMA           reduce using rule 48 (term -> factor TIMES term .)
    SEMICOLON       reduce using rule 48 (term -> factor TIMES term .)
    TO              reduce using rule 48 (term -> factor TIMES term .)
    BY              reduce using rule 48 (term -> factor TIMES term .)
    DO              reduce using rule 48 (term -> factor TIMES term .)


state 102

    (50) factor -> LPAREN super_exp RPAREN .
    DIVIDE          reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    TIMES           reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    MINUS           reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    PLUS            reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    RBRACKET        reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    NEQ             reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    EQ              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    LTE             reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    GTE             reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    LT              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    GT              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    OR              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    AND             reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    RPAREN          reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    COMMA           reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    SEMICOLON       reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    TO              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    BY              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)
    DO              reduce using rule 50 (factor -> LPAREN super_exp RPAREN .)


state 103

    (33) super_exp -> expression OR . super_exp
    (33) super_exp -> . expression OR super_exp
    (34) super_exp -> . expression AND super_exp
    (35) super_exp -> . expression
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    expression                     shift and go to state 80
    super_exp                      shift and go to state 126
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 104

    (34) super_exp -> expression AND . super_exp
    (33) super_exp -> . expression OR super_exp
    (34) super_exp -> . expression AND super_exp
    (35) super_exp -> . expression
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    expression                     shift and go to state 80
    super_exp                      shift and go to state 127
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 105

    (36) expression -> exp relation . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    exp                            shift and go to state 128
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 106

    (38) relation -> NEQ .
    LPAREN          reduce using rule 38 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 38 (relation -> NEQ .)
    CTEINT          reduce using rule 38 (relation -> NEQ .)
    ID              reduce using rule 38 (relation -> NEQ .)


state 107

    (39) relation -> EQ .
    LPAREN          reduce using rule 39 (relation -> EQ .)
    CTEFLOAT        reduce using rule 39 (relation -> EQ .)
    CTEINT          reduce using rule 39 (relation -> EQ .)
    ID              reduce using rule 39 (relation -> EQ .)


state 108

    (40) relation -> LTE .
    LPAREN          reduce using rule 40 (relation -> LTE .)
    CTEFLOAT        reduce using rule 40 (relation -> LTE .)
    CTEINT          reduce using rule 40 (relation -> LTE .)
    ID              reduce using rule 40 (relation -> LTE .)


state 109

    (41) relation -> GTE .
    LPAREN          reduce using rule 41 (relation -> GTE .)
    CTEFLOAT        reduce using rule 41 (relation -> GTE .)
    CTEINT          reduce using rule 41 (relation -> GTE .)
    ID              reduce using rule 41 (relation -> GTE .)


state 110

    (42) relation -> LT .
    LPAREN          reduce using rule 42 (relation -> LT .)
    CTEFLOAT        reduce using rule 42 (relation -> LT .)
    CTEINT          reduce using rule 42 (relation -> LT .)
    ID              reduce using rule 42 (relation -> LT .)


state 111

    (43) relation -> GT .
    LPAREN          reduce using rule 43 (relation -> GT .)
    CTEFLOAT        reduce using rule 43 (relation -> GT .)
    CTEINT          reduce using rule 43 (relation -> GT .)
    ID              reduce using rule 43 (relation -> GT .)


state 112

    (27) params -> type ID . COMMA params
    (28) params -> type ID .
    COMMA           shift and go to state 129
    RPAREN          reduce using rule 28 (params -> type ID .)


state 113

    (25) typefunc -> type ID changecontext LPAREN params RPAREN . returnblock
    (9) returnblock -> . LCURLY blockcontent RETURN exp SEMICOLON RCURLY
    LCURLY          shift and go to state 131

    returnblock                    shift and go to state 130

state 114

    (24) voidfunc -> VOID ID changecontext LPAREN params RPAREN . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 132

state 115

    (57) assignment -> ID ASSIGN expression . SEMICOLON
    SEMICOLON       shift and go to state 133


state 116

    (54) forloop -> FROM var ASSIGN . expression TO expression BY expression DO block
    (55) forloop -> FROM var ASSIGN . expression TO expression DO block
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    var                            shift and go to state 51
    expression                     shift and go to state 134
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50

state 117

    (56) whileloop -> WHILE LPAREN expression . RPAREN block
    RPAREN          shift and go to state 135


state 118

    (58) read -> INPUT LPAREN decvar . RPAREN SEMICOLON
    RPAREN          shift and go to state 136


state 119

    (59) write -> PRINT LPAREN writevalues . RPAREN SEMICOLON
    RPAREN          shift and go to state 137


state 120

    (60) writevalues -> CTESTRING . COMMA writevalues
    (62) writevalues -> CTESTRING .
    COMMA           shift and go to state 138
    RPAREN          reduce using rule 62 (writevalues -> CTESTRING .)


state 121

    (61) writevalues -> super_exp . COMMA writevalues
    (63) writevalues -> super_exp .
    COMMA           shift and go to state 139
    RPAREN          reduce using rule 63 (writevalues -> super_exp .)


state 122

    (64) condition -> IF LPAREN expression . RPAREN block ELSE block
    (65) condition -> IF LPAREN expression . RPAREN block
    RPAREN          shift and go to state 140


state 123

    (29) call -> ID LPAREN callvalues RPAREN .
    DIVIDE          reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    RBRACKET        reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    ID              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    VARS            reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    FROM            reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    IF              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    EQ              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    LTE             reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    GTE             reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    LT              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    GT              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    OR              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    AND             reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    RETURN          reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    TO              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    BY              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)
    DO              reduce using rule 29 (call -> ID LPAREN callvalues RPAREN .)


state 124

    (31) callvalues -> exp COMMA . callvalues
    (30) callvalues -> . empty
    (31) callvalues -> . exp COMMA callvalues
    (32) callvalues -> . exp
    (80) empty -> .
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    RPAREN          reduce using rule 80 (empty -> .)
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    exp                            shift and go to state 96
    callvalues                     shift and go to state 141
    empty                          shift and go to state 95
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 125

    (17) var -> ID LBRACKET exp RBRACKET LBRACKET exp . RBRACKET
    RBRACKET        shift and go to state 142


state 126

    (33) super_exp -> expression OR super_exp .
    RPAREN          reduce using rule 33 (super_exp -> expression OR super_exp .)
    COMMA           reduce using rule 33 (super_exp -> expression OR super_exp .)


state 127

    (34) super_exp -> expression AND super_exp .
    RPAREN          reduce using rule 34 (super_exp -> expression AND super_exp .)
    COMMA           reduce using rule 34 (super_exp -> expression AND super_exp .)


state 128

    (36) expression -> exp relation exp .
    OR              reduce using rule 36 (expression -> exp relation exp .)
    AND             reduce using rule 36 (expression -> exp relation exp .)
    RPAREN          reduce using rule 36 (expression -> exp relation exp .)
    SEMICOLON       reduce using rule 36 (expression -> exp relation exp .)
    COMMA           reduce using rule 36 (expression -> exp relation exp .)
    TO              reduce using rule 36 (expression -> exp relation exp .)
    BY              reduce using rule 36 (expression -> exp relation exp .)
    DO              reduce using rule 36 (expression -> exp relation exp .)


state 129

    (27) params -> type ID COMMA . params
    (26) params -> . empty
    (27) params -> . type ID COMMA params
    (28) params -> . type ID
    (80) empty -> .
    (68) type -> . FLOAT
    (69) type -> . INT
    RPAREN          reduce using rule 80 (empty -> .)
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    type                           shift and go to state 82
    params                         shift and go to state 143
    empty                          shift and go to state 84

state 130

    (25) typefunc -> type ID changecontext LPAREN params RPAREN returnblock .
    FUNC            reduce using rule 25 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)
    MAIN            reduce using rule 25 (typefunc -> type ID changecontext LPAREN params RPAREN returnblock .)


state 131

    (9) returnblock -> LCURLY . blockcontent RETURN exp SEMICOLON RCURLY
    (10) blockcontent -> . empty
    (11) blockcontent -> . statute blockcontent
    (80) empty -> .
    (70) statute -> . call
    (71) statute -> . decvars
    (72) statute -> . forloop
    (73) statute -> . whileloop
    (74) statute -> . read
    (75) statute -> . write
    (76) statute -> . condition
    (77) statute -> . assignment
    (29) call -> . ID LPAREN callvalues RPAREN
    (12) decvars -> . VARS decvar_line
    (54) forloop -> . FROM var ASSIGN expression TO expression BY expression DO block
    (55) forloop -> . FROM var ASSIGN expression TO expression DO block
    (56) whileloop -> . WHILE LPAREN expression RPAREN block
    (58) read -> . INPUT LPAREN decvar RPAREN SEMICOLON
    (59) write -> . PRINT LPAREN writevalues RPAREN SEMICOLON
    (64) condition -> . IF LPAREN expression RPAREN block ELSE block
    (65) condition -> . IF LPAREN expression RPAREN block
    (57) assignment -> . ID ASSIGN expression SEMICOLON
    RETURN          reduce using rule 80 (empty -> .)
    ID              shift and go to state 67
    VARS            shift and go to state 11
    FROM            shift and go to state 68
    WHILE           shift and go to state 69
    INPUT           shift and go to state 70
    PRINT           shift and go to state 71
    IF              shift and go to state 72

    blockcontent                   shift and go to state 144
    empty                          shift and go to state 57
    statute                        shift and go to state 58
    call                           shift and go to state 59
    decvars                        shift and go to state 60
    forloop                        shift and go to state 61
    whileloop                      shift and go to state 62
    read                           shift and go to state 63
    write                          shift and go to state 64
    condition                      shift and go to state 65
    assignment                     shift and go to state 66

state 132

    (24) voidfunc -> VOID ID changecontext LPAREN params RPAREN block .
    FUNC            reduce using rule 24 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)
    MAIN            reduce using rule 24 (voidfunc -> VOID ID changecontext LPAREN params RPAREN block .)


state 133

    (57) assignment -> ID ASSIGN expression SEMICOLON .
    ID              reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    VARS            reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    FROM            reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    INPUT           reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    RCURLY          reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 57 (assignment -> ID ASSIGN expression SEMICOLON .)


state 134

    (54) forloop -> FROM var ASSIGN expression . TO expression BY expression DO block
    (55) forloop -> FROM var ASSIGN expression . TO expression DO block
    TO              shift and go to state 145


state 135

    (56) whileloop -> WHILE LPAREN expression RPAREN . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 146

state 136

    (58) read -> INPUT LPAREN decvar RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 147


state 137

    (59) write -> PRINT LPAREN writevalues RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 148


state 138

    (60) writevalues -> CTESTRING COMMA . writevalues
    (60) writevalues -> . CTESTRING COMMA writevalues
    (61) writevalues -> . super_exp COMMA writevalues
    (62) writevalues -> . CTESTRING
    (63) writevalues -> . super_exp
    (33) super_exp -> . expression OR super_exp
    (34) super_exp -> . expression AND super_exp
    (35) super_exp -> . expression
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    CTESTRING       shift and go to state 120
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    writevalues                    shift and go to state 149
    super_exp                      shift and go to state 121
    expression                     shift and go to state 80
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 139

    (61) writevalues -> super_exp COMMA . writevalues
    (60) writevalues -> . CTESTRING COMMA writevalues
    (61) writevalues -> . super_exp COMMA writevalues
    (62) writevalues -> . CTESTRING
    (63) writevalues -> . super_exp
    (33) super_exp -> . expression OR super_exp
    (34) super_exp -> . expression AND super_exp
    (35) super_exp -> . expression
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    CTESTRING       shift and go to state 120
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    super_exp                      shift and go to state 121
    writevalues                    shift and go to state 150
    expression                     shift and go to state 80
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 140

    (64) condition -> IF LPAREN expression RPAREN . block ELSE block
    (65) condition -> IF LPAREN expression RPAREN . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 151

state 141

    (31) callvalues -> exp COMMA callvalues .
    RPAREN          reduce using rule 31 (callvalues -> exp COMMA callvalues .)


state 142

    (17) var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .
    COMMA           reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    NEQ             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    EQ              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LTE             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GTE             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LT              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GT              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    OR              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    AND             reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    ASSIGN          reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    TO              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    BY              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DO              reduce using rule 17 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)


state 143

    (27) params -> type ID COMMA params .
    RPAREN          reduce using rule 27 (params -> type ID COMMA params .)


state 144

    (9) returnblock -> LCURLY blockcontent . RETURN exp SEMICOLON RCURLY
    RETURN          shift and go to state 152


state 145

    (54) forloop -> FROM var ASSIGN expression TO . expression BY expression DO block
    (55) forloop -> FROM var ASSIGN expression TO . expression DO block
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    var                            shift and go to state 51
    expression                     shift and go to state 153
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50

state 146

    (56) whileloop -> WHILE LPAREN expression RPAREN block .
    ID              reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    VARS            reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    FROM            reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    WHILE           reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    INPUT           reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    PRINT           reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    IF              reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)
    RETURN          reduce using rule 56 (whileloop -> WHILE LPAREN expression RPAREN block .)


state 147

    (58) read -> INPUT LPAREN decvar RPAREN SEMICOLON .
    ID              reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    VARS            reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    FROM            reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    WHILE           reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    INPUT           reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    PRINT           reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    IF              reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RCURLY          reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)
    RETURN          reduce using rule 58 (read -> INPUT LPAREN decvar RPAREN SEMICOLON .)


state 148

    (59) write -> PRINT LPAREN writevalues RPAREN SEMICOLON .
    ID              reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    VARS            reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    FROM            reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    WHILE           reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    INPUT           reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    PRINT           reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    IF              reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RCURLY          reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)
    RETURN          reduce using rule 59 (write -> PRINT LPAREN writevalues RPAREN SEMICOLON .)


state 149

    (60) writevalues -> CTESTRING COMMA writevalues .
    RPAREN          reduce using rule 60 (writevalues -> CTESTRING COMMA writevalues .)


state 150

    (61) writevalues -> super_exp COMMA writevalues .
    RPAREN          reduce using rule 61 (writevalues -> super_exp COMMA writevalues .)


state 151

    (64) condition -> IF LPAREN expression RPAREN block . ELSE block
    (65) condition -> IF LPAREN expression RPAREN block .
    ELSE            shift and go to state 154
    ID              reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    VARS            reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    FROM            reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    WHILE           reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    INPUT           reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    PRINT           reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    IF              reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    RCURLY          reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)
    RETURN          reduce using rule 65 (condition -> IF LPAREN expression RPAREN block .)


state 152

    (9) returnblock -> LCURLY blockcontent RETURN . exp SEMICOLON RCURLY
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    exp                            shift and go to state 155
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50
    var                            shift and go to state 51

state 153

    (54) forloop -> FROM var ASSIGN expression TO expression . BY expression DO block
    (55) forloop -> FROM var ASSIGN expression TO expression . DO block
    BY              shift and go to state 156
    DO              shift and go to state 157


state 154

    (64) condition -> IF LPAREN expression RPAREN block ELSE . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 158

state 155

    (9) returnblock -> LCURLY blockcontent RETURN exp . SEMICOLON RCURLY
    SEMICOLON       shift and go to state 159


state 156

    (54) forloop -> FROM var ASSIGN expression TO expression BY . expression DO block
    (36) expression -> . exp relation exp
    (37) expression -> . exp
    (44) exp -> . term MINUS exp
    (45) exp -> . term PLUS exp
    (46) exp -> . term
    (47) term -> . factor DIVIDE term
    (48) term -> . factor TIMES term
    (49) term -> . factor
    (50) factor -> . LPAREN super_exp RPAREN
    (51) factor -> . varcte
    (52) factor -> . call
    (53) factor -> . var
    (66) varcte -> . CTEFLOAT
    (67) varcte -> . CTEINT
    (29) call -> . ID LPAREN callvalues RPAREN
    (17) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (18) var -> . ID LBRACKET exp RBRACKET
    (19) var -> . ID
    LPAREN          shift and go to state 48
    CTEFLOAT        shift and go to state 52
    CTEINT          shift and go to state 53
    ID              shift and go to state 44

    var                            shift and go to state 51
    expression                     shift and go to state 160
    exp                            shift and go to state 81
    term                           shift and go to state 46
    factor                         shift and go to state 47
    varcte                         shift and go to state 49
    call                           shift and go to state 50

state 157

    (55) forloop -> FROM var ASSIGN expression TO expression DO . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 161

state 158

    (64) condition -> IF LPAREN expression RPAREN block ELSE block .
    ID              reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    VARS            reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    FROM            reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    WHILE           reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    INPUT           reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    PRINT           reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    IF              reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RCURLY          reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)
    RETURN          reduce using rule 64 (condition -> IF LPAREN expression RPAREN block ELSE block .)


state 159

    (9) returnblock -> LCURLY blockcontent RETURN exp SEMICOLON . RCURLY
    RCURLY          shift and go to state 162


state 160

    (54) forloop -> FROM var ASSIGN expression TO expression BY expression . DO block
    DO              shift and go to state 163


state 161

    (55) forloop -> FROM var ASSIGN expression TO expression DO block .
    ID              reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    VARS            reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    FROM            reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    WHILE           reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    INPUT           reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    PRINT           reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    IF              reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RCURLY          reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)
    RETURN          reduce using rule 55 (forloop -> FROM var ASSIGN expression TO expression DO block .)


state 162

    (9) returnblock -> LCURLY blockcontent RETURN exp SEMICOLON RCURLY .
    FUNC            reduce using rule 9 (returnblock -> LCURLY blockcontent RETURN exp SEMICOLON RCURLY .)
    MAIN            reduce using rule 9 (returnblock -> LCURLY blockcontent RETURN exp SEMICOLON RCURLY .)


state 163

    (54) forloop -> FROM var ASSIGN expression TO expression BY expression DO . block
    (8) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 41

    block                          shift and go to state 164

state 164

    (54) forloop -> FROM var ASSIGN expression TO expression BY expression DO block .
    ID              reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    VARS            reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    FROM            reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    WHILE           reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    INPUT           reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    PRINT           reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    IF              reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RCURLY          reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
    RETURN          reduce using rule 54 (forloop -> FROM var ASSIGN expression TO expression BY expression DO block .)
