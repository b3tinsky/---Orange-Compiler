Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID saveprogramname declare
Rule 2     declare -> decvars decfuncs main_block
Rule 3     main_block -> MAIN changecontext LPAREN RPAREN declareblock
Rule 4     block -> LCURLY blockcontent RCURLY
Rule 5     declareblock -> LCURLY decvars blockcontent RCURLY
Rule 6     blockcontent -> empty
Rule 7     blockcontent -> statute blockcontent
Rule 8     decvars -> empty
Rule 9     decvars -> VARS decvar_line
Rule 10    decvar_line -> decvar_type decvar SEMICOLON decvar_line
Rule 11    decvar_line -> decvar_type decvar SEMICOLON
Rule 12    decvar_type -> type
Rule 13    decvar -> var COMMA decvar
Rule 14    decvar -> var
Rule 15    var -> BOOL
Rule 16    var -> FLOAT
Rule 17    var -> INT
Rule 18    var -> ELSE
Rule 19    var -> IF
Rule 20    var -> PRINT
Rule 21    var -> INPUT
Rule 22    var -> WHILE
Rule 23    var -> DO
Rule 24    var -> BY
Rule 25    var -> TO
Rule 26    var -> FROM
Rule 27    var -> VOID
Rule 28    var -> RETURN
Rule 29    var -> FUNC
Rule 30    var -> MAIN
Rule 31    var -> VARS
Rule 32    var -> PROGRAM
Rule 33    var -> ID add_id dim
Rule 34    add_id -> <empty>
Rule 35    dim -> empty
Rule 36    dim -> LBRACKET CTEINT COLON CTEINT RBRACKET dim
Rule 37    decfuncs -> empty
Rule 38    decfuncs -> func decfuncs
Rule 39    func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock
Rule 40    functype -> type
Rule 41    functype -> VOID
Rule 42    params -> empty
Rule 43    params -> param params_aux
Rule 44    param -> type ID
Rule 45    params_aux -> empty
Rule 46    params_aux -> COMMA params
Rule 47    call -> ID generate_era LPAREN callvalues RPAREN
Rule 48    generate_era -> <empty>
Rule 49    callvalues_aux -> empty
Rule 50    callvalues_aux -> COMMA callvalues
Rule 51    callvalue -> exp generate_param
Rule 52    callvalues -> empty
Rule 53    callvalues -> callvalue callvalues_aux
Rule 54    generate_param -> <empty>
Rule 55    super_exp_aux -> logic super_exp
Rule 56    super_exp_aux -> empty
Rule 57    super_exp -> expression super_exp_quadgen super_exp_aux
Rule 58    logic -> OR
Rule 59    logic -> AND
Rule 60    super_exp_quadgen -> <empty>
Rule 61    expression_aux -> relation expression
Rule 62    expression_aux -> empty
Rule 63    expression -> exp expression_quadgen expression_aux
Rule 64    relation -> NEQ
Rule 65    relation -> EQ
Rule 66    relation -> LTE
Rule 67    relation -> GTE
Rule 68    relation -> LT
Rule 69    relation -> GT
Rule 70    expression_quadgen -> <empty>
Rule 71    exp_aux -> exp_sign exp
Rule 72    exp_aux -> empty
Rule 73    exp -> term exp_quadgen exp_aux
Rule 74    exp_sign -> MINUS
Rule 75    exp_sign -> PLUS
Rule 76    exp_quadgen -> <empty>
Rule 77    term_aux -> term_sign term
Rule 78    term_aux -> empty
Rule 79    term -> factor term_quadgen term_aux
Rule 80    term_sign -> DIVIDE
Rule 81    term_sign -> TIMES
Rule 82    term_quadgen -> <empty>
Rule 83    factor -> LPAREN fakefloor super_exp RPAREN
Rule 84    factor -> varcte
Rule 85    factor -> var_access
Rule 86    factor -> call
Rule 87    var_access -> ID verify_id access_dim
Rule 88    var_access -> ID
Rule 89    verify_id -> <empty>
Rule 90    access_dim -> empty
Rule 91    access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim
Rule 92    verify_dim -> <empty>
Rule 93    fakefloor -> <empty>
Rule 94    forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
Rule 95    forloopcontrolvar -> ID
Rule 96    validatecontrolvar -> <empty>
Rule 97    createfinaltempvar -> <empty>
Rule 98    validateloopend -> <empty>
Rule 99    whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
Rule 100   dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
Rule 101   assignment -> var_access assignment_sign expression SEMICOLON
Rule 102   assignment_sign -> ASSIGN
Rule 103   read -> INPUT LPAREN readaux RPAREN SEMICOLON
Rule 104   readaux -> readvalue COMMA readaux
Rule 105   readaux -> readvalue
Rule 106   readvalue -> ID
Rule 107   write -> PRINT LPAREN writeaux RPAREN SEMICOLON
Rule 108   writeaux -> writevalues
Rule 109   writeaux -> writevalues COMMA writeaux
Rule 110   writevalues -> CTESTRING
Rule 111   writevalues -> super_exp
Rule 112   condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps
Rule 113   condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
Rule 114   openjumpslot -> <empty>
Rule 115   saveposition -> <empty>
Rule 116   filljumps -> <empty>
Rule 117   varcte -> CTEBOOL
Rule 118   varcte -> CTEFLOAT
Rule 119   varcte -> CTEINT
Rule 120   type -> BOOL
Rule 121   type -> FLOAT
Rule 122   type -> INT
Rule 123   returnstmt -> RETURN super_exp
Rule 124   statute -> returnstmt
Rule 125   statute -> call
Rule 126   statute -> forloop
Rule 127   statute -> dowhileloop
Rule 128   statute -> whileloop
Rule 129   statute -> read
Rule 130   statute -> write
Rule 131   statute -> condition
Rule 132   statute -> assignment
Rule 133   changecontext -> <empty>
Rule 134   saveprogramname -> <empty>
Rule 135   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 59
ASSIGN               : 102
BOOL                 : 15 120
BY                   : 24
COLON                : 36
COMMA                : 13 46 50 104 109
CTEBOOL              : 117
CTEFLOAT             : 118
CTEINT               : 36 36 119
CTESTRING            : 110
DIVIDE               : 80
DO                   : 23 94 100
ELSE                 : 18 113
EQ                   : 65
FLOAT                : 16 121
FROM                 : 26 94
FUNC                 : 29 39
GT                   : 69
GTE                  : 67
ID                   : 1 33 39 44 47 87 88 95 106
IF                   : 19 112 113
INPUT                : 21 103
INT                  : 17 122
LBRACKET             : 36 91
LCURLY               : 4 5
LPAREN               : 3 39 47 83 99 100 103 107 112 113
LT                   : 68
LTE                  : 66
MAIN                 : 3 30
MINUS                : 74
NEQ                  : 64
OR                   : 58
PLUS                 : 75
PRINT                : 20 107
PROGRAM              : 1 32
RBRACKET             : 36 91
RCURLY               : 4 5
RETURN               : 28 123
RPAREN               : 3 39 47 83 99 100 103 107 112 113
SEMICOLON            : 10 11 101 103 107
TIMES                : 81
TO                   : 25 94
VARS                 : 9 31
VOID                 : 27 41
WHILE                : 22 99 100
error                : 

Nonterminals, with rules where they appear:

access_dim           : 87 91
add_id               : 33
assignment           : 132
assignment_sign      : 94 101
block                : 94 99 100 112 113 113
blockcontent         : 4 5 7
call                 : 86 125
callvalue            : 53
callvalues           : 47 50
callvalues_aux       : 53
changecontext        : 3 39
condition            : 131
createfinaltempvar   : 94
decfuncs             : 2 38
declare              : 1
declareblock         : 3 39
decvar               : 10 11 13
decvar_line          : 9 10
decvar_type          : 10 11
decvars              : 2 5
dim                  : 33 36
dowhileloop          : 127
empty                : 6 8 35 37 42 45 49 52 56 62 72 78 90
exp                  : 51 63 71 91
exp_aux              : 73
exp_quadgen          : 73
exp_sign             : 71
expression           : 57 61 94 94 99 100 101
expression_aux       : 63
expression_quadgen   : 63
factor               : 79
fakefloor            : 83 91
filljumps            : 94 99 112 113 113
forloop              : 126
forloopcontrolvar    : 94
func                 : 38
functype             : 39
generate_era         : 47
generate_param       : 51
logic                : 55
main_block           : 2
openjumpslot         : 94 99 100 112 113 113
param                : 43
params               : 39 46
params_aux           : 43
program              : 0
read                 : 129
readaux              : 103 104
readvalue            : 104 105
relation             : 61
returnstmt           : 124
saveposition         : 99 100
saveprogramname      : 1
statute              : 7
super_exp            : 55 83 111 112 113 123
super_exp_aux        : 57
super_exp_quadgen    : 57
term                 : 73 77
term_aux             : 79
term_quadgen         : 79
term_sign            : 77
type                 : 12 40 44
validatecontrolvar   : 94
validateloopend      : 94
var                  : 13 14
var_access           : 85 101
varcte               : 84
verify_dim           : 91
verify_id            : 87
whileloop            : 128
write                : 130
writeaux             : 107 109
writevalues          : 108 109


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID saveprogramname declare
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . ID saveprogramname declare
    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . saveprogramname declare
    (134) saveprogramname -> .
    VARS            reduce using rule 134 (saveprogramname -> .)
    FUNC            reduce using rule 134 (saveprogramname -> .)
    MAIN            reduce using rule 134 (saveprogramname -> .)

    saveprogramname                shift and go to state 4

state 4

    (1) program -> PROGRAM ID saveprogramname . declare
    (2) declare -> . decvars decfuncs main_block
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (135) empty -> .
    VARS            shift and go to state 8
    FUNC            reduce using rule 135 (empty -> .)
    MAIN            reduce using rule 135 (empty -> .)

    declare                        shift and go to state 5
    decvars                        shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID saveprogramname declare .
    $end            reduce using rule 1 (program -> PROGRAM ID saveprogramname declare .)


state 6

    (2) declare -> decvars . decfuncs main_block
    (37) decfuncs -> . empty
    (38) decfuncs -> . func decfuncs
    (135) empty -> .
    (39) func -> . FUNC functype ID changecontext LPAREN params RPAREN declareblock
    MAIN            reduce using rule 135 (empty -> .)
    FUNC            shift and go to state 12

    decfuncs                       shift and go to state 9
    empty                          shift and go to state 10
    func                           shift and go to state 11

state 7

    (8) decvars -> empty .
    FUNC            reduce using rule 8 (decvars -> empty .)
    MAIN            reduce using rule 8 (decvars -> empty .)
    RETURN          reduce using rule 8 (decvars -> empty .)
    ID              reduce using rule 8 (decvars -> empty .)
    FROM            reduce using rule 8 (decvars -> empty .)
    DO              reduce using rule 8 (decvars -> empty .)
    WHILE           reduce using rule 8 (decvars -> empty .)
    INPUT           reduce using rule 8 (decvars -> empty .)
    PRINT           reduce using rule 8 (decvars -> empty .)
    IF              reduce using rule 8 (decvars -> empty .)
    RCURLY          reduce using rule 8 (decvars -> empty .)


state 8

    (9) decvars -> VARS . decvar_line
    (10) decvar_line -> . decvar_type decvar SEMICOLON decvar_line
    (11) decvar_line -> . decvar_type decvar SEMICOLON
    (12) decvar_type -> . type
    (120) type -> . BOOL
    (121) type -> . FLOAT
    (122) type -> . INT
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    decvar_line                    shift and go to state 13
    decvar_type                    shift and go to state 14
    type                           shift and go to state 15

state 9

    (2) declare -> decvars decfuncs . main_block
    (3) main_block -> . MAIN changecontext LPAREN RPAREN declareblock
    MAIN            shift and go to state 20

    main_block                     shift and go to state 19

state 10

    (37) decfuncs -> empty .
    MAIN            reduce using rule 37 (decfuncs -> empty .)


state 11

    (38) decfuncs -> func . decfuncs
    (37) decfuncs -> . empty
    (38) decfuncs -> . func decfuncs
    (135) empty -> .
    (39) func -> . FUNC functype ID changecontext LPAREN params RPAREN declareblock
    MAIN            reduce using rule 135 (empty -> .)
    FUNC            shift and go to state 12

    func                           shift and go to state 11
    decfuncs                       shift and go to state 21
    empty                          shift and go to state 10

state 12

    (39) func -> FUNC . functype ID changecontext LPAREN params RPAREN declareblock
    (40) functype -> . type
    (41) functype -> . VOID
    (120) type -> . BOOL
    (121) type -> . FLOAT
    (122) type -> . INT
    VOID            shift and go to state 24
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    functype                       shift and go to state 22
    type                           shift and go to state 23

state 13

    (9) decvars -> VARS decvar_line .
    FUNC            reduce using rule 9 (decvars -> VARS decvar_line .)
    MAIN            reduce using rule 9 (decvars -> VARS decvar_line .)
    RETURN          reduce using rule 9 (decvars -> VARS decvar_line .)
    ID              reduce using rule 9 (decvars -> VARS decvar_line .)
    FROM            reduce using rule 9 (decvars -> VARS decvar_line .)
    DO              reduce using rule 9 (decvars -> VARS decvar_line .)
    WHILE           reduce using rule 9 (decvars -> VARS decvar_line .)
    INPUT           reduce using rule 9 (decvars -> VARS decvar_line .)
    PRINT           reduce using rule 9 (decvars -> VARS decvar_line .)
    IF              reduce using rule 9 (decvars -> VARS decvar_line .)
    RCURLY          reduce using rule 9 (decvars -> VARS decvar_line .)


state 14

    (10) decvar_line -> decvar_type . decvar SEMICOLON decvar_line
    (11) decvar_line -> decvar_type . decvar SEMICOLON
    (13) decvar -> . var COMMA decvar
    (14) decvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID add_id dim
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    decvar                         shift and go to state 25
    var                            shift and go to state 26

state 15

    (12) decvar_type -> type .
    BOOL            reduce using rule 12 (decvar_type -> type .)
    FLOAT           reduce using rule 12 (decvar_type -> type .)
    INT             reduce using rule 12 (decvar_type -> type .)
    ELSE            reduce using rule 12 (decvar_type -> type .)
    IF              reduce using rule 12 (decvar_type -> type .)
    PRINT           reduce using rule 12 (decvar_type -> type .)
    INPUT           reduce using rule 12 (decvar_type -> type .)
    WHILE           reduce using rule 12 (decvar_type -> type .)
    DO              reduce using rule 12 (decvar_type -> type .)
    BY              reduce using rule 12 (decvar_type -> type .)
    TO              reduce using rule 12 (decvar_type -> type .)
    FROM            reduce using rule 12 (decvar_type -> type .)
    VOID            reduce using rule 12 (decvar_type -> type .)
    RETURN          reduce using rule 12 (decvar_type -> type .)
    FUNC            reduce using rule 12 (decvar_type -> type .)
    MAIN            reduce using rule 12 (decvar_type -> type .)
    VARS            reduce using rule 12 (decvar_type -> type .)
    PROGRAM         reduce using rule 12 (decvar_type -> type .)
    ID              reduce using rule 12 (decvar_type -> type .)


state 16

    (120) type -> BOOL .
    BOOL            reduce using rule 120 (type -> BOOL .)
    FLOAT           reduce using rule 120 (type -> BOOL .)
    INT             reduce using rule 120 (type -> BOOL .)
    ELSE            reduce using rule 120 (type -> BOOL .)
    IF              reduce using rule 120 (type -> BOOL .)
    PRINT           reduce using rule 120 (type -> BOOL .)
    INPUT           reduce using rule 120 (type -> BOOL .)
    WHILE           reduce using rule 120 (type -> BOOL .)
    DO              reduce using rule 120 (type -> BOOL .)
    BY              reduce using rule 120 (type -> BOOL .)
    TO              reduce using rule 120 (type -> BOOL .)
    FROM            reduce using rule 120 (type -> BOOL .)
    VOID            reduce using rule 120 (type -> BOOL .)
    RETURN          reduce using rule 120 (type -> BOOL .)
    FUNC            reduce using rule 120 (type -> BOOL .)
    MAIN            reduce using rule 120 (type -> BOOL .)
    VARS            reduce using rule 120 (type -> BOOL .)
    PROGRAM         reduce using rule 120 (type -> BOOL .)
    ID              reduce using rule 120 (type -> BOOL .)


state 17

    (121) type -> FLOAT .
    BOOL            reduce using rule 121 (type -> FLOAT .)
    FLOAT           reduce using rule 121 (type -> FLOAT .)
    INT             reduce using rule 121 (type -> FLOAT .)
    ELSE            reduce using rule 121 (type -> FLOAT .)
    IF              reduce using rule 121 (type -> FLOAT .)
    PRINT           reduce using rule 121 (type -> FLOAT .)
    INPUT           reduce using rule 121 (type -> FLOAT .)
    WHILE           reduce using rule 121 (type -> FLOAT .)
    DO              reduce using rule 121 (type -> FLOAT .)
    BY              reduce using rule 121 (type -> FLOAT .)
    TO              reduce using rule 121 (type -> FLOAT .)
    FROM            reduce using rule 121 (type -> FLOAT .)
    VOID            reduce using rule 121 (type -> FLOAT .)
    RETURN          reduce using rule 121 (type -> FLOAT .)
    FUNC            reduce using rule 121 (type -> FLOAT .)
    MAIN            reduce using rule 121 (type -> FLOAT .)
    VARS            reduce using rule 121 (type -> FLOAT .)
    PROGRAM         reduce using rule 121 (type -> FLOAT .)
    ID              reduce using rule 121 (type -> FLOAT .)


state 18

    (122) type -> INT .
    BOOL            reduce using rule 122 (type -> INT .)
    FLOAT           reduce using rule 122 (type -> INT .)
    INT             reduce using rule 122 (type -> INT .)
    ELSE            reduce using rule 122 (type -> INT .)
    IF              reduce using rule 122 (type -> INT .)
    PRINT           reduce using rule 122 (type -> INT .)
    INPUT           reduce using rule 122 (type -> INT .)
    WHILE           reduce using rule 122 (type -> INT .)
    DO              reduce using rule 122 (type -> INT .)
    BY              reduce using rule 122 (type -> INT .)
    TO              reduce using rule 122 (type -> INT .)
    FROM            reduce using rule 122 (type -> INT .)
    VOID            reduce using rule 122 (type -> INT .)
    RETURN          reduce using rule 122 (type -> INT .)
    FUNC            reduce using rule 122 (type -> INT .)
    MAIN            reduce using rule 122 (type -> INT .)
    VARS            reduce using rule 122 (type -> INT .)
    PROGRAM         reduce using rule 122 (type -> INT .)
    ID              reduce using rule 122 (type -> INT .)


state 19

    (2) declare -> decvars decfuncs main_block .
    $end            reduce using rule 2 (declare -> decvars decfuncs main_block .)


state 20

    (3) main_block -> MAIN . changecontext LPAREN RPAREN declareblock
    (133) changecontext -> .
    LPAREN          reduce using rule 133 (changecontext -> .)

    changecontext                  shift and go to state 46

state 21

    (38) decfuncs -> func decfuncs .
    MAIN            reduce using rule 38 (decfuncs -> func decfuncs .)


state 22

    (39) func -> FUNC functype . ID changecontext LPAREN params RPAREN declareblock
    ID              shift and go to state 47


state 23

    (40) functype -> type .
    ID              reduce using rule 40 (functype -> type .)


state 24

    (41) functype -> VOID .
    ID              reduce using rule 41 (functype -> VOID .)


state 25

    (10) decvar_line -> decvar_type decvar . SEMICOLON decvar_line
    (11) decvar_line -> decvar_type decvar . SEMICOLON
    SEMICOLON       shift and go to state 48


state 26

    (13) decvar -> var . COMMA decvar
    (14) decvar -> var .
    COMMA           shift and go to state 49
    SEMICOLON       reduce using rule 14 (decvar -> var .)


state 27

    (15) var -> BOOL .
    COMMA           reduce using rule 15 (var -> BOOL .)
    SEMICOLON       reduce using rule 15 (var -> BOOL .)


state 28

    (16) var -> FLOAT .
    COMMA           reduce using rule 16 (var -> FLOAT .)
    SEMICOLON       reduce using rule 16 (var -> FLOAT .)


state 29

    (17) var -> INT .
    COMMA           reduce using rule 17 (var -> INT .)
    SEMICOLON       reduce using rule 17 (var -> INT .)


state 30

    (18) var -> ELSE .
    COMMA           reduce using rule 18 (var -> ELSE .)
    SEMICOLON       reduce using rule 18 (var -> ELSE .)


state 31

    (19) var -> IF .
    COMMA           reduce using rule 19 (var -> IF .)
    SEMICOLON       reduce using rule 19 (var -> IF .)


state 32

    (20) var -> PRINT .
    COMMA           reduce using rule 20 (var -> PRINT .)
    SEMICOLON       reduce using rule 20 (var -> PRINT .)


state 33

    (21) var -> INPUT .
    COMMA           reduce using rule 21 (var -> INPUT .)
    SEMICOLON       reduce using rule 21 (var -> INPUT .)


state 34

    (22) var -> WHILE .
    COMMA           reduce using rule 22 (var -> WHILE .)
    SEMICOLON       reduce using rule 22 (var -> WHILE .)


state 35

    (23) var -> DO .
    COMMA           reduce using rule 23 (var -> DO .)
    SEMICOLON       reduce using rule 23 (var -> DO .)


state 36

    (24) var -> BY .
    COMMA           reduce using rule 24 (var -> BY .)
    SEMICOLON       reduce using rule 24 (var -> BY .)


state 37

    (25) var -> TO .
    COMMA           reduce using rule 25 (var -> TO .)
    SEMICOLON       reduce using rule 25 (var -> TO .)


state 38

    (26) var -> FROM .
    COMMA           reduce using rule 26 (var -> FROM .)
    SEMICOLON       reduce using rule 26 (var -> FROM .)


state 39

    (27) var -> VOID .
    COMMA           reduce using rule 27 (var -> VOID .)
    SEMICOLON       reduce using rule 27 (var -> VOID .)


state 40

    (28) var -> RETURN .
    COMMA           reduce using rule 28 (var -> RETURN .)
    SEMICOLON       reduce using rule 28 (var -> RETURN .)


state 41

    (29) var -> FUNC .
    COMMA           reduce using rule 29 (var -> FUNC .)
    SEMICOLON       reduce using rule 29 (var -> FUNC .)


state 42

    (30) var -> MAIN .
    COMMA           reduce using rule 30 (var -> MAIN .)
    SEMICOLON       reduce using rule 30 (var -> MAIN .)


state 43

    (31) var -> VARS .
    COMMA           reduce using rule 31 (var -> VARS .)
    SEMICOLON       reduce using rule 31 (var -> VARS .)


state 44

    (32) var -> PROGRAM .
    COMMA           reduce using rule 32 (var -> PROGRAM .)
    SEMICOLON       reduce using rule 32 (var -> PROGRAM .)


state 45

    (33) var -> ID . add_id dim
    (34) add_id -> .
    LBRACKET        reduce using rule 34 (add_id -> .)
    COMMA           reduce using rule 34 (add_id -> .)
    SEMICOLON       reduce using rule 34 (add_id -> .)

    add_id                         shift and go to state 50

state 46

    (3) main_block -> MAIN changecontext . LPAREN RPAREN declareblock
    LPAREN          shift and go to state 51


state 47

    (39) func -> FUNC functype ID . changecontext LPAREN params RPAREN declareblock
    (133) changecontext -> .
    LPAREN          reduce using rule 133 (changecontext -> .)

    changecontext                  shift and go to state 52

state 48

    (10) decvar_line -> decvar_type decvar SEMICOLON . decvar_line
    (11) decvar_line -> decvar_type decvar SEMICOLON .
    (10) decvar_line -> . decvar_type decvar SEMICOLON decvar_line
    (11) decvar_line -> . decvar_type decvar SEMICOLON
    (12) decvar_type -> . type
    (120) type -> . BOOL
    (121) type -> . FLOAT
    (122) type -> . INT
    FUNC            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    MAIN            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    RETURN          reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    ID              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    FROM            reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    DO              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    WHILE           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    INPUT           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    PRINT           reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    IF              reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    RCURLY          reduce using rule 11 (decvar_line -> decvar_type decvar SEMICOLON .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    decvar_type                    shift and go to state 14
    decvar_line                    shift and go to state 53
    type                           shift and go to state 15

state 49

    (13) decvar -> var COMMA . decvar
    (13) decvar -> . var COMMA decvar
    (14) decvar -> . var
    (15) var -> . BOOL
    (16) var -> . FLOAT
    (17) var -> . INT
    (18) var -> . ELSE
    (19) var -> . IF
    (20) var -> . PRINT
    (21) var -> . INPUT
    (22) var -> . WHILE
    (23) var -> . DO
    (24) var -> . BY
    (25) var -> . TO
    (26) var -> . FROM
    (27) var -> . VOID
    (28) var -> . RETURN
    (29) var -> . FUNC
    (30) var -> . MAIN
    (31) var -> . VARS
    (32) var -> . PROGRAM
    (33) var -> . ID add_id dim
    BOOL            shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    ELSE            shift and go to state 30
    IF              shift and go to state 31
    PRINT           shift and go to state 32
    INPUT           shift and go to state 33
    WHILE           shift and go to state 34
    DO              shift and go to state 35
    BY              shift and go to state 36
    TO              shift and go to state 37
    FROM            shift and go to state 38
    VOID            shift and go to state 39
    RETURN          shift and go to state 40
    FUNC            shift and go to state 41
    MAIN            shift and go to state 42
    VARS            shift and go to state 43
    PROGRAM         shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 26
    decvar                         shift and go to state 54

state 50

    (33) var -> ID add_id . dim
    (35) dim -> . empty
    (36) dim -> . LBRACKET CTEINT COLON CTEINT RBRACKET dim
    (135) empty -> .
    LBRACKET        shift and go to state 57
    COMMA           reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)

    dim                            shift and go to state 55
    empty                          shift and go to state 56

state 51

    (3) main_block -> MAIN changecontext LPAREN . RPAREN declareblock
    RPAREN          shift and go to state 58


state 52

    (39) func -> FUNC functype ID changecontext . LPAREN params RPAREN declareblock
    LPAREN          shift and go to state 59


state 53

    (10) decvar_line -> decvar_type decvar SEMICOLON decvar_line .
    FUNC            reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    MAIN            reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    RETURN          reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    ID              reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    FROM            reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    DO              reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    WHILE           reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    INPUT           reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    PRINT           reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    IF              reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)
    RCURLY          reduce using rule 10 (decvar_line -> decvar_type decvar SEMICOLON decvar_line .)


state 54

    (13) decvar -> var COMMA decvar .
    SEMICOLON       reduce using rule 13 (decvar -> var COMMA decvar .)


state 55

    (33) var -> ID add_id dim .
    COMMA           reduce using rule 33 (var -> ID add_id dim .)
    SEMICOLON       reduce using rule 33 (var -> ID add_id dim .)


state 56

    (35) dim -> empty .
    COMMA           reduce using rule 35 (dim -> empty .)
    SEMICOLON       reduce using rule 35 (dim -> empty .)


state 57

    (36) dim -> LBRACKET . CTEINT COLON CTEINT RBRACKET dim
    CTEINT          shift and go to state 60


state 58

    (3) main_block -> MAIN changecontext LPAREN RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 62

    declareblock                   shift and go to state 61

state 59

    (39) func -> FUNC functype ID changecontext LPAREN . params RPAREN declareblock
    (42) params -> . empty
    (43) params -> . param params_aux
    (135) empty -> .
    (44) param -> . type ID
    (120) type -> . BOOL
    (121) type -> . FLOAT
    (122) type -> . INT
    RPAREN          reduce using rule 135 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    params                         shift and go to state 63
    empty                          shift and go to state 64
    param                          shift and go to state 65
    type                           shift and go to state 66

state 60

    (36) dim -> LBRACKET CTEINT . COLON CTEINT RBRACKET dim
    COLON           shift and go to state 67


state 61

    (3) main_block -> MAIN changecontext LPAREN RPAREN declareblock .
    $end            reduce using rule 3 (main_block -> MAIN changecontext LPAREN RPAREN declareblock .)


state 62

    (5) declareblock -> LCURLY . decvars blockcontent RCURLY
    (8) decvars -> . empty
    (9) decvars -> . VARS decvar_line
    (135) empty -> .
    VARS            shift and go to state 8
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)

    decvars                        shift and go to state 68
    empty                          shift and go to state 7

state 63

    (39) func -> FUNC functype ID changecontext LPAREN params . RPAREN declareblock
    RPAREN          shift and go to state 69


state 64

    (42) params -> empty .
    RPAREN          reduce using rule 42 (params -> empty .)


state 65

    (43) params -> param . params_aux
    (45) params_aux -> . empty
    (46) params_aux -> . COMMA params
    (135) empty -> .
    COMMA           shift and go to state 72
    RPAREN          reduce using rule 135 (empty -> .)

    params_aux                     shift and go to state 70
    empty                          shift and go to state 71

state 66

    (44) param -> type . ID
    ID              shift and go to state 73


state 67

    (36) dim -> LBRACKET CTEINT COLON . CTEINT RBRACKET dim
    CTEINT          shift and go to state 74


state 68

    (5) declareblock -> LCURLY decvars . blockcontent RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (135) empty -> .
    (124) statute -> . returnstmt
    (125) statute -> . call
    (126) statute -> . forloop
    (127) statute -> . dowhileloop
    (128) statute -> . whileloop
    (129) statute -> . read
    (130) statute -> . write
    (131) statute -> . condition
    (132) statute -> . assignment
    (123) returnstmt -> . RETURN super_exp
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    (94) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (100) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (99) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (103) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (107) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (112) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (113) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (101) assignment -> . var_access assignment_sign expression SEMICOLON
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    RCURLY          reduce using rule 135 (empty -> .)
    RETURN          shift and go to state 87
    ID              shift and go to state 88
    FROM            shift and go to state 89
    DO              shift and go to state 90
    WHILE           shift and go to state 91
    INPUT           shift and go to state 92
    PRINT           shift and go to state 93
    IF              shift and go to state 94

    blockcontent                   shift and go to state 75
    empty                          shift and go to state 76
    statute                        shift and go to state 77
    returnstmt                     shift and go to state 78
    call                           shift and go to state 79
    forloop                        shift and go to state 80
    dowhileloop                    shift and go to state 81
    whileloop                      shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    condition                      shift and go to state 85
    assignment                     shift and go to state 86
    var_access                     shift and go to state 95

state 69

    (39) func -> FUNC functype ID changecontext LPAREN params RPAREN . declareblock
    (5) declareblock -> . LCURLY decvars blockcontent RCURLY
    LCURLY          shift and go to state 62

    declareblock                   shift and go to state 96

state 70

    (43) params -> param params_aux .
    RPAREN          reduce using rule 43 (params -> param params_aux .)


state 71

    (45) params_aux -> empty .
    RPAREN          reduce using rule 45 (params_aux -> empty .)


state 72

    (46) params_aux -> COMMA . params
    (42) params -> . empty
    (43) params -> . param params_aux
    (135) empty -> .
    (44) param -> . type ID
    (120) type -> . BOOL
    (121) type -> . FLOAT
    (122) type -> . INT
    RPAREN          reduce using rule 135 (empty -> .)
    BOOL            shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18

    params                         shift and go to state 97
    empty                          shift and go to state 64
    param                          shift and go to state 65
    type                           shift and go to state 66

state 73

    (44) param -> type ID .
    COMMA           reduce using rule 44 (param -> type ID .)
    RPAREN          reduce using rule 44 (param -> type ID .)


state 74

    (36) dim -> LBRACKET CTEINT COLON CTEINT . RBRACKET dim
    RBRACKET        shift and go to state 98


state 75

    (5) declareblock -> LCURLY decvars blockcontent . RCURLY
    RCURLY          shift and go to state 99


state 76

    (6) blockcontent -> empty .
    RCURLY          reduce using rule 6 (blockcontent -> empty .)


state 77

    (7) blockcontent -> statute . blockcontent
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (135) empty -> .
    (124) statute -> . returnstmt
    (125) statute -> . call
    (126) statute -> . forloop
    (127) statute -> . dowhileloop
    (128) statute -> . whileloop
    (129) statute -> . read
    (130) statute -> . write
    (131) statute -> . condition
    (132) statute -> . assignment
    (123) returnstmt -> . RETURN super_exp
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    (94) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (100) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (99) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (103) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (107) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (112) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (113) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (101) assignment -> . var_access assignment_sign expression SEMICOLON
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    RCURLY          reduce using rule 135 (empty -> .)
    RETURN          shift and go to state 87
    ID              shift and go to state 88
    FROM            shift and go to state 89
    DO              shift and go to state 90
    WHILE           shift and go to state 91
    INPUT           shift and go to state 92
    PRINT           shift and go to state 93
    IF              shift and go to state 94

    statute                        shift and go to state 77
    blockcontent                   shift and go to state 100
    empty                          shift and go to state 76
    returnstmt                     shift and go to state 78
    call                           shift and go to state 79
    forloop                        shift and go to state 80
    dowhileloop                    shift and go to state 81
    whileloop                      shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    condition                      shift and go to state 85
    assignment                     shift and go to state 86
    var_access                     shift and go to state 95

state 78

    (124) statute -> returnstmt .
    RETURN          reduce using rule 124 (statute -> returnstmt .)
    ID              reduce using rule 124 (statute -> returnstmt .)
    FROM            reduce using rule 124 (statute -> returnstmt .)
    DO              reduce using rule 124 (statute -> returnstmt .)
    WHILE           reduce using rule 124 (statute -> returnstmt .)
    INPUT           reduce using rule 124 (statute -> returnstmt .)
    PRINT           reduce using rule 124 (statute -> returnstmt .)
    IF              reduce using rule 124 (statute -> returnstmt .)
    RCURLY          reduce using rule 124 (statute -> returnstmt .)


state 79

    (125) statute -> call .
    RETURN          reduce using rule 125 (statute -> call .)
    ID              reduce using rule 125 (statute -> call .)
    FROM            reduce using rule 125 (statute -> call .)
    DO              reduce using rule 125 (statute -> call .)
    WHILE           reduce using rule 125 (statute -> call .)
    INPUT           reduce using rule 125 (statute -> call .)
    PRINT           reduce using rule 125 (statute -> call .)
    IF              reduce using rule 125 (statute -> call .)
    RCURLY          reduce using rule 125 (statute -> call .)


state 80

    (126) statute -> forloop .
    RETURN          reduce using rule 126 (statute -> forloop .)
    ID              reduce using rule 126 (statute -> forloop .)
    FROM            reduce using rule 126 (statute -> forloop .)
    DO              reduce using rule 126 (statute -> forloop .)
    WHILE           reduce using rule 126 (statute -> forloop .)
    INPUT           reduce using rule 126 (statute -> forloop .)
    PRINT           reduce using rule 126 (statute -> forloop .)
    IF              reduce using rule 126 (statute -> forloop .)
    RCURLY          reduce using rule 126 (statute -> forloop .)


state 81

    (127) statute -> dowhileloop .
    RETURN          reduce using rule 127 (statute -> dowhileloop .)
    ID              reduce using rule 127 (statute -> dowhileloop .)
    FROM            reduce using rule 127 (statute -> dowhileloop .)
    DO              reduce using rule 127 (statute -> dowhileloop .)
    WHILE           reduce using rule 127 (statute -> dowhileloop .)
    INPUT           reduce using rule 127 (statute -> dowhileloop .)
    PRINT           reduce using rule 127 (statute -> dowhileloop .)
    IF              reduce using rule 127 (statute -> dowhileloop .)
    RCURLY          reduce using rule 127 (statute -> dowhileloop .)


state 82

    (128) statute -> whileloop .
    RETURN          reduce using rule 128 (statute -> whileloop .)
    ID              reduce using rule 128 (statute -> whileloop .)
    FROM            reduce using rule 128 (statute -> whileloop .)
    DO              reduce using rule 128 (statute -> whileloop .)
    WHILE           reduce using rule 128 (statute -> whileloop .)
    INPUT           reduce using rule 128 (statute -> whileloop .)
    PRINT           reduce using rule 128 (statute -> whileloop .)
    IF              reduce using rule 128 (statute -> whileloop .)
    RCURLY          reduce using rule 128 (statute -> whileloop .)


state 83

    (129) statute -> read .
    RETURN          reduce using rule 129 (statute -> read .)
    ID              reduce using rule 129 (statute -> read .)
    FROM            reduce using rule 129 (statute -> read .)
    DO              reduce using rule 129 (statute -> read .)
    WHILE           reduce using rule 129 (statute -> read .)
    INPUT           reduce using rule 129 (statute -> read .)
    PRINT           reduce using rule 129 (statute -> read .)
    IF              reduce using rule 129 (statute -> read .)
    RCURLY          reduce using rule 129 (statute -> read .)


state 84

    (130) statute -> write .
    RETURN          reduce using rule 130 (statute -> write .)
    ID              reduce using rule 130 (statute -> write .)
    FROM            reduce using rule 130 (statute -> write .)
    DO              reduce using rule 130 (statute -> write .)
    WHILE           reduce using rule 130 (statute -> write .)
    INPUT           reduce using rule 130 (statute -> write .)
    PRINT           reduce using rule 130 (statute -> write .)
    IF              reduce using rule 130 (statute -> write .)
    RCURLY          reduce using rule 130 (statute -> write .)


state 85

    (131) statute -> condition .
    RETURN          reduce using rule 131 (statute -> condition .)
    ID              reduce using rule 131 (statute -> condition .)
    FROM            reduce using rule 131 (statute -> condition .)
    DO              reduce using rule 131 (statute -> condition .)
    WHILE           reduce using rule 131 (statute -> condition .)
    INPUT           reduce using rule 131 (statute -> condition .)
    PRINT           reduce using rule 131 (statute -> condition .)
    IF              reduce using rule 131 (statute -> condition .)
    RCURLY          reduce using rule 131 (statute -> condition .)


state 86

    (132) statute -> assignment .
    RETURN          reduce using rule 132 (statute -> assignment .)
    ID              reduce using rule 132 (statute -> assignment .)
    FROM            reduce using rule 132 (statute -> assignment .)
    DO              reduce using rule 132 (statute -> assignment .)
    WHILE           reduce using rule 132 (statute -> assignment .)
    INPUT           reduce using rule 132 (statute -> assignment .)
    PRINT           reduce using rule 132 (statute -> assignment .)
    IF              reduce using rule 132 (statute -> assignment .)
    RCURLY          reduce using rule 132 (statute -> assignment .)


state 87

    (123) returnstmt -> RETURN . super_exp
    (57) super_exp -> . expression super_exp_quadgen super_exp_aux
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    super_exp                      shift and go to state 101
    expression                     shift and go to state 102
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 88

    (47) call -> ID . generate_era LPAREN callvalues RPAREN
    (87) var_access -> ID . verify_id access_dim
    (88) var_access -> ID .
    (48) generate_era -> .
    (89) verify_id -> .
  ! reduce/reduce conflict for ASSIGN resolved using rule 88 (var_access -> ID .)
    ASSIGN          reduce using rule 88 (var_access -> ID .)
    LPAREN          reduce using rule 48 (generate_era -> .)
    LBRACKET        reduce using rule 89 (verify_id -> .)

    generate_era                   shift and go to state 114
    verify_id                      shift and go to state 115

state 89

    (94) forloop -> FROM . forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (95) forloopcontrolvar -> . ID
    ID              shift and go to state 117

    forloopcontrolvar              shift and go to state 116

state 90

    (100) dowhileloop -> DO . saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (115) saveposition -> .
    LCURLY          reduce using rule 115 (saveposition -> .)

    saveposition                   shift and go to state 118

state 91

    (99) whileloop -> WHILE . saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (115) saveposition -> .
    LPAREN          reduce using rule 115 (saveposition -> .)

    saveposition                   shift and go to state 119

state 92

    (103) read -> INPUT . LPAREN readaux RPAREN SEMICOLON
    LPAREN          shift and go to state 120


state 93

    (107) write -> PRINT . LPAREN writeaux RPAREN SEMICOLON
    LPAREN          shift and go to state 121


state 94

    (112) condition -> IF . LPAREN super_exp RPAREN openjumpslot block filljumps
    (113) condition -> IF . LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    LPAREN          shift and go to state 122


state 95

    (101) assignment -> var_access . assignment_sign expression SEMICOLON
    (102) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 124

    assignment_sign                shift and go to state 123

state 96

    (39) func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock .
    FUNC            reduce using rule 39 (func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock .)
    MAIN            reduce using rule 39 (func -> FUNC functype ID changecontext LPAREN params RPAREN declareblock .)


state 97

    (46) params_aux -> COMMA params .
    RPAREN          reduce using rule 46 (params_aux -> COMMA params .)


state 98

    (36) dim -> LBRACKET CTEINT COLON CTEINT RBRACKET . dim
    (35) dim -> . empty
    (36) dim -> . LBRACKET CTEINT COLON CTEINT RBRACKET dim
    (135) empty -> .
    LBRACKET        shift and go to state 57
    COMMA           reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)

    dim                            shift and go to state 125
    empty                          shift and go to state 56

state 99

    (5) declareblock -> LCURLY decvars blockcontent RCURLY .
    $end            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    FUNC            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)
    MAIN            reduce using rule 5 (declareblock -> LCURLY decvars blockcontent RCURLY .)


state 100

    (7) blockcontent -> statute blockcontent .
    RCURLY          reduce using rule 7 (blockcontent -> statute blockcontent .)


state 101

    (123) returnstmt -> RETURN super_exp .
    RETURN          reduce using rule 123 (returnstmt -> RETURN super_exp .)
    ID              reduce using rule 123 (returnstmt -> RETURN super_exp .)
    FROM            reduce using rule 123 (returnstmt -> RETURN super_exp .)
    DO              reduce using rule 123 (returnstmt -> RETURN super_exp .)
    WHILE           reduce using rule 123 (returnstmt -> RETURN super_exp .)
    INPUT           reduce using rule 123 (returnstmt -> RETURN super_exp .)
    PRINT           reduce using rule 123 (returnstmt -> RETURN super_exp .)
    IF              reduce using rule 123 (returnstmt -> RETURN super_exp .)
    RCURLY          reduce using rule 123 (returnstmt -> RETURN super_exp .)


state 102

    (57) super_exp -> expression . super_exp_quadgen super_exp_aux
    (60) super_exp_quadgen -> .
    OR              reduce using rule 60 (super_exp_quadgen -> .)
    AND             reduce using rule 60 (super_exp_quadgen -> .)
    RETURN          reduce using rule 60 (super_exp_quadgen -> .)
    ID              reduce using rule 60 (super_exp_quadgen -> .)
    FROM            reduce using rule 60 (super_exp_quadgen -> .)
    DO              reduce using rule 60 (super_exp_quadgen -> .)
    WHILE           reduce using rule 60 (super_exp_quadgen -> .)
    INPUT           reduce using rule 60 (super_exp_quadgen -> .)
    PRINT           reduce using rule 60 (super_exp_quadgen -> .)
    IF              reduce using rule 60 (super_exp_quadgen -> .)
    RCURLY          reduce using rule 60 (super_exp_quadgen -> .)
    COMMA           reduce using rule 60 (super_exp_quadgen -> .)
    RPAREN          reduce using rule 60 (super_exp_quadgen -> .)

    super_exp_quadgen              shift and go to state 126

state 103

    (63) expression -> exp . expression_quadgen expression_aux
    (70) expression_quadgen -> .
    NEQ             reduce using rule 70 (expression_quadgen -> .)
    EQ              reduce using rule 70 (expression_quadgen -> .)
    LTE             reduce using rule 70 (expression_quadgen -> .)
    GTE             reduce using rule 70 (expression_quadgen -> .)
    LT              reduce using rule 70 (expression_quadgen -> .)
    GT              reduce using rule 70 (expression_quadgen -> .)
    OR              reduce using rule 70 (expression_quadgen -> .)
    AND             reduce using rule 70 (expression_quadgen -> .)
    RETURN          reduce using rule 70 (expression_quadgen -> .)
    ID              reduce using rule 70 (expression_quadgen -> .)
    FROM            reduce using rule 70 (expression_quadgen -> .)
    DO              reduce using rule 70 (expression_quadgen -> .)
    WHILE           reduce using rule 70 (expression_quadgen -> .)
    INPUT           reduce using rule 70 (expression_quadgen -> .)
    PRINT           reduce using rule 70 (expression_quadgen -> .)
    IF              reduce using rule 70 (expression_quadgen -> .)
    RCURLY          reduce using rule 70 (expression_quadgen -> .)
    COMMA           reduce using rule 70 (expression_quadgen -> .)
    RPAREN          reduce using rule 70 (expression_quadgen -> .)
    SEMICOLON       reduce using rule 70 (expression_quadgen -> .)
    TO              reduce using rule 70 (expression_quadgen -> .)

    expression_quadgen             shift and go to state 127

state 104

    (73) exp -> term . exp_quadgen exp_aux
    (76) exp_quadgen -> .
    MINUS           reduce using rule 76 (exp_quadgen -> .)
    PLUS            reduce using rule 76 (exp_quadgen -> .)
    NEQ             reduce using rule 76 (exp_quadgen -> .)
    EQ              reduce using rule 76 (exp_quadgen -> .)
    LTE             reduce using rule 76 (exp_quadgen -> .)
    GTE             reduce using rule 76 (exp_quadgen -> .)
    LT              reduce using rule 76 (exp_quadgen -> .)
    GT              reduce using rule 76 (exp_quadgen -> .)
    OR              reduce using rule 76 (exp_quadgen -> .)
    AND             reduce using rule 76 (exp_quadgen -> .)
    RETURN          reduce using rule 76 (exp_quadgen -> .)
    ID              reduce using rule 76 (exp_quadgen -> .)
    FROM            reduce using rule 76 (exp_quadgen -> .)
    DO              reduce using rule 76 (exp_quadgen -> .)
    WHILE           reduce using rule 76 (exp_quadgen -> .)
    INPUT           reduce using rule 76 (exp_quadgen -> .)
    PRINT           reduce using rule 76 (exp_quadgen -> .)
    IF              reduce using rule 76 (exp_quadgen -> .)
    RCURLY          reduce using rule 76 (exp_quadgen -> .)
    COMMA           reduce using rule 76 (exp_quadgen -> .)
    RPAREN          reduce using rule 76 (exp_quadgen -> .)
    SEMICOLON       reduce using rule 76 (exp_quadgen -> .)
    TO              reduce using rule 76 (exp_quadgen -> .)
    RBRACKET        reduce using rule 76 (exp_quadgen -> .)

    exp_quadgen                    shift and go to state 128

state 105

    (79) term -> factor . term_quadgen term_aux
    (82) term_quadgen -> .
    DIVIDE          reduce using rule 82 (term_quadgen -> .)
    TIMES           reduce using rule 82 (term_quadgen -> .)
    MINUS           reduce using rule 82 (term_quadgen -> .)
    PLUS            reduce using rule 82 (term_quadgen -> .)
    NEQ             reduce using rule 82 (term_quadgen -> .)
    EQ              reduce using rule 82 (term_quadgen -> .)
    LTE             reduce using rule 82 (term_quadgen -> .)
    GTE             reduce using rule 82 (term_quadgen -> .)
    LT              reduce using rule 82 (term_quadgen -> .)
    GT              reduce using rule 82 (term_quadgen -> .)
    OR              reduce using rule 82 (term_quadgen -> .)
    AND             reduce using rule 82 (term_quadgen -> .)
    RETURN          reduce using rule 82 (term_quadgen -> .)
    ID              reduce using rule 82 (term_quadgen -> .)
    FROM            reduce using rule 82 (term_quadgen -> .)
    DO              reduce using rule 82 (term_quadgen -> .)
    WHILE           reduce using rule 82 (term_quadgen -> .)
    INPUT           reduce using rule 82 (term_quadgen -> .)
    PRINT           reduce using rule 82 (term_quadgen -> .)
    IF              reduce using rule 82 (term_quadgen -> .)
    RCURLY          reduce using rule 82 (term_quadgen -> .)
    COMMA           reduce using rule 82 (term_quadgen -> .)
    RPAREN          reduce using rule 82 (term_quadgen -> .)
    SEMICOLON       reduce using rule 82 (term_quadgen -> .)
    TO              reduce using rule 82 (term_quadgen -> .)
    RBRACKET        reduce using rule 82 (term_quadgen -> .)

    term_quadgen                   shift and go to state 129

state 106

    (83) factor -> LPAREN . fakefloor super_exp RPAREN
    (93) fakefloor -> .
    LPAREN          reduce using rule 93 (fakefloor -> .)
    CTEBOOL         reduce using rule 93 (fakefloor -> .)
    CTEFLOAT        reduce using rule 93 (fakefloor -> .)
    CTEINT          reduce using rule 93 (fakefloor -> .)
    ID              reduce using rule 93 (fakefloor -> .)

    fakefloor                      shift and go to state 130

state 107

    (84) factor -> varcte .
    DIVIDE          reduce using rule 84 (factor -> varcte .)
    TIMES           reduce using rule 84 (factor -> varcte .)
    MINUS           reduce using rule 84 (factor -> varcte .)
    PLUS            reduce using rule 84 (factor -> varcte .)
    NEQ             reduce using rule 84 (factor -> varcte .)
    EQ              reduce using rule 84 (factor -> varcte .)
    LTE             reduce using rule 84 (factor -> varcte .)
    GTE             reduce using rule 84 (factor -> varcte .)
    LT              reduce using rule 84 (factor -> varcte .)
    GT              reduce using rule 84 (factor -> varcte .)
    OR              reduce using rule 84 (factor -> varcte .)
    AND             reduce using rule 84 (factor -> varcte .)
    RETURN          reduce using rule 84 (factor -> varcte .)
    ID              reduce using rule 84 (factor -> varcte .)
    FROM            reduce using rule 84 (factor -> varcte .)
    DO              reduce using rule 84 (factor -> varcte .)
    WHILE           reduce using rule 84 (factor -> varcte .)
    INPUT           reduce using rule 84 (factor -> varcte .)
    PRINT           reduce using rule 84 (factor -> varcte .)
    IF              reduce using rule 84 (factor -> varcte .)
    RCURLY          reduce using rule 84 (factor -> varcte .)
    COMMA           reduce using rule 84 (factor -> varcte .)
    RPAREN          reduce using rule 84 (factor -> varcte .)
    SEMICOLON       reduce using rule 84 (factor -> varcte .)
    TO              reduce using rule 84 (factor -> varcte .)
    RBRACKET        reduce using rule 84 (factor -> varcte .)


state 108

    (85) factor -> var_access .
    DIVIDE          reduce using rule 85 (factor -> var_access .)
    TIMES           reduce using rule 85 (factor -> var_access .)
    MINUS           reduce using rule 85 (factor -> var_access .)
    PLUS            reduce using rule 85 (factor -> var_access .)
    NEQ             reduce using rule 85 (factor -> var_access .)
    EQ              reduce using rule 85 (factor -> var_access .)
    LTE             reduce using rule 85 (factor -> var_access .)
    GTE             reduce using rule 85 (factor -> var_access .)
    LT              reduce using rule 85 (factor -> var_access .)
    GT              reduce using rule 85 (factor -> var_access .)
    OR              reduce using rule 85 (factor -> var_access .)
    AND             reduce using rule 85 (factor -> var_access .)
    RETURN          reduce using rule 85 (factor -> var_access .)
    ID              reduce using rule 85 (factor -> var_access .)
    FROM            reduce using rule 85 (factor -> var_access .)
    DO              reduce using rule 85 (factor -> var_access .)
    WHILE           reduce using rule 85 (factor -> var_access .)
    INPUT           reduce using rule 85 (factor -> var_access .)
    PRINT           reduce using rule 85 (factor -> var_access .)
    IF              reduce using rule 85 (factor -> var_access .)
    RCURLY          reduce using rule 85 (factor -> var_access .)
    COMMA           reduce using rule 85 (factor -> var_access .)
    RPAREN          reduce using rule 85 (factor -> var_access .)
    SEMICOLON       reduce using rule 85 (factor -> var_access .)
    TO              reduce using rule 85 (factor -> var_access .)
    RBRACKET        reduce using rule 85 (factor -> var_access .)


state 109

    (86) factor -> call .
    DIVIDE          reduce using rule 86 (factor -> call .)
    TIMES           reduce using rule 86 (factor -> call .)
    MINUS           reduce using rule 86 (factor -> call .)
    PLUS            reduce using rule 86 (factor -> call .)
    NEQ             reduce using rule 86 (factor -> call .)
    EQ              reduce using rule 86 (factor -> call .)
    LTE             reduce using rule 86 (factor -> call .)
    GTE             reduce using rule 86 (factor -> call .)
    LT              reduce using rule 86 (factor -> call .)
    GT              reduce using rule 86 (factor -> call .)
    OR              reduce using rule 86 (factor -> call .)
    AND             reduce using rule 86 (factor -> call .)
    RETURN          reduce using rule 86 (factor -> call .)
    ID              reduce using rule 86 (factor -> call .)
    FROM            reduce using rule 86 (factor -> call .)
    DO              reduce using rule 86 (factor -> call .)
    WHILE           reduce using rule 86 (factor -> call .)
    INPUT           reduce using rule 86 (factor -> call .)
    PRINT           reduce using rule 86 (factor -> call .)
    IF              reduce using rule 86 (factor -> call .)
    RCURLY          reduce using rule 86 (factor -> call .)
    COMMA           reduce using rule 86 (factor -> call .)
    RPAREN          reduce using rule 86 (factor -> call .)
    SEMICOLON       reduce using rule 86 (factor -> call .)
    TO              reduce using rule 86 (factor -> call .)
    RBRACKET        reduce using rule 86 (factor -> call .)


state 110

    (117) varcte -> CTEBOOL .
    DIVIDE          reduce using rule 117 (varcte -> CTEBOOL .)
    TIMES           reduce using rule 117 (varcte -> CTEBOOL .)
    MINUS           reduce using rule 117 (varcte -> CTEBOOL .)
    PLUS            reduce using rule 117 (varcte -> CTEBOOL .)
    NEQ             reduce using rule 117 (varcte -> CTEBOOL .)
    EQ              reduce using rule 117 (varcte -> CTEBOOL .)
    LTE             reduce using rule 117 (varcte -> CTEBOOL .)
    GTE             reduce using rule 117 (varcte -> CTEBOOL .)
    LT              reduce using rule 117 (varcte -> CTEBOOL .)
    GT              reduce using rule 117 (varcte -> CTEBOOL .)
    OR              reduce using rule 117 (varcte -> CTEBOOL .)
    AND             reduce using rule 117 (varcte -> CTEBOOL .)
    RETURN          reduce using rule 117 (varcte -> CTEBOOL .)
    ID              reduce using rule 117 (varcte -> CTEBOOL .)
    FROM            reduce using rule 117 (varcte -> CTEBOOL .)
    DO              reduce using rule 117 (varcte -> CTEBOOL .)
    WHILE           reduce using rule 117 (varcte -> CTEBOOL .)
    INPUT           reduce using rule 117 (varcte -> CTEBOOL .)
    PRINT           reduce using rule 117 (varcte -> CTEBOOL .)
    IF              reduce using rule 117 (varcte -> CTEBOOL .)
    RCURLY          reduce using rule 117 (varcte -> CTEBOOL .)
    COMMA           reduce using rule 117 (varcte -> CTEBOOL .)
    RPAREN          reduce using rule 117 (varcte -> CTEBOOL .)
    SEMICOLON       reduce using rule 117 (varcte -> CTEBOOL .)
    TO              reduce using rule 117 (varcte -> CTEBOOL .)
    RBRACKET        reduce using rule 117 (varcte -> CTEBOOL .)


state 111

    (118) varcte -> CTEFLOAT .
    DIVIDE          reduce using rule 118 (varcte -> CTEFLOAT .)
    TIMES           reduce using rule 118 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 118 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 118 (varcte -> CTEFLOAT .)
    NEQ             reduce using rule 118 (varcte -> CTEFLOAT .)
    EQ              reduce using rule 118 (varcte -> CTEFLOAT .)
    LTE             reduce using rule 118 (varcte -> CTEFLOAT .)
    GTE             reduce using rule 118 (varcte -> CTEFLOAT .)
    LT              reduce using rule 118 (varcte -> CTEFLOAT .)
    GT              reduce using rule 118 (varcte -> CTEFLOAT .)
    OR              reduce using rule 118 (varcte -> CTEFLOAT .)
    AND             reduce using rule 118 (varcte -> CTEFLOAT .)
    RETURN          reduce using rule 118 (varcte -> CTEFLOAT .)
    ID              reduce using rule 118 (varcte -> CTEFLOAT .)
    FROM            reduce using rule 118 (varcte -> CTEFLOAT .)
    DO              reduce using rule 118 (varcte -> CTEFLOAT .)
    WHILE           reduce using rule 118 (varcte -> CTEFLOAT .)
    INPUT           reduce using rule 118 (varcte -> CTEFLOAT .)
    PRINT           reduce using rule 118 (varcte -> CTEFLOAT .)
    IF              reduce using rule 118 (varcte -> CTEFLOAT .)
    RCURLY          reduce using rule 118 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 118 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 118 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 118 (varcte -> CTEFLOAT .)
    TO              reduce using rule 118 (varcte -> CTEFLOAT .)
    RBRACKET        reduce using rule 118 (varcte -> CTEFLOAT .)


state 112

    (119) varcte -> CTEINT .
    DIVIDE          reduce using rule 119 (varcte -> CTEINT .)
    TIMES           reduce using rule 119 (varcte -> CTEINT .)
    MINUS           reduce using rule 119 (varcte -> CTEINT .)
    PLUS            reduce using rule 119 (varcte -> CTEINT .)
    NEQ             reduce using rule 119 (varcte -> CTEINT .)
    EQ              reduce using rule 119 (varcte -> CTEINT .)
    LTE             reduce using rule 119 (varcte -> CTEINT .)
    GTE             reduce using rule 119 (varcte -> CTEINT .)
    LT              reduce using rule 119 (varcte -> CTEINT .)
    GT              reduce using rule 119 (varcte -> CTEINT .)
    OR              reduce using rule 119 (varcte -> CTEINT .)
    AND             reduce using rule 119 (varcte -> CTEINT .)
    RETURN          reduce using rule 119 (varcte -> CTEINT .)
    ID              reduce using rule 119 (varcte -> CTEINT .)
    FROM            reduce using rule 119 (varcte -> CTEINT .)
    DO              reduce using rule 119 (varcte -> CTEINT .)
    WHILE           reduce using rule 119 (varcte -> CTEINT .)
    INPUT           reduce using rule 119 (varcte -> CTEINT .)
    PRINT           reduce using rule 119 (varcte -> CTEINT .)
    IF              reduce using rule 119 (varcte -> CTEINT .)
    RCURLY          reduce using rule 119 (varcte -> CTEINT .)
    COMMA           reduce using rule 119 (varcte -> CTEINT .)
    RPAREN          reduce using rule 119 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 119 (varcte -> CTEINT .)
    TO              reduce using rule 119 (varcte -> CTEINT .)
    RBRACKET        reduce using rule 119 (varcte -> CTEINT .)


state 113

    (87) var_access -> ID . verify_id access_dim
    (88) var_access -> ID .
    (47) call -> ID . generate_era LPAREN callvalues RPAREN
    (89) verify_id -> .
    (48) generate_era -> .
  ! reduce/reduce conflict for DIVIDE resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for NEQ resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for EQ resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for LTE resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for GTE resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for LT resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for GT resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for FROM resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for DO resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for INPUT resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for RCURLY resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 88 (var_access -> ID .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 88 (var_access -> ID .)
    DIVIDE          reduce using rule 88 (var_access -> ID .)
    TIMES           reduce using rule 88 (var_access -> ID .)
    MINUS           reduce using rule 88 (var_access -> ID .)
    PLUS            reduce using rule 88 (var_access -> ID .)
    NEQ             reduce using rule 88 (var_access -> ID .)
    EQ              reduce using rule 88 (var_access -> ID .)
    LTE             reduce using rule 88 (var_access -> ID .)
    GTE             reduce using rule 88 (var_access -> ID .)
    LT              reduce using rule 88 (var_access -> ID .)
    GT              reduce using rule 88 (var_access -> ID .)
    OR              reduce using rule 88 (var_access -> ID .)
    AND             reduce using rule 88 (var_access -> ID .)
    RETURN          reduce using rule 88 (var_access -> ID .)
    ID              reduce using rule 88 (var_access -> ID .)
    FROM            reduce using rule 88 (var_access -> ID .)
    DO              reduce using rule 88 (var_access -> ID .)
    WHILE           reduce using rule 88 (var_access -> ID .)
    INPUT           reduce using rule 88 (var_access -> ID .)
    PRINT           reduce using rule 88 (var_access -> ID .)
    IF              reduce using rule 88 (var_access -> ID .)
    RCURLY          reduce using rule 88 (var_access -> ID .)
    COMMA           reduce using rule 88 (var_access -> ID .)
    RPAREN          reduce using rule 88 (var_access -> ID .)
    SEMICOLON       reduce using rule 88 (var_access -> ID .)
    TO              reduce using rule 88 (var_access -> ID .)
    RBRACKET        reduce using rule 88 (var_access -> ID .)
    LBRACKET        reduce using rule 89 (verify_id -> .)
    LPAREN          reduce using rule 48 (generate_era -> .)

    verify_id                      shift and go to state 115
    generate_era                   shift and go to state 114

state 114

    (47) call -> ID generate_era . LPAREN callvalues RPAREN
    LPAREN          shift and go to state 131


state 115

    (87) var_access -> ID verify_id . access_dim
    (90) access_dim -> . empty
    (91) access_dim -> . fakefloor LBRACKET exp RBRACKET verify_dim access_dim
    (135) empty -> .
    (93) fakefloor -> .
    ASSIGN          reduce using rule 135 (empty -> .)
    DIVIDE          reduce using rule 135 (empty -> .)
    TIMES           reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    EQ              reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    LBRACKET        reduce using rule 93 (fakefloor -> .)

    access_dim                     shift and go to state 132
    empty                          shift and go to state 133
    fakefloor                      shift and go to state 134

state 116

    (94) forloop -> FROM forloopcontrolvar . assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (102) assignment_sign -> . ASSIGN
    ASSIGN          shift and go to state 124

    assignment_sign                shift and go to state 135

state 117

    (95) forloopcontrolvar -> ID .
    ASSIGN          reduce using rule 95 (forloopcontrolvar -> ID .)


state 118

    (100) dowhileloop -> DO saveposition . block WHILE LPAREN expression RPAREN openjumpslot
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 137

    block                          shift and go to state 136

state 119

    (99) whileloop -> WHILE saveposition . LPAREN expression RPAREN openjumpslot block filljumps
    LPAREN          shift and go to state 138


state 120

    (103) read -> INPUT LPAREN . readaux RPAREN SEMICOLON
    (104) readaux -> . readvalue COMMA readaux
    (105) readaux -> . readvalue
    (106) readvalue -> . ID
    ID              shift and go to state 141

    readaux                        shift and go to state 139
    readvalue                      shift and go to state 140

state 121

    (107) write -> PRINT LPAREN . writeaux RPAREN SEMICOLON
    (108) writeaux -> . writevalues
    (109) writeaux -> . writevalues COMMA writeaux
    (110) writevalues -> . CTESTRING
    (111) writevalues -> . super_exp
    (57) super_exp -> . expression super_exp_quadgen super_exp_aux
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    CTESTRING       shift and go to state 144
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    writeaux                       shift and go to state 142
    writevalues                    shift and go to state 143
    super_exp                      shift and go to state 145
    expression                     shift and go to state 102
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 122

    (112) condition -> IF LPAREN . super_exp RPAREN openjumpslot block filljumps
    (113) condition -> IF LPAREN . super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (57) super_exp -> . expression super_exp_quadgen super_exp_aux
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    super_exp                      shift and go to state 146
    expression                     shift and go to state 102
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 123

    (101) assignment -> var_access assignment_sign . expression SEMICOLON
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    var_access                     shift and go to state 108
    expression                     shift and go to state 147
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    call                           shift and go to state 109

state 124

    (102) assignment_sign -> ASSIGN .
    LPAREN          reduce using rule 102 (assignment_sign -> ASSIGN .)
    CTEBOOL         reduce using rule 102 (assignment_sign -> ASSIGN .)
    CTEFLOAT        reduce using rule 102 (assignment_sign -> ASSIGN .)
    CTEINT          reduce using rule 102 (assignment_sign -> ASSIGN .)
    ID              reduce using rule 102 (assignment_sign -> ASSIGN .)


state 125

    (36) dim -> LBRACKET CTEINT COLON CTEINT RBRACKET dim .
    COMMA           reduce using rule 36 (dim -> LBRACKET CTEINT COLON CTEINT RBRACKET dim .)
    SEMICOLON       reduce using rule 36 (dim -> LBRACKET CTEINT COLON CTEINT RBRACKET dim .)


state 126

    (57) super_exp -> expression super_exp_quadgen . super_exp_aux
    (55) super_exp_aux -> . logic super_exp
    (56) super_exp_aux -> . empty
    (58) logic -> . OR
    (59) logic -> . AND
    (135) empty -> .
    OR              shift and go to state 151
    AND             shift and go to state 152
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    super_exp_aux                  shift and go to state 148
    logic                          shift and go to state 149
    empty                          shift and go to state 150

state 127

    (63) expression -> exp expression_quadgen . expression_aux
    (61) expression_aux -> . relation expression
    (62) expression_aux -> . empty
    (64) relation -> . NEQ
    (65) relation -> . EQ
    (66) relation -> . LTE
    (67) relation -> . GTE
    (68) relation -> . LT
    (69) relation -> . GT
    (135) empty -> .
    NEQ             shift and go to state 156
    EQ              shift and go to state 157
    LTE             shift and go to state 158
    GTE             shift and go to state 159
    LT              shift and go to state 160
    GT              shift and go to state 161
    OR              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

    expression_aux                 shift and go to state 153
    relation                       shift and go to state 154
    empty                          shift and go to state 155

state 128

    (73) exp -> term exp_quadgen . exp_aux
    (71) exp_aux -> . exp_sign exp
    (72) exp_aux -> . empty
    (74) exp_sign -> . MINUS
    (75) exp_sign -> . PLUS
    (135) empty -> .
    MINUS           shift and go to state 165
    PLUS            shift and go to state 166
    NEQ             reduce using rule 135 (empty -> .)
    EQ              reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)

    exp_aux                        shift and go to state 162
    exp_sign                       shift and go to state 163
    empty                          shift and go to state 164

state 129

    (79) term -> factor term_quadgen . term_aux
    (77) term_aux -> . term_sign term
    (78) term_aux -> . empty
    (80) term_sign -> . DIVIDE
    (81) term_sign -> . TIMES
    (135) empty -> .
    DIVIDE          shift and go to state 170
    TIMES           shift and go to state 171
    MINUS           reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    EQ              reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)

    term_aux                       shift and go to state 167
    term_sign                      shift and go to state 168
    empty                          shift and go to state 169

state 130

    (83) factor -> LPAREN fakefloor . super_exp RPAREN
    (57) super_exp -> . expression super_exp_quadgen super_exp_aux
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    super_exp                      shift and go to state 172
    expression                     shift and go to state 102
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 131

    (47) call -> ID generate_era LPAREN . callvalues RPAREN
    (52) callvalues -> . empty
    (53) callvalues -> . callvalue callvalues_aux
    (135) empty -> .
    (51) callvalue -> . exp generate_param
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    RPAREN          reduce using rule 135 (empty -> .)
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    callvalues                     shift and go to state 173
    empty                          shift and go to state 174
    callvalue                      shift and go to state 175
    exp                            shift and go to state 176
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 132

    (87) var_access -> ID verify_id access_dim .
    ASSIGN          reduce using rule 87 (var_access -> ID verify_id access_dim .)
    DIVIDE          reduce using rule 87 (var_access -> ID verify_id access_dim .)
    TIMES           reduce using rule 87 (var_access -> ID verify_id access_dim .)
    MINUS           reduce using rule 87 (var_access -> ID verify_id access_dim .)
    PLUS            reduce using rule 87 (var_access -> ID verify_id access_dim .)
    NEQ             reduce using rule 87 (var_access -> ID verify_id access_dim .)
    EQ              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    LTE             reduce using rule 87 (var_access -> ID verify_id access_dim .)
    GTE             reduce using rule 87 (var_access -> ID verify_id access_dim .)
    LT              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    GT              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    OR              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    AND             reduce using rule 87 (var_access -> ID verify_id access_dim .)
    RETURN          reduce using rule 87 (var_access -> ID verify_id access_dim .)
    ID              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    FROM            reduce using rule 87 (var_access -> ID verify_id access_dim .)
    DO              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    WHILE           reduce using rule 87 (var_access -> ID verify_id access_dim .)
    INPUT           reduce using rule 87 (var_access -> ID verify_id access_dim .)
    PRINT           reduce using rule 87 (var_access -> ID verify_id access_dim .)
    IF              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    RCURLY          reduce using rule 87 (var_access -> ID verify_id access_dim .)
    COMMA           reduce using rule 87 (var_access -> ID verify_id access_dim .)
    RPAREN          reduce using rule 87 (var_access -> ID verify_id access_dim .)
    SEMICOLON       reduce using rule 87 (var_access -> ID verify_id access_dim .)
    TO              reduce using rule 87 (var_access -> ID verify_id access_dim .)
    RBRACKET        reduce using rule 87 (var_access -> ID verify_id access_dim .)


state 133

    (90) access_dim -> empty .
    ASSIGN          reduce using rule 90 (access_dim -> empty .)
    DIVIDE          reduce using rule 90 (access_dim -> empty .)
    TIMES           reduce using rule 90 (access_dim -> empty .)
    MINUS           reduce using rule 90 (access_dim -> empty .)
    PLUS            reduce using rule 90 (access_dim -> empty .)
    NEQ             reduce using rule 90 (access_dim -> empty .)
    EQ              reduce using rule 90 (access_dim -> empty .)
    LTE             reduce using rule 90 (access_dim -> empty .)
    GTE             reduce using rule 90 (access_dim -> empty .)
    LT              reduce using rule 90 (access_dim -> empty .)
    GT              reduce using rule 90 (access_dim -> empty .)
    OR              reduce using rule 90 (access_dim -> empty .)
    AND             reduce using rule 90 (access_dim -> empty .)
    RETURN          reduce using rule 90 (access_dim -> empty .)
    ID              reduce using rule 90 (access_dim -> empty .)
    FROM            reduce using rule 90 (access_dim -> empty .)
    DO              reduce using rule 90 (access_dim -> empty .)
    WHILE           reduce using rule 90 (access_dim -> empty .)
    INPUT           reduce using rule 90 (access_dim -> empty .)
    PRINT           reduce using rule 90 (access_dim -> empty .)
    IF              reduce using rule 90 (access_dim -> empty .)
    RCURLY          reduce using rule 90 (access_dim -> empty .)
    COMMA           reduce using rule 90 (access_dim -> empty .)
    RPAREN          reduce using rule 90 (access_dim -> empty .)
    SEMICOLON       reduce using rule 90 (access_dim -> empty .)
    TO              reduce using rule 90 (access_dim -> empty .)
    RBRACKET        reduce using rule 90 (access_dim -> empty .)


state 134

    (91) access_dim -> fakefloor . LBRACKET exp RBRACKET verify_dim access_dim
    LBRACKET        shift and go to state 177


state 135

    (94) forloop -> FROM forloopcontrolvar assignment_sign . expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    expression                     shift and go to state 178
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 136

    (100) dowhileloop -> DO saveposition block . WHILE LPAREN expression RPAREN openjumpslot
    WHILE           shift and go to state 179


state 137

    (4) block -> LCURLY . blockcontent RCURLY
    (6) blockcontent -> . empty
    (7) blockcontent -> . statute blockcontent
    (135) empty -> .
    (124) statute -> . returnstmt
    (125) statute -> . call
    (126) statute -> . forloop
    (127) statute -> . dowhileloop
    (128) statute -> . whileloop
    (129) statute -> . read
    (130) statute -> . write
    (131) statute -> . condition
    (132) statute -> . assignment
    (123) returnstmt -> . RETURN super_exp
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    (94) forloop -> . FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (100) dowhileloop -> . DO saveposition block WHILE LPAREN expression RPAREN openjumpslot
    (99) whileloop -> . WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps
    (103) read -> . INPUT LPAREN readaux RPAREN SEMICOLON
    (107) write -> . PRINT LPAREN writeaux RPAREN SEMICOLON
    (112) condition -> . IF LPAREN super_exp RPAREN openjumpslot block filljumps
    (113) condition -> . IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    (101) assignment -> . var_access assignment_sign expression SEMICOLON
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    RCURLY          reduce using rule 135 (empty -> .)
    RETURN          shift and go to state 87
    ID              shift and go to state 88
    FROM            shift and go to state 89
    DO              shift and go to state 90
    WHILE           shift and go to state 91
    INPUT           shift and go to state 92
    PRINT           shift and go to state 93
    IF              shift and go to state 94

    blockcontent                   shift and go to state 180
    empty                          shift and go to state 76
    statute                        shift and go to state 77
    returnstmt                     shift and go to state 78
    call                           shift and go to state 79
    forloop                        shift and go to state 80
    dowhileloop                    shift and go to state 81
    whileloop                      shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    condition                      shift and go to state 85
    assignment                     shift and go to state 86
    var_access                     shift and go to state 95

state 138

    (99) whileloop -> WHILE saveposition LPAREN . expression RPAREN openjumpslot block filljumps
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    expression                     shift and go to state 181
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 139

    (103) read -> INPUT LPAREN readaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 182


state 140

    (104) readaux -> readvalue . COMMA readaux
    (105) readaux -> readvalue .
    COMMA           shift and go to state 183
    RPAREN          reduce using rule 105 (readaux -> readvalue .)


state 141

    (106) readvalue -> ID .
    COMMA           reduce using rule 106 (readvalue -> ID .)
    RPAREN          reduce using rule 106 (readvalue -> ID .)


state 142

    (107) write -> PRINT LPAREN writeaux . RPAREN SEMICOLON
    RPAREN          shift and go to state 184


state 143

    (108) writeaux -> writevalues .
    (109) writeaux -> writevalues . COMMA writeaux
    RPAREN          reduce using rule 108 (writeaux -> writevalues .)
    COMMA           shift and go to state 185


state 144

    (110) writevalues -> CTESTRING .
    COMMA           reduce using rule 110 (writevalues -> CTESTRING .)
    RPAREN          reduce using rule 110 (writevalues -> CTESTRING .)


state 145

    (111) writevalues -> super_exp .
    COMMA           reduce using rule 111 (writevalues -> super_exp .)
    RPAREN          reduce using rule 111 (writevalues -> super_exp .)


state 146

    (112) condition -> IF LPAREN super_exp . RPAREN openjumpslot block filljumps
    (113) condition -> IF LPAREN super_exp . RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps
    RPAREN          shift and go to state 186


state 147

    (101) assignment -> var_access assignment_sign expression . SEMICOLON
    SEMICOLON       shift and go to state 187


state 148

    (57) super_exp -> expression super_exp_quadgen super_exp_aux .
    RETURN          reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    ID              reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    FROM            reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    DO              reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    WHILE           reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    INPUT           reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    PRINT           reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    IF              reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RCURLY          reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    COMMA           reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)
    RPAREN          reduce using rule 57 (super_exp -> expression super_exp_quadgen super_exp_aux .)


state 149

    (55) super_exp_aux -> logic . super_exp
    (57) super_exp -> . expression super_exp_quadgen super_exp_aux
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    super_exp                      shift and go to state 188
    expression                     shift and go to state 102
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 150

    (56) super_exp_aux -> empty .
    RETURN          reduce using rule 56 (super_exp_aux -> empty .)
    ID              reduce using rule 56 (super_exp_aux -> empty .)
    FROM            reduce using rule 56 (super_exp_aux -> empty .)
    DO              reduce using rule 56 (super_exp_aux -> empty .)
    WHILE           reduce using rule 56 (super_exp_aux -> empty .)
    INPUT           reduce using rule 56 (super_exp_aux -> empty .)
    PRINT           reduce using rule 56 (super_exp_aux -> empty .)
    IF              reduce using rule 56 (super_exp_aux -> empty .)
    RCURLY          reduce using rule 56 (super_exp_aux -> empty .)
    COMMA           reduce using rule 56 (super_exp_aux -> empty .)
    RPAREN          reduce using rule 56 (super_exp_aux -> empty .)


state 151

    (58) logic -> OR .
    LPAREN          reduce using rule 58 (logic -> OR .)
    CTEBOOL         reduce using rule 58 (logic -> OR .)
    CTEFLOAT        reduce using rule 58 (logic -> OR .)
    CTEINT          reduce using rule 58 (logic -> OR .)
    ID              reduce using rule 58 (logic -> OR .)


state 152

    (59) logic -> AND .
    LPAREN          reduce using rule 59 (logic -> AND .)
    CTEBOOL         reduce using rule 59 (logic -> AND .)
    CTEFLOAT        reduce using rule 59 (logic -> AND .)
    CTEINT          reduce using rule 59 (logic -> AND .)
    ID              reduce using rule 59 (logic -> AND .)


state 153

    (63) expression -> exp expression_quadgen expression_aux .
    OR              reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    AND             reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    RETURN          reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    ID              reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    FROM            reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    DO              reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    WHILE           reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    INPUT           reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    PRINT           reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    IF              reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    RCURLY          reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    COMMA           reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    RPAREN          reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    SEMICOLON       reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)
    TO              reduce using rule 63 (expression -> exp expression_quadgen expression_aux .)


state 154

    (61) expression_aux -> relation . expression
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    expression                     shift and go to state 189
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 155

    (62) expression_aux -> empty .
    OR              reduce using rule 62 (expression_aux -> empty .)
    AND             reduce using rule 62 (expression_aux -> empty .)
    RETURN          reduce using rule 62 (expression_aux -> empty .)
    ID              reduce using rule 62 (expression_aux -> empty .)
    FROM            reduce using rule 62 (expression_aux -> empty .)
    DO              reduce using rule 62 (expression_aux -> empty .)
    WHILE           reduce using rule 62 (expression_aux -> empty .)
    INPUT           reduce using rule 62 (expression_aux -> empty .)
    PRINT           reduce using rule 62 (expression_aux -> empty .)
    IF              reduce using rule 62 (expression_aux -> empty .)
    RCURLY          reduce using rule 62 (expression_aux -> empty .)
    COMMA           reduce using rule 62 (expression_aux -> empty .)
    RPAREN          reduce using rule 62 (expression_aux -> empty .)
    SEMICOLON       reduce using rule 62 (expression_aux -> empty .)
    TO              reduce using rule 62 (expression_aux -> empty .)


state 156

    (64) relation -> NEQ .
    LPAREN          reduce using rule 64 (relation -> NEQ .)
    CTEBOOL         reduce using rule 64 (relation -> NEQ .)
    CTEFLOAT        reduce using rule 64 (relation -> NEQ .)
    CTEINT          reduce using rule 64 (relation -> NEQ .)
    ID              reduce using rule 64 (relation -> NEQ .)


state 157

    (65) relation -> EQ .
    LPAREN          reduce using rule 65 (relation -> EQ .)
    CTEBOOL         reduce using rule 65 (relation -> EQ .)
    CTEFLOAT        reduce using rule 65 (relation -> EQ .)
    CTEINT          reduce using rule 65 (relation -> EQ .)
    ID              reduce using rule 65 (relation -> EQ .)


state 158

    (66) relation -> LTE .
    LPAREN          reduce using rule 66 (relation -> LTE .)
    CTEBOOL         reduce using rule 66 (relation -> LTE .)
    CTEFLOAT        reduce using rule 66 (relation -> LTE .)
    CTEINT          reduce using rule 66 (relation -> LTE .)
    ID              reduce using rule 66 (relation -> LTE .)


state 159

    (67) relation -> GTE .
    LPAREN          reduce using rule 67 (relation -> GTE .)
    CTEBOOL         reduce using rule 67 (relation -> GTE .)
    CTEFLOAT        reduce using rule 67 (relation -> GTE .)
    CTEINT          reduce using rule 67 (relation -> GTE .)
    ID              reduce using rule 67 (relation -> GTE .)


state 160

    (68) relation -> LT .
    LPAREN          reduce using rule 68 (relation -> LT .)
    CTEBOOL         reduce using rule 68 (relation -> LT .)
    CTEFLOAT        reduce using rule 68 (relation -> LT .)
    CTEINT          reduce using rule 68 (relation -> LT .)
    ID              reduce using rule 68 (relation -> LT .)


state 161

    (69) relation -> GT .
    LPAREN          reduce using rule 69 (relation -> GT .)
    CTEBOOL         reduce using rule 69 (relation -> GT .)
    CTEFLOAT        reduce using rule 69 (relation -> GT .)
    CTEINT          reduce using rule 69 (relation -> GT .)
    ID              reduce using rule 69 (relation -> GT .)


state 162

    (73) exp -> term exp_quadgen exp_aux .
    NEQ             reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    EQ              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    LTE             reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    GTE             reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    LT              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    GT              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    OR              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    AND             reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    RETURN          reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    ID              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    FROM            reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    DO              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    WHILE           reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    INPUT           reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    PRINT           reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    IF              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    RCURLY          reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    COMMA           reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    RPAREN          reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    SEMICOLON       reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    TO              reduce using rule 73 (exp -> term exp_quadgen exp_aux .)
    RBRACKET        reduce using rule 73 (exp -> term exp_quadgen exp_aux .)


state 163

    (71) exp_aux -> exp_sign . exp
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    exp                            shift and go to state 190
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 164

    (72) exp_aux -> empty .
    NEQ             reduce using rule 72 (exp_aux -> empty .)
    EQ              reduce using rule 72 (exp_aux -> empty .)
    LTE             reduce using rule 72 (exp_aux -> empty .)
    GTE             reduce using rule 72 (exp_aux -> empty .)
    LT              reduce using rule 72 (exp_aux -> empty .)
    GT              reduce using rule 72 (exp_aux -> empty .)
    OR              reduce using rule 72 (exp_aux -> empty .)
    AND             reduce using rule 72 (exp_aux -> empty .)
    RETURN          reduce using rule 72 (exp_aux -> empty .)
    ID              reduce using rule 72 (exp_aux -> empty .)
    FROM            reduce using rule 72 (exp_aux -> empty .)
    DO              reduce using rule 72 (exp_aux -> empty .)
    WHILE           reduce using rule 72 (exp_aux -> empty .)
    INPUT           reduce using rule 72 (exp_aux -> empty .)
    PRINT           reduce using rule 72 (exp_aux -> empty .)
    IF              reduce using rule 72 (exp_aux -> empty .)
    RCURLY          reduce using rule 72 (exp_aux -> empty .)
    COMMA           reduce using rule 72 (exp_aux -> empty .)
    RPAREN          reduce using rule 72 (exp_aux -> empty .)
    SEMICOLON       reduce using rule 72 (exp_aux -> empty .)
    TO              reduce using rule 72 (exp_aux -> empty .)
    RBRACKET        reduce using rule 72 (exp_aux -> empty .)


state 165

    (74) exp_sign -> MINUS .
    LPAREN          reduce using rule 74 (exp_sign -> MINUS .)
    CTEBOOL         reduce using rule 74 (exp_sign -> MINUS .)
    CTEFLOAT        reduce using rule 74 (exp_sign -> MINUS .)
    CTEINT          reduce using rule 74 (exp_sign -> MINUS .)
    ID              reduce using rule 74 (exp_sign -> MINUS .)


state 166

    (75) exp_sign -> PLUS .
    LPAREN          reduce using rule 75 (exp_sign -> PLUS .)
    CTEBOOL         reduce using rule 75 (exp_sign -> PLUS .)
    CTEFLOAT        reduce using rule 75 (exp_sign -> PLUS .)
    CTEINT          reduce using rule 75 (exp_sign -> PLUS .)
    ID              reduce using rule 75 (exp_sign -> PLUS .)


state 167

    (79) term -> factor term_quadgen term_aux .
    MINUS           reduce using rule 79 (term -> factor term_quadgen term_aux .)
    PLUS            reduce using rule 79 (term -> factor term_quadgen term_aux .)
    NEQ             reduce using rule 79 (term -> factor term_quadgen term_aux .)
    EQ              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    LTE             reduce using rule 79 (term -> factor term_quadgen term_aux .)
    GTE             reduce using rule 79 (term -> factor term_quadgen term_aux .)
    LT              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    GT              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    OR              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    AND             reduce using rule 79 (term -> factor term_quadgen term_aux .)
    RETURN          reduce using rule 79 (term -> factor term_quadgen term_aux .)
    ID              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    FROM            reduce using rule 79 (term -> factor term_quadgen term_aux .)
    DO              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    WHILE           reduce using rule 79 (term -> factor term_quadgen term_aux .)
    INPUT           reduce using rule 79 (term -> factor term_quadgen term_aux .)
    PRINT           reduce using rule 79 (term -> factor term_quadgen term_aux .)
    IF              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    RCURLY          reduce using rule 79 (term -> factor term_quadgen term_aux .)
    COMMA           reduce using rule 79 (term -> factor term_quadgen term_aux .)
    RPAREN          reduce using rule 79 (term -> factor term_quadgen term_aux .)
    SEMICOLON       reduce using rule 79 (term -> factor term_quadgen term_aux .)
    TO              reduce using rule 79 (term -> factor term_quadgen term_aux .)
    RBRACKET        reduce using rule 79 (term -> factor term_quadgen term_aux .)


state 168

    (77) term_aux -> term_sign . term
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    term                           shift and go to state 191
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 169

    (78) term_aux -> empty .
    MINUS           reduce using rule 78 (term_aux -> empty .)
    PLUS            reduce using rule 78 (term_aux -> empty .)
    NEQ             reduce using rule 78 (term_aux -> empty .)
    EQ              reduce using rule 78 (term_aux -> empty .)
    LTE             reduce using rule 78 (term_aux -> empty .)
    GTE             reduce using rule 78 (term_aux -> empty .)
    LT              reduce using rule 78 (term_aux -> empty .)
    GT              reduce using rule 78 (term_aux -> empty .)
    OR              reduce using rule 78 (term_aux -> empty .)
    AND             reduce using rule 78 (term_aux -> empty .)
    RETURN          reduce using rule 78 (term_aux -> empty .)
    ID              reduce using rule 78 (term_aux -> empty .)
    FROM            reduce using rule 78 (term_aux -> empty .)
    DO              reduce using rule 78 (term_aux -> empty .)
    WHILE           reduce using rule 78 (term_aux -> empty .)
    INPUT           reduce using rule 78 (term_aux -> empty .)
    PRINT           reduce using rule 78 (term_aux -> empty .)
    IF              reduce using rule 78 (term_aux -> empty .)
    RCURLY          reduce using rule 78 (term_aux -> empty .)
    COMMA           reduce using rule 78 (term_aux -> empty .)
    RPAREN          reduce using rule 78 (term_aux -> empty .)
    SEMICOLON       reduce using rule 78 (term_aux -> empty .)
    TO              reduce using rule 78 (term_aux -> empty .)
    RBRACKET        reduce using rule 78 (term_aux -> empty .)


state 170

    (80) term_sign -> DIVIDE .
    LPAREN          reduce using rule 80 (term_sign -> DIVIDE .)
    CTEBOOL         reduce using rule 80 (term_sign -> DIVIDE .)
    CTEFLOAT        reduce using rule 80 (term_sign -> DIVIDE .)
    CTEINT          reduce using rule 80 (term_sign -> DIVIDE .)
    ID              reduce using rule 80 (term_sign -> DIVIDE .)


state 171

    (81) term_sign -> TIMES .
    LPAREN          reduce using rule 81 (term_sign -> TIMES .)
    CTEBOOL         reduce using rule 81 (term_sign -> TIMES .)
    CTEFLOAT        reduce using rule 81 (term_sign -> TIMES .)
    CTEINT          reduce using rule 81 (term_sign -> TIMES .)
    ID              reduce using rule 81 (term_sign -> TIMES .)


state 172

    (83) factor -> LPAREN fakefloor super_exp . RPAREN
    RPAREN          shift and go to state 192


state 173

    (47) call -> ID generate_era LPAREN callvalues . RPAREN
    RPAREN          shift and go to state 193


state 174

    (52) callvalues -> empty .
    RPAREN          reduce using rule 52 (callvalues -> empty .)


state 175

    (53) callvalues -> callvalue . callvalues_aux
    (49) callvalues_aux -> . empty
    (50) callvalues_aux -> . COMMA callvalues
    (135) empty -> .
    COMMA           shift and go to state 196
    RPAREN          reduce using rule 135 (empty -> .)

    callvalues_aux                 shift and go to state 194
    empty                          shift and go to state 195

state 176

    (51) callvalue -> exp . generate_param
    (54) generate_param -> .
    COMMA           reduce using rule 54 (generate_param -> .)
    RPAREN          reduce using rule 54 (generate_param -> .)

    generate_param                 shift and go to state 197

state 177

    (91) access_dim -> fakefloor LBRACKET . exp RBRACKET verify_dim access_dim
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    exp                            shift and go to state 198
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 178

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression . validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (96) validatecontrolvar -> .
    TO              reduce using rule 96 (validatecontrolvar -> .)

    validatecontrolvar             shift and go to state 199

state 179

    (100) dowhileloop -> DO saveposition block WHILE . LPAREN expression RPAREN openjumpslot
    LPAREN          shift and go to state 200


state 180

    (4) block -> LCURLY blockcontent . RCURLY
    RCURLY          shift and go to state 201


state 181

    (99) whileloop -> WHILE saveposition LPAREN expression . RPAREN openjumpslot block filljumps
    RPAREN          shift and go to state 202


state 182

    (103) read -> INPUT LPAREN readaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 203


state 183

    (104) readaux -> readvalue COMMA . readaux
    (104) readaux -> . readvalue COMMA readaux
    (105) readaux -> . readvalue
    (106) readvalue -> . ID
    ID              shift and go to state 141

    readvalue                      shift and go to state 140
    readaux                        shift and go to state 204

state 184

    (107) write -> PRINT LPAREN writeaux RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 205


state 185

    (109) writeaux -> writevalues COMMA . writeaux
    (108) writeaux -> . writevalues
    (109) writeaux -> . writevalues COMMA writeaux
    (110) writevalues -> . CTESTRING
    (111) writevalues -> . super_exp
    (57) super_exp -> . expression super_exp_quadgen super_exp_aux
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    CTESTRING       shift and go to state 144
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    writevalues                    shift and go to state 143
    writeaux                       shift and go to state 206
    super_exp                      shift and go to state 145
    expression                     shift and go to state 102
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 186

    (112) condition -> IF LPAREN super_exp RPAREN . openjumpslot block filljumps
    (113) condition -> IF LPAREN super_exp RPAREN . openjumpslot block ELSE filljumps openjumpslot block filljumps
    (114) openjumpslot -> .
    LCURLY          reduce using rule 114 (openjumpslot -> .)

    openjumpslot                   shift and go to state 207

state 187

    (101) assignment -> var_access assignment_sign expression SEMICOLON .
    RETURN          reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    ID              reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    FROM            reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    DO              reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    WHILE           reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    INPUT           reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    PRINT           reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    IF              reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)
    RCURLY          reduce using rule 101 (assignment -> var_access assignment_sign expression SEMICOLON .)


state 188

    (55) super_exp_aux -> logic super_exp .
    RETURN          reduce using rule 55 (super_exp_aux -> logic super_exp .)
    ID              reduce using rule 55 (super_exp_aux -> logic super_exp .)
    FROM            reduce using rule 55 (super_exp_aux -> logic super_exp .)
    DO              reduce using rule 55 (super_exp_aux -> logic super_exp .)
    WHILE           reduce using rule 55 (super_exp_aux -> logic super_exp .)
    INPUT           reduce using rule 55 (super_exp_aux -> logic super_exp .)
    PRINT           reduce using rule 55 (super_exp_aux -> logic super_exp .)
    IF              reduce using rule 55 (super_exp_aux -> logic super_exp .)
    RCURLY          reduce using rule 55 (super_exp_aux -> logic super_exp .)
    COMMA           reduce using rule 55 (super_exp_aux -> logic super_exp .)
    RPAREN          reduce using rule 55 (super_exp_aux -> logic super_exp .)


state 189

    (61) expression_aux -> relation expression .
    OR              reduce using rule 61 (expression_aux -> relation expression .)
    AND             reduce using rule 61 (expression_aux -> relation expression .)
    RETURN          reduce using rule 61 (expression_aux -> relation expression .)
    ID              reduce using rule 61 (expression_aux -> relation expression .)
    FROM            reduce using rule 61 (expression_aux -> relation expression .)
    DO              reduce using rule 61 (expression_aux -> relation expression .)
    WHILE           reduce using rule 61 (expression_aux -> relation expression .)
    INPUT           reduce using rule 61 (expression_aux -> relation expression .)
    PRINT           reduce using rule 61 (expression_aux -> relation expression .)
    IF              reduce using rule 61 (expression_aux -> relation expression .)
    RCURLY          reduce using rule 61 (expression_aux -> relation expression .)
    COMMA           reduce using rule 61 (expression_aux -> relation expression .)
    RPAREN          reduce using rule 61 (expression_aux -> relation expression .)
    SEMICOLON       reduce using rule 61 (expression_aux -> relation expression .)
    TO              reduce using rule 61 (expression_aux -> relation expression .)


state 190

    (71) exp_aux -> exp_sign exp .
    NEQ             reduce using rule 71 (exp_aux -> exp_sign exp .)
    EQ              reduce using rule 71 (exp_aux -> exp_sign exp .)
    LTE             reduce using rule 71 (exp_aux -> exp_sign exp .)
    GTE             reduce using rule 71 (exp_aux -> exp_sign exp .)
    LT              reduce using rule 71 (exp_aux -> exp_sign exp .)
    GT              reduce using rule 71 (exp_aux -> exp_sign exp .)
    OR              reduce using rule 71 (exp_aux -> exp_sign exp .)
    AND             reduce using rule 71 (exp_aux -> exp_sign exp .)
    RETURN          reduce using rule 71 (exp_aux -> exp_sign exp .)
    ID              reduce using rule 71 (exp_aux -> exp_sign exp .)
    FROM            reduce using rule 71 (exp_aux -> exp_sign exp .)
    DO              reduce using rule 71 (exp_aux -> exp_sign exp .)
    WHILE           reduce using rule 71 (exp_aux -> exp_sign exp .)
    INPUT           reduce using rule 71 (exp_aux -> exp_sign exp .)
    PRINT           reduce using rule 71 (exp_aux -> exp_sign exp .)
    IF              reduce using rule 71 (exp_aux -> exp_sign exp .)
    RCURLY          reduce using rule 71 (exp_aux -> exp_sign exp .)
    COMMA           reduce using rule 71 (exp_aux -> exp_sign exp .)
    RPAREN          reduce using rule 71 (exp_aux -> exp_sign exp .)
    SEMICOLON       reduce using rule 71 (exp_aux -> exp_sign exp .)
    TO              reduce using rule 71 (exp_aux -> exp_sign exp .)
    RBRACKET        reduce using rule 71 (exp_aux -> exp_sign exp .)


state 191

    (77) term_aux -> term_sign term .
    MINUS           reduce using rule 77 (term_aux -> term_sign term .)
    PLUS            reduce using rule 77 (term_aux -> term_sign term .)
    NEQ             reduce using rule 77 (term_aux -> term_sign term .)
    EQ              reduce using rule 77 (term_aux -> term_sign term .)
    LTE             reduce using rule 77 (term_aux -> term_sign term .)
    GTE             reduce using rule 77 (term_aux -> term_sign term .)
    LT              reduce using rule 77 (term_aux -> term_sign term .)
    GT              reduce using rule 77 (term_aux -> term_sign term .)
    OR              reduce using rule 77 (term_aux -> term_sign term .)
    AND             reduce using rule 77 (term_aux -> term_sign term .)
    RETURN          reduce using rule 77 (term_aux -> term_sign term .)
    ID              reduce using rule 77 (term_aux -> term_sign term .)
    FROM            reduce using rule 77 (term_aux -> term_sign term .)
    DO              reduce using rule 77 (term_aux -> term_sign term .)
    WHILE           reduce using rule 77 (term_aux -> term_sign term .)
    INPUT           reduce using rule 77 (term_aux -> term_sign term .)
    PRINT           reduce using rule 77 (term_aux -> term_sign term .)
    IF              reduce using rule 77 (term_aux -> term_sign term .)
    RCURLY          reduce using rule 77 (term_aux -> term_sign term .)
    COMMA           reduce using rule 77 (term_aux -> term_sign term .)
    RPAREN          reduce using rule 77 (term_aux -> term_sign term .)
    SEMICOLON       reduce using rule 77 (term_aux -> term_sign term .)
    TO              reduce using rule 77 (term_aux -> term_sign term .)
    RBRACKET        reduce using rule 77 (term_aux -> term_sign term .)


state 192

    (83) factor -> LPAREN fakefloor super_exp RPAREN .
    DIVIDE          reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TIMES           reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    MINUS           reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PLUS            reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    NEQ             reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    EQ              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LTE             reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GTE             reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    LT              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    GT              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    OR              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    AND             reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RETURN          reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    ID              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    FROM            reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    DO              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    WHILE           reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    INPUT           reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    PRINT           reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    IF              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RCURLY          reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    COMMA           reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RPAREN          reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    SEMICOLON       reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    TO              reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)
    RBRACKET        reduce using rule 83 (factor -> LPAREN fakefloor super_exp RPAREN .)


state 193

    (47) call -> ID generate_era LPAREN callvalues RPAREN .
    RETURN          reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    ID              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    FROM            reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    DO              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    WHILE           reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    INPUT           reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    PRINT           reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    IF              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RCURLY          reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    DIVIDE          reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    TIMES           reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    MINUS           reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    PLUS            reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    NEQ             reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    EQ              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    LTE             reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    GTE             reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    LT              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    GT              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    OR              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    AND             reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    COMMA           reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RPAREN          reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    SEMICOLON       reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    TO              reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)
    RBRACKET        reduce using rule 47 (call -> ID generate_era LPAREN callvalues RPAREN .)


state 194

    (53) callvalues -> callvalue callvalues_aux .
    RPAREN          reduce using rule 53 (callvalues -> callvalue callvalues_aux .)


state 195

    (49) callvalues_aux -> empty .
    RPAREN          reduce using rule 49 (callvalues_aux -> empty .)


state 196

    (50) callvalues_aux -> COMMA . callvalues
    (52) callvalues -> . empty
    (53) callvalues -> . callvalue callvalues_aux
    (135) empty -> .
    (51) callvalue -> . exp generate_param
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    RPAREN          reduce using rule 135 (empty -> .)
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    callvalues                     shift and go to state 208
    empty                          shift and go to state 174
    callvalue                      shift and go to state 175
    exp                            shift and go to state 176
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 197

    (51) callvalue -> exp generate_param .
    COMMA           reduce using rule 51 (callvalue -> exp generate_param .)
    RPAREN          reduce using rule 51 (callvalue -> exp generate_param .)


state 198

    (91) access_dim -> fakefloor LBRACKET exp . RBRACKET verify_dim access_dim
    RBRACKET        shift and go to state 209


state 199

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar . TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    TO              shift and go to state 210


state 200

    (100) dowhileloop -> DO saveposition block WHILE LPAREN . expression RPAREN openjumpslot
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    expression                     shift and go to state 211
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 201

    (4) block -> LCURLY blockcontent RCURLY .
    WHILE           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ELSE            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RETURN          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    ID              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    FROM            reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    DO              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    INPUT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    PRINT           reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    IF              reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)
    RCURLY          reduce using rule 4 (block -> LCURLY blockcontent RCURLY .)


state 202

    (99) whileloop -> WHILE saveposition LPAREN expression RPAREN . openjumpslot block filljumps
    (114) openjumpslot -> .
    LCURLY          reduce using rule 114 (openjumpslot -> .)

    openjumpslot                   shift and go to state 212

state 203

    (103) read -> INPUT LPAREN readaux RPAREN SEMICOLON .
    RETURN          reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    ID              reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    FROM            reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    DO              reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    IF              reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 103 (read -> INPUT LPAREN readaux RPAREN SEMICOLON .)


state 204

    (104) readaux -> readvalue COMMA readaux .
    RPAREN          reduce using rule 104 (readaux -> readvalue COMMA readaux .)


state 205

    (107) write -> PRINT LPAREN writeaux RPAREN SEMICOLON .
    RETURN          reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    ID              reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    FROM            reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    DO              reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    WHILE           reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    INPUT           reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    PRINT           reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    IF              reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)
    RCURLY          reduce using rule 107 (write -> PRINT LPAREN writeaux RPAREN SEMICOLON .)


state 206

    (109) writeaux -> writevalues COMMA writeaux .
    RPAREN          reduce using rule 109 (writeaux -> writevalues COMMA writeaux .)


state 207

    (112) condition -> IF LPAREN super_exp RPAREN openjumpslot . block filljumps
    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot . block ELSE filljumps openjumpslot block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 137

    block                          shift and go to state 213

state 208

    (50) callvalues_aux -> COMMA callvalues .
    RPAREN          reduce using rule 50 (callvalues_aux -> COMMA callvalues .)


state 209

    (91) access_dim -> fakefloor LBRACKET exp RBRACKET . verify_dim access_dim
    (92) verify_dim -> .
    LBRACKET        reduce using rule 92 (verify_dim -> .)
    ASSIGN          reduce using rule 92 (verify_dim -> .)
    DIVIDE          reduce using rule 92 (verify_dim -> .)
    TIMES           reduce using rule 92 (verify_dim -> .)
    MINUS           reduce using rule 92 (verify_dim -> .)
    PLUS            reduce using rule 92 (verify_dim -> .)
    NEQ             reduce using rule 92 (verify_dim -> .)
    EQ              reduce using rule 92 (verify_dim -> .)
    LTE             reduce using rule 92 (verify_dim -> .)
    GTE             reduce using rule 92 (verify_dim -> .)
    LT              reduce using rule 92 (verify_dim -> .)
    GT              reduce using rule 92 (verify_dim -> .)
    OR              reduce using rule 92 (verify_dim -> .)
    AND             reduce using rule 92 (verify_dim -> .)
    RETURN          reduce using rule 92 (verify_dim -> .)
    ID              reduce using rule 92 (verify_dim -> .)
    FROM            reduce using rule 92 (verify_dim -> .)
    DO              reduce using rule 92 (verify_dim -> .)
    WHILE           reduce using rule 92 (verify_dim -> .)
    INPUT           reduce using rule 92 (verify_dim -> .)
    PRINT           reduce using rule 92 (verify_dim -> .)
    IF              reduce using rule 92 (verify_dim -> .)
    RCURLY          reduce using rule 92 (verify_dim -> .)
    COMMA           reduce using rule 92 (verify_dim -> .)
    RPAREN          reduce using rule 92 (verify_dim -> .)
    SEMICOLON       reduce using rule 92 (verify_dim -> .)
    TO              reduce using rule 92 (verify_dim -> .)
    RBRACKET        reduce using rule 92 (verify_dim -> .)

    verify_dim                     shift and go to state 214

state 210

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO . createfinaltempvar expression validateloopend DO openjumpslot block filljumps
    (97) createfinaltempvar -> .
    LPAREN          reduce using rule 97 (createfinaltempvar -> .)
    CTEBOOL         reduce using rule 97 (createfinaltempvar -> .)
    CTEFLOAT        reduce using rule 97 (createfinaltempvar -> .)
    CTEINT          reduce using rule 97 (createfinaltempvar -> .)
    ID              reduce using rule 97 (createfinaltempvar -> .)

    createfinaltempvar             shift and go to state 215

state 211

    (100) dowhileloop -> DO saveposition block WHILE LPAREN expression . RPAREN openjumpslot
    RPAREN          shift and go to state 216


state 212

    (99) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 137

    block                          shift and go to state 217

state 213

    (112) condition -> IF LPAREN super_exp RPAREN openjumpslot block . filljumps
    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot block . ELSE filljumps openjumpslot block filljumps
    (116) filljumps -> .
    ELSE            shift and go to state 219
    RETURN          reduce using rule 116 (filljumps -> .)
    ID              reduce using rule 116 (filljumps -> .)
    FROM            reduce using rule 116 (filljumps -> .)
    DO              reduce using rule 116 (filljumps -> .)
    WHILE           reduce using rule 116 (filljumps -> .)
    INPUT           reduce using rule 116 (filljumps -> .)
    PRINT           reduce using rule 116 (filljumps -> .)
    IF              reduce using rule 116 (filljumps -> .)
    RCURLY          reduce using rule 116 (filljumps -> .)

    filljumps                      shift and go to state 218

state 214

    (91) access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim . access_dim
    (90) access_dim -> . empty
    (91) access_dim -> . fakefloor LBRACKET exp RBRACKET verify_dim access_dim
    (135) empty -> .
    (93) fakefloor -> .
    ASSIGN          reduce using rule 135 (empty -> .)
    DIVIDE          reduce using rule 135 (empty -> .)
    TIMES           reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    NEQ             reduce using rule 135 (empty -> .)
    EQ              reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    FROM            reduce using rule 135 (empty -> .)
    DO              reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    INPUT           reduce using rule 135 (empty -> .)
    PRINT           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    SEMICOLON       reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    LBRACKET        reduce using rule 93 (fakefloor -> .)

    fakefloor                      shift and go to state 134
    access_dim                     shift and go to state 220
    empty                          shift and go to state 133

state 215

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar . expression validateloopend DO openjumpslot block filljumps
    (63) expression -> . exp expression_quadgen expression_aux
    (73) exp -> . term exp_quadgen exp_aux
    (79) term -> . factor term_quadgen term_aux
    (83) factor -> . LPAREN fakefloor super_exp RPAREN
    (84) factor -> . varcte
    (85) factor -> . var_access
    (86) factor -> . call
    (117) varcte -> . CTEBOOL
    (118) varcte -> . CTEFLOAT
    (119) varcte -> . CTEINT
    (87) var_access -> . ID verify_id access_dim
    (88) var_access -> . ID
    (47) call -> . ID generate_era LPAREN callvalues RPAREN
    LPAREN          shift and go to state 106
    CTEBOOL         shift and go to state 110
    CTEFLOAT        shift and go to state 111
    CTEINT          shift and go to state 112
    ID              shift and go to state 113

    expression                     shift and go to state 221
    exp                            shift and go to state 103
    term                           shift and go to state 104
    factor                         shift and go to state 105
    varcte                         shift and go to state 107
    var_access                     shift and go to state 108
    call                           shift and go to state 109

state 216

    (100) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN . openjumpslot
    (114) openjumpslot -> .
    RETURN          reduce using rule 114 (openjumpslot -> .)
    ID              reduce using rule 114 (openjumpslot -> .)
    FROM            reduce using rule 114 (openjumpslot -> .)
    DO              reduce using rule 114 (openjumpslot -> .)
    WHILE           reduce using rule 114 (openjumpslot -> .)
    INPUT           reduce using rule 114 (openjumpslot -> .)
    PRINT           reduce using rule 114 (openjumpslot -> .)
    IF              reduce using rule 114 (openjumpslot -> .)
    RCURLY          reduce using rule 114 (openjumpslot -> .)

    openjumpslot                   shift and go to state 222

state 217

    (99) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block . filljumps
    (116) filljumps -> .
    RETURN          reduce using rule 116 (filljumps -> .)
    ID              reduce using rule 116 (filljumps -> .)
    FROM            reduce using rule 116 (filljumps -> .)
    DO              reduce using rule 116 (filljumps -> .)
    WHILE           reduce using rule 116 (filljumps -> .)
    INPUT           reduce using rule 116 (filljumps -> .)
    PRINT           reduce using rule 116 (filljumps -> .)
    IF              reduce using rule 116 (filljumps -> .)
    RCURLY          reduce using rule 116 (filljumps -> .)

    filljumps                      shift and go to state 223

state 218

    (112) condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .
    RETURN          reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    ID              reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 112 (condition -> IF LPAREN super_exp RPAREN openjumpslot block filljumps .)


state 219

    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE . filljumps openjumpslot block filljumps
    (116) filljumps -> .
    LCURLY          reduce using rule 116 (filljumps -> .)

    filljumps                      shift and go to state 224

state 220

    (91) access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .
    ASSIGN          reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    DIVIDE          reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    TIMES           reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    MINUS           reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    PLUS            reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    NEQ             reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    EQ              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    LTE             reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    GTE             reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    LT              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    GT              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    OR              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    AND             reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    RETURN          reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    ID              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    FROM            reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    DO              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    WHILE           reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    INPUT           reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    PRINT           reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    IF              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    RCURLY          reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    COMMA           reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    RPAREN          reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    SEMICOLON       reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    TO              reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)
    RBRACKET        reduce using rule 91 (access_dim -> fakefloor LBRACKET exp RBRACKET verify_dim access_dim .)


state 221

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression . validateloopend DO openjumpslot block filljumps
    (98) validateloopend -> .
    DO              reduce using rule 98 (validateloopend -> .)

    validateloopend                shift and go to state 225

state 222

    (100) dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .
    RETURN          reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    ID              reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    FROM            reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    DO              reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    WHILE           reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    INPUT           reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    PRINT           reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    IF              reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)
    RCURLY          reduce using rule 100 (dowhileloop -> DO saveposition block WHILE LPAREN expression RPAREN openjumpslot .)


state 223

    (99) whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .
    RETURN          reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    ID              reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    FROM            reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    DO              reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    WHILE           reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    INPUT           reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    PRINT           reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    IF              reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)
    RCURLY          reduce using rule 99 (whileloop -> WHILE saveposition LPAREN expression RPAREN openjumpslot block filljumps .)


state 224

    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps . openjumpslot block filljumps
    (114) openjumpslot -> .
    LCURLY          reduce using rule 114 (openjumpslot -> .)

    openjumpslot                   shift and go to state 226

state 225

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend . DO openjumpslot block filljumps
    DO              shift and go to state 227


state 226

    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 137

    block                          shift and go to state 228

state 227

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO . openjumpslot block filljumps
    (114) openjumpslot -> .
    LCURLY          reduce using rule 114 (openjumpslot -> .)

    openjumpslot                   shift and go to state 229

state 228

    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block . filljumps
    (116) filljumps -> .
    RETURN          reduce using rule 116 (filljumps -> .)
    ID              reduce using rule 116 (filljumps -> .)
    FROM            reduce using rule 116 (filljumps -> .)
    DO              reduce using rule 116 (filljumps -> .)
    WHILE           reduce using rule 116 (filljumps -> .)
    INPUT           reduce using rule 116 (filljumps -> .)
    PRINT           reduce using rule 116 (filljumps -> .)
    IF              reduce using rule 116 (filljumps -> .)
    RCURLY          reduce using rule 116 (filljumps -> .)

    filljumps                      shift and go to state 230

state 229

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot . block filljumps
    (4) block -> . LCURLY blockcontent RCURLY
    LCURLY          shift and go to state 137

    block                          shift and go to state 231

state 230

    (113) condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .
    RETURN          reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    ID              reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    FROM            reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    DO              reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    WHILE           reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    INPUT           reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    PRINT           reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    IF              reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)
    RCURLY          reduce using rule 113 (condition -> IF LPAREN super_exp RPAREN openjumpslot block ELSE filljumps openjumpslot block filljumps .)


state 231

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block . filljumps
    (116) filljumps -> .
    RETURN          reduce using rule 116 (filljumps -> .)
    ID              reduce using rule 116 (filljumps -> .)
    FROM            reduce using rule 116 (filljumps -> .)
    DO              reduce using rule 116 (filljumps -> .)
    WHILE           reduce using rule 116 (filljumps -> .)
    INPUT           reduce using rule 116 (filljumps -> .)
    PRINT           reduce using rule 116 (filljumps -> .)
    IF              reduce using rule 116 (filljumps -> .)
    RCURLY          reduce using rule 116 (filljumps -> .)

    filljumps                      shift and go to state 232

state 232

    (94) forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .
    RETURN          reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    ID              reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    FROM            reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    DO              reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    WHILE           reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    INPUT           reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    PRINT           reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    IF              reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)
    RCURLY          reduce using rule 94 (forloop -> FROM forloopcontrolvar assignment_sign expression validatecontrolvar TO createfinaltempvar expression validateloopend DO openjumpslot block filljumps .)


Conflicts:

reduce/reduce conflict in state 88 resolved using rule var_access -> ID
rejected rule (verify_id -> <empty>) in state 88
reduce/reduce conflict in state 113 resolved using rule var_access -> ID
rejected rule (verify_id -> <empty>) in state 113